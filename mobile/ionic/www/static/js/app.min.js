(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
require('./account.nav.js');
require('./account.profile.js');
require('./account.login.js');

angular.module('app.controllers.account', [
		'app.controllers.account.nav',
		'app.controllers.account.profile',
		'app.controllers.account.login',
	])

},{"./account.login.js":2,"./account.nav.js":3,"./account.profile.js":4}],2:[function(require,module,exports){
angular.module('app.controllers.account.login', [])
.controller('loginCtrl',['$scope', '$rootScope','$state', 'authService', 'localStorageService', 
	function ($scope, $rootScope, $state,authService, localStorageService) {
	    $scope.credentials = {
	        username: 'demouser',
	        password: 'demouser'
	    };

	    $scope.login=function(){
	        authService.login($scope.credentials).then(
	            function(token){
	                $rootScope.$state.go('root.home')
	            },
	            function(err){
	                console.log(err);
	                $scope.credentials.password = '';
	            }
	        )

	    }
	}
]);

},{}],3:[function(require,module,exports){
angular.module('app.controllers.account.nav', [])

	.controller('profileNavCtrl', ['$scope', '$rootScope', function ($scope, $rootScope) {

	}])
},{}],4:[function(require,module,exports){
angular.module('app.controllers.account.profile', [])

    .controller('profileUserCtrl', ['$q', '$scope', '$rootScope', '$timeout', 'UserService', 'CompanyService', 'accountService', '$ionicPopover', 
        function ($q, $scope, $rootScope, $timeout, UserService, CompanyService, accountService, $ionicPopover) {

        // Clones of resources used when the user cancels an edit.
        $scope.originals = {};

        $scope.editEntryConfig = {
            isVisible: false,
            title: 'New record',
            view: "template/dialog.generic.compare.html",
            model: [
                {
                    type: 'email',
                    name: 'value',
                    value: '',
                },
                {
                    type: 'email',
                    name: 'value',
                    value: '',
                }
            ],
            onOk: function(){
                this.hide();
            },
            onCancel: function(){
                this.hide();
            }
        };

        $scope.load = function(){
            $scope.loading = true;
            var promise = $q.all([
                UserService.get(),
                //CompanyService.get()
            ])
            .then(function(result)    {
                $scope.loading = false;

                $scope.entity = result[0];
                $scope.originals.entity = angular.copy($scope.entity);

            })
        }

        $ionicPopover.fromTemplateUrl('template/popover-confirm-email.html', { scope: $scope, focusFirstInput: true }).then(function(popover) {
            $scope.popoverEmail = popover;    
            $scope.popoverEmail.model = {
                type: 'email',
                title: '新邮箱地址',
                confirmTitle: '请再次确认新邮箱地址',
                value: '',
                value2: ''
            };        
            $scope.popoverEmail.onOk = function(){
                $scope.entity.email = $scope.popoverEmail.model.value;
                $scope.editForm.$setDirty();

                $scope.popoverEmail.model.value =   
                $scope.popoverEmail.model.value2 = '';   
                $scope.popoverEmail.hide();
            }
            $scope.popoverEmail.onCancel = function(){
                $scope.popoverEmail.hide();
                $scope.popoverEmail.model.value =   
                $scope.popoverEmail.model.value2 = '';   
            }
        });

        $ionicPopover.fromTemplateUrl('template/popover-confirm-password.html', { scope: $scope }).then(function(popover) {
            $scope.popoverPassword = popover;
            $scope.popoverPassword.model = {
                type: 'email',
                title: '新邮箱地址',
                confirmTitle: '请再次确认新邮箱地址',
                value: '',
                value2: ''
            };
            $scope.popoverPassword.onOk = function(){
                $scope.entity.password = $scope.popoverPassword.model.value;
                $scope.editForm.$setDirty();
                
                $scope.popoverPassword.model.value =   
                $scope.popoverPassword.model.value2 = '';   
                $scope.popoverPassword.hide();
            }
            $scope.popoverPassword.onCancel = function(){
                $scope.popoverPassword.hide();
                $scope.popoverPassword.model.value =   
                $scope.popoverPassword.model.value2 = '';   
            }
        });

        $scope.onEmailChanging = function(e){

            $scope.popoverEmail.show(e);            


            // $scope.editEntryConfig.title = '邮箱';
            // $scope.editEntryConfig.model[0].type =
            // $scope.editEntryConfig.model[1].type = 'email';
            // $scope.editEntryConfig.model[0].name = '新邮箱地址';
            // $scope.editEntryConfig.model[1].name = '请再次确认新邮箱地址';
            // $scope.editEntryConfig.onOk = function(){
            //     $scope.entity.email = $scope.editEntryConfig.model[0].value;
            //     this.hide();
            // }
            // $scope.editEntryConfig.show();
        }

        $scope.onPasswordChanging = function(e){

            $scope.popoverPassword.show(e);            

            // $scope.editEntryConfig.title = '密码';
            // $scope.editEntryConfig.model[0].type = 
            // $scope.editEntryConfig.model[1].type = 'password';
            // $scope.editEntryConfig.model[0].name = '新密码';
            // $scope.editEntryConfig.model[1].name = '请再次确认新密码';
            // $scope.editEntryConfig.onOk = function(){
            //     $scope.entity.password = $scope.editEntryConfig.model[0].value;
            //     this.hide();
            // }
            // $scope.editEntryConfig.show();
        }

        $scope.onAvatarSelected = function (file) {
            UserService.uploadAvatar($scope.originals.entity.id, file).then(function(result){
                //$rootScope.user.avatar = newClientSettings.avatar;
                //$rootScope.loadSettings();
                accountService.reload();
            })
        };

        $scope.saveEntity = function() {
            UserService.save($scope.originals.entity.id, $scope.entity).then(function(result) {
                $scope.entity = angular.copy(result.config.data);
                $scope.originals.entity = angular.copy($scope.entity);
                
                accountService.reload();
                $scope.editForm.$setPristine();
            });
        };

        $scope.resetEntity = function() {
            $scope.editForm.$setPristine();
            $scope.entity = angular.copy($scope.originals.entity);
        }

        $scope.isClean = function(){
            return angular.equals($scope.originals.entity, $scope.entity);
        }

        // Obtain resources
        $scope.load();
}])

    .controller('profileCompanyCtrl', ['$q', '$scope', '$rootScope', '$timeout', 'UserService', 'CompanyService', 'accountService', function ($q, $scope, $rootScope, $timeout, UserService, CompanyService, accountService) {

        $scope.originals = {};

        $scope.load = function(){
            $scope.loading = true;
            var promise = $q.all([
                    //UserService.get(),
                    CompanyService.get()
                ])
                .then(function(result)    {
                    $scope.loading = false;

                    $scope.entity = result[0];
                    $scope.originals.entity = angular.copy($scope.entity);
                })
        }

        $scope.onLogoSelected = function (file) {
            CompanyService.uploadLogo($scope.originals.entity.id, file);
            //$rootScope.loadSettings();
            accountService.reload();
        };

        $scope.isClean = function(){
            return angular.equals($scope.originals.entity, $scope.entity);
        }

        $scope.saveEntity = function() {
            CompanyService.save($scope.originals.entity.id, $scope.entity).then(function(result) {
                $scope.entity = angular.copy(result.config.data);
                $scope.originals.entity = angular.copy($scope.entity);

                accountService.reload();
                $scope.editForm.$setPristine();
            });
        };

        $scope.resetEntity = function() {
            $scope.editForm.$setPristine();
            $scope.entity = angular.copy($scope.originals.entity);
        }

        // Obtain resources
        $scope.load();

}])

},{}],5:[function(require,module,exports){
// reserved
angular.module('app.controllers.admin', [])

	.controller('adminCtrl', ['$scope', function($scope) {

	}]);
},{}],6:[function(require,module,exports){
require('./home/home.js');
require('./news/news.js');
require('./reports/reports.js');
require('./recommend/recommend.js');
require('./charts/charts.js');
require('./account/account.js');
require('./admin/admin.js');
require('./nav/nav.js');


angular.module('app.controllers', [
        'app.controllers.home',
        'app.controllers.news',
        'app.controllers.reports',
        'app.controllers.recommendations',
        'app.controllers.charts',
        'app.controllers.account',
        'app.controllers.admin',
        'app.controllers.nav'
    ])

    
    .controller('navCtrl', [
        '$ionicHistory', '$ionicScrollDelegate', '$scope', '$rootScope', '$state', 'toastr', 'toastrConfig', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'DataSource', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
        function ($ionicHistory, $ionicScrollDelegate, $scope, $rootScope, $state, toastr, toastrConfig, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, DataSource, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {

        }
    ])

    .controller('rootCtrl', [
        '$ionicHistory', '$ionicScrollDelegate', '$scope', '$rootScope', '$state', 'toastr', 'toastrConfig', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'DataSource', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
        function ($ionicHistory, $ionicScrollDelegate, $scope, $rootScope, $state, toastr, toastrConfig, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, DataSource, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {

            //Search
            $scope.search = { term: null };
            $scope.navtype = 0;


            // $scope.$watch('navtype', function(newValue, oldValue, scope) {
            // });

            /********************************************************************
             *
             *
             *  Building List
             *
             *
            *********************************************************************/

            // $scope.v2_onBackClicked = function(){

            //     $scope.navtype = 0;
            //     //$scope.selectedUnit = null;
            // }



            // 1. Energy unit browser

            // $scope.buildingListConfig = {
            //     template: 'template/energy-unit-groupped-list.html',
            //     data: DataSource.EnergyUnits(),
            //     datasource: function(){
            //         var units = DataSource.EnergyUnits();
            //         var evens = _.filter(units, function(obj) {
            //             return !$scope.search.term || $scope.search.term.length == 0 || obj.name.toLowerCase().indexOf($scope.search.term.toLowerCase()) >= 0;
            //         });

            //         return evens;
            //     },
            //     filter: function(){
            //       return searchTerm;
            //     },
            //     onMouseEnter: function(e, item){
            //         //item.__highlighted = true;
            //     },
            //     onMouseLeave: function(e, item){
            //         item.__highlighted = false;
            //     },
            //     onClick: function(item, index, e){
            //         $rootScope.$state.go('root.home.unit', {uid: item.id});
            //         //TODO: Highlight marker
            //          $scope.navtype = 1; // to sitemap
                    
            //         _.each($scope.buildingListConfig.datasource(), function(next){
            //           next.__selected = next.id == item.id;
            //           next.__highlighted = false;
            //         })

            //         // Content is hidden and map is shown at energyunit selection view
            //         // Hereby switch to sitemap or display user last visited section, but for selected unit

            //         item.__selected = true;
            //         $scope.selectedUnit = item;

            //         if($scope.sitemapItem) {
            //           $rootScope.$state.go($scope.sitemapItem.href,  {id: $scope.selectedUnit.id});
            //         }

            //     }
            // }
 

            // 2. Sitemap browser

            // $scope.sitemapConfig = {
            //     template: 'template/sitemap.html',
            //     data: 
            //     {
            //         "能源报告":          [
            //                                 { name: '综述指标', href: 'root.home.unit.reports.summary', icon: 'icon-signal' },
            //                                 { name: '最新动态', href: 'root.home.unit.reports.trend', icon: 'icon-area-chart' },
            //                                 { name: '能耗构成', href: 'root.home.unit.reports.disagg', icon: 'icon-pie-chart' },
            //                                 { name: '能耗透视', href: 'root.home.unit.reports.heatmap', icon: 'icon-barcode' },
            //                                 { name: '历史比较', href: 'root.home.unit.reports.monthly', icon: 'icon-bar-chart' },
            //                                 { name: '能耗对比', href: 'root.home.unit.reports.regular', icon: 'icon-line-chart' },
            //                                 { name: "策略分析", href: 'root.home.unit.recommendations.strategies', icon: 'icon-flask' }
            //                             ],
            //         "优化方案":          [
            //                                 { name: "节能方案", href: 'root.home.unit.recommendations.summary', icon: 'icon-pagelines' },
            //                                 // { name: "实时监测", href: 'root.home.unit.recommendations.configuration', icon: 'icon-cog' }
            //                             ],
            //         "能源数据":          [
            //                                 { name: "实时能源数据", href: 'root.home.unit.charts.summary', icon: 'icon-bar-chart' }
            //                             ]
            //     },
            //     onClick: function(item, index, e){

            //         $scope.navtype = 2; // keep sitemap view on selection

            //         // Select clicked and deselect other sitemap items
            //         _.each($scope.sitemapConfig.data, function(categories){
            //             _.each(categories, function(next){
            //                 next.__selected = next == item;
            //             })
            //         })

            //         // EXCEPTION: Show Data page specific navigation
            //         if(item.href == 'root.charts.summary')  {
            //             $scope.navtype = 3;                  
            //             $ionicScrollDelegate.scrollTop();   
            //         }

            //         $scope.sitemapItem = item;
            //         $rootScope.$state.go(item.href, {id: $scope.selectedUnit.id});
            //     }
            // }
            

            // 3. Charts browser

            // $scope.chartsConfig = {
            //     template: 'template/energy-unit-groupped-list.html',
            //     data: [],
            //     onClick: function(item, index, e){
            //         //TODO: Highlight marker
            //         e.preventDefault();
            //         e.stopPropagation();
            //         $scope.navtype = 1;
            //         //$rootScope.$state.go('root.navigation');
            //     }
            // }


 
            // TODO: Simplify this
            // $scope.$watch(
            //     function(){
            //         return DataSource.EnergyUnits();
            //     }, 
            //     function(value){
            //         console.log('value ' , value);
            //         $scope.buildingListConfig.data = DataSource.EnergyUnits();//_.groupBy(EnergyUnitsOfType(1), 'campus');
            //         console.log('$scope.buildingListConfig.data ' , $scope.buildingListConfig.data);
            //     }
            // );


            // $scope.load = function(){

            //     var buildings = DataSource.EnergyUnits();
                
            //     var buildings = result.objects.filter(function (building) {
            //         return building.type == 1;
            //     });



            //     EnergyUnitFactory.getByType(1).then(function(result) {
            //         $scope.buildingListConfig.data = ;
            //     });
            // }

            

    }]);


// a way to manipulate data label line connectors
(function (H) {
    H.wrap(H.seriesTypes.pie.prototype, "drawDataLabels", function (p) {
        var x_offset = 5,
            y_offset = 12;

        p.call(this);

        H.each(this.points, function (p) {
            if (p.dataLabel && p.connector) {
                p.connector.attr({
                    d: [
                        "M",
                        p.dataLabel._pos.x + (p.labelPos[6] === "left" ? -x_offset : x_offset),
                        p.dataLabel._pos.y + y_offset,
                        "L",
                        p.labelPos[4],
                        p.labelPos[5]
                    ]
                });
            }
        });
    });
})(Highcharts)

},{"./account/account.js":1,"./admin/admin.js":5,"./charts/charts.js":7,"./home/home.js":13,"./nav/nav.js":15,"./news/news.js":16,"./recommend/recommend.js":19,"./reports/reports.js":34}],7:[function(require,module,exports){
require('./charts.nav.js');
require('./charts.summary.js');
require('./charts.summary.list.js');
require('./charts.summary.edit.js');
require('./charts.summary.import.js');

angular.module('app.controllers.charts', [
        'app.controllers.charts.nav',
        'app.controllers.charts.summary',
        'app.controllers.charts.summary.list',
        'app.controllers.charts.summary.edit',
        'app.controllers.charts.summary.import'
    ])
},{"./charts.nav.js":8,"./charts.summary.edit.js":9,"./charts.summary.import.js":10,"./charts.summary.js":11,"./charts.summary.list.js":12}],8:[function(require,module,exports){
angular.module('app.controllers.charts.nav', [])
    .factory('chartsNavDeligate', ['$q', '$rootScope', 'EnergyUnitFactory', '$compile', function ($q, $rootScope, EnergyUnitFactory, $compile) {

        return {
            toPDF: function(filePrefix){
                $rootScope.$broadcast('export.pdf', {filePrefix: filePrefix});
            }
        }

    }])
    .controller('chartsNavCtrl', ['$scope', '$rootScope', 'EnergyUnitFactory', '$ionicListDelegate', '$timeout', 'DataSource', '$ionicPopover', '$ionicHistory',
        function ($scope, $rootScope, EnergyUnitFactory, $ionicListDelegate, $timeout, DataSource, $ionicPopover, $ionicHistory) {


        $scope.parentID = 0;
        $scope.maxSeries=8
        var serieColors = ['#F79646', '#4BACC6', '#8064A2', '#9BBB59', '#C0504D', '#4F81BD', '#C0504D', '#1F497D'];
        $scope.originalNodes = [];
        $scope.checkedNodes = [];

        $scope.currentUnit = { name: 'loading...'}

        /********************************************************************
         *
         *
         *  Menu popup Edit / Add / Import 
         *
         *
        *********************************************************************/

        $scope.popData = [
            { name: 'add',  title: 'Add meter', href: 'root.charts.summary.edit', params: { uid: 0, parentID: $rootScope.$stateParams.uid} }, 
            { name: 'import', title: 'Import Data', href: 'root.charts.summary.import'}
        ];
        
        $scope.popSelected = function(item){
            if(item.name == 'add')
            {
                $scope.addMeter(3);
            }

            $rootScope.setActiveView('content');
            $rootScope.go(item.href, angular.extend({uid: $rootScope.$stateParams.uid}, item.params || {}));
            $scope.popover.hide();
        }

        $ionicPopover.fromTemplateUrl('template/popover-list-menu.html', { scope: $scope }).then(function(popover) {
            $scope.popover = popover;
        });

        $scope.onAdd = function(e){
            if($scope.currentUnit.type > 2)
                $scope.popover.show(e)
            else
                $scope.popSelected($scope.popData[0]); // 0 <-- add meter, 1 <-- import data
        }


        // TODO: REMOVE OBSOLETE (see subnav)
        $scope.addMeter = function(type){

            var node = {
                 parent: type == 2 ? null : parseInt($rootScope.$stateParams.uid),
                 //campus: $scope.formData.campus,
                 //influxKey: Math.random().toString(36).substring(7),
                 name: 'New Entity',
                 type: type, // 1 == building, 2 == campus, 3 == meter (default) ...
                 id: 0
             }
             DataSource.addUnit(node);
        }


        $scope.getLevel = function(id, lvl){
            if(!lvl) lvl = 0;

            var item = _.find($scope.originalNodes, function(node){
                return node.id == id;
            });

            return !item ? lvl : $scope.getLevel(item.parent, ++lvl)
        }


        $scope.canSwipe = function(){
            return !$rootScope.disableListSwipping;
        }


        // Send node edit event
        $scope.edit = function (node, evt) {
            if(evt){
                evt.preventDefault();
                evt.stopPropagation();
            }
            $ionicListDelegate.closeOptionButtons();
            $rootScope.go('root.charts.summary.edit', { uid: node.id }, 'forward');            
            $timeout(function(){
                $rootScope.$broadcast('chart-serie-edit', node);
            });
        }


        // Send node selected event
        $scope.toggleSeries = function (node, ctrl, evt) {
            if(node.nodes.length > 0 && ctrl) {
                ctrl.collapsed ? ctrl.expand() : ctrl.collapse();
                node.collapsed = !node.collapsed;
                //$(evt.currentTarget).parent().hasClass('collapsed') ? $(evt.currentTarget).parent().removeClass('collapsed') : $(evt.currentTarget).parent().addClass('collapsed');
                return;
            }


            if($rootScope.$stateParams.uid)
            {
                return;
            }

            if(evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            var index = $scope.checkedNodes.indexOf(node);
            if (index >= 0) {
                node.color = null;
                $scope.checkedNodes.splice(index, 1);
            } else {
                console.log('node ' , node);
                if (node.influxKey) {

                    // Limit selectable nodes
                    if ($scope.checkedNodes.length >= $scope.maxSeries)
                        return;

                    for (var ci = 0; ci < serieColors.length; ci++) {
                        var items = $scope.checkedNodes.filter(function(item) {
                            return item.color == serieColors[ci];
                        });
                        if (items.length > 0) continue;


                        node.color = serieColors[ci];
                        $scope.checkedNodes.push(node);
                        break;
                    }
                }
            }
            
            $rootScope.setActiveView('content');
            $rootScope.$broadcast('chart-serie-checked', node);
        }


        $scope.buildTree = function(result){
            var map = {}, node, roots = [], nodes = [];

            $scope.originalNodes = result;
            nodes = angular.copy($scope.originalNodes);
            var maxId=0; 
            //remove duplicates
            var nodes = _.map(_.groupBy(nodes, function(doc){
                                        if(doc.id>=maxId)   
                                            maxId=doc.id+1;
                                        return doc.id;
                                }),
                                function(grouped){
                               	    node=grouped[0];
                                    node.euid=node.id;
                                    return node;
                            });

    	    // Add "fake" nodes in a building node has disaggregated series
    	    function addFakeNode(node,maxId,disag){
        		return {
        			id:maxId,
        			parent:node.id,
        			type:3,
        			euid:node.euid,
        			name:disag,
        			disagg:disag,
        			influxKey:node.influxKey||"temp",
        			campus:node.campus
        		}		
    	    }

    	    var hijackheadbar=$('a[href="/hijack/release-hijack/"]');
    	    if(hijackheadbar.length>0){   
    	    	var i=0;
    	    	while (i<nodes.length){
    	    	    node=nodes[i];
    	    	    i++;
    	    	    if(node.type!=1||!node.invisible)continue;
                    var total_node=addFakeNode(node,maxId,'total')
                    maxId++;
                    nodes.push(total_node);
                    nodes.push(addFakeNode(total_node,maxId,'lighting'));
    	    	    maxId++;

    	    	    nodes.push(addFakeNode(total_node,maxId,'plug'));
    	    	    maxId++;

    	    	    nodes.push(addFakeNode(total_node,maxId,'cooling'));
    	    	    maxId++;

    	    	    nodes.push(addFakeNode(total_node,maxId,'misc'));
    	    	    maxId++;

    	    	    nodes.push(addFakeNode(total_node,maxId,'motor'));
    	    	    maxId++;

    	    	    nodes.push(addFakeNode(total_node,maxId,'heating'));
    	    	    maxId++;
    	    	}
    	    }
            
            //map ids for parent reference
            for (var i = 0; i < nodes.length; i += 1) {
                node = nodes[i];
                node.nodes = [];
                map[node.id] = i;
            }

            //build tree from flat array
            for (var i = 0; i < nodes.length; i += 1) {
                node = nodes[i];
                if (node.parent && node.id != $rootScope.$stateParams.uid) {
                    if(nodes[map[node.parent]]){
                        node.level = $scope.getLevel(node.id);
                        node.collapsed = node.level > 1; 
                        nodes[map[node.parent]].nodes.push(node);
                    }
                } else {
                    node.level = 0;
                    roots.push(node);
                }
            }

            //bind to ui-tree
            $scope.nodes = roots;

        }


        $scope.getParentTitle = function() {
            if($scope.parentID == 0) return;

            // find current parent item
            var item = _.find($scope.originalNodes, function(item) {
                return item.id == $scope.parentID; 
            });
            
            // set parent item level higher
            return item.name;
        }
        

        $scope.onListItemClick = function(item){
            $scope.parentID = item.id;

            var children = _.filter($scope.originalNodes, function(item) {
                if($scope.parentID == 0 && !item.parent) return true;
                return item.parent == $scope.parentID; 
            });

        }


        $scope.getListItems = function(parentID){

            var children = _.filter($scope.originalNodes, function(item) {
                if(parentID == 0 && !item.parent) return true;
                return item.parent == $scope.parentID; 
            });
            return children;

        }


        var getAllChildren = function(id, children){
            if(!children) children = [];

            _.each($scope.originalNodes, function(node){
                if(node.parent == id){
                  children.push(node);  
                  children = getAllChildren(node.id, children)
                }
            });

            return children;
        }

        // Load tree for the first time
        DataSource.Units().then(function(units){

            $scope.originalNodes = angular.copy(units);

            //new unit must be precreated
            if($rootScope.$stateParams.uid == 0){
                var newUnit = _.find(units, function(unit){
                    return unit.id == 0;
                });
                if(!newUnit){
                    $rootScope.go('root.charts.summary');                
                    return;
                }                
            }

            if($rootScope.$stateParams.uid >= 0){

                // get all inheritors
                units = getAllChildren($rootScope.$stateParams.uid, []);

                // add current node as parent for tree to work
                $scope.currentUnit = _.find($scope.originalNodes, function(unit){
                     return unit.id == $rootScope.$stateParams.uid;
                });
                units.splice(0, 0, $scope.currentUnit);

            }
            if(units.length > 1)
                $scope.buildTree(units);
        });


        var destroyMe = $rootScope.$on('create-meter', function (event, node) {

            // TODO: Save new meter into database, (event recieved from chartsCtrl)

            var maxID = _.max(_.pluck($scope.originalNodes, 'id'));
            EnergyUnitFactory.create(node).then(function(result){
                $scope.originalNodes.push(result);
                $scope.buildTree($scope.originalNodes);
                $scope.edit(result);
            },function(err){
                console.log(err);
            })

        });


        // Reset all selected indicators
        $scope.reset = function () {
            for (var i = $scope.checkedNodes.length - 1; i >= 0; i--) {
                $scope.checkedNodes[i].color = null;
                $rootScope.$broadcast('chart-serie-checked', $scope.checkedNodes[i]);
                $scope.checkedNodes.splice(i, 1);
            }
            nextColorIndex = 0;
        };

        var onReset = $rootScope.$on('reset-meters', function(event, meter){

            $scope.reset();

        });

        var onRemoveMeter = $rootScope.$on('remove-meter', function(event, meter){
    
            //	var items = $scope.checkedNodes.filter(function(item) { 
            //		return item.id == meter.id;
            //	 });
    	
            for (var i = $scope.checkedNodes.length - 1; i >= 0; i--) {
        		if(meter.id==$scope.checkedNodes[i].id){
        				
                        $scope.checkedNodes[i].color = null;
                        $rootScope.$broadcast('chart-serie-checked', $scope.checkedNodes[i]);
                        $scope.checkedNodes.splice(i, 1);
        		}
            }

        });



        /********************************************************************
         *
         *
         *  
         *
         *
        *********************************************************************/

        var onNodeSelected = function(node){

            var oldCopy = _.find($scope.checkedNodes, function(checked) {
                return checked.id == node.id; 
            });
            var index = $scope.checkedNodes.indexOf(oldCopy);
            if (oldCopy) {
                node.color = null;
                $scope.checkedNodes.splice(index, 1);
            } else {
                if (node.influxKey) {

                    // Limit selectable nodes
                    if ($scope.checkedNodes.length >= $scope.maxSeries)
                        return;

                    // Apply unique color
                    for (var ci = 0; ci < serieColors.length; ci++) {
                        var items = $scope.checkedNodes.filter(function(item) {
                            return item.color == serieColors[ci];
                        });
                        if (items.length > 0) continue;


                        node.color = serieColors[ci];
                        $scope.checkedNodes.push(node);
                        break;
                    }
                }
            }

            $rootScope.$broadcast('chart-serie-checked', node);

        }



        $scope.loadEnergyUnits = function(parentID){
            
            EnergyUnitFactory.get().then(function(result) {

                // var itemsToShow = _.filter(result.objects, function(item) {
                    
                //     // return root items when nothing selected 
                //     if(parentID == 0 && !item.parent) return true;
                    

                //     // Check whether or not to enable drilling
                //     var children = _.filter(result.objects, function(child) {
                //         return child.parent == item.id; 
                //     });

                //     // disable drilling
                //     if(children.length == 0)
                //         item.hasNoChildren = true;

                //     // apply color (we could introduce another cached collection to avoid reappling color)
                //     var oldCopy = _.find($scope.checkedNodes, function(node) {
                //         return node.id == item.id; 
                //     });
                //     if(oldCopy){
                //         item.color = oldCopy.color;
                //     }

                //     // required in reports.summary.js  
                //     item.euid = item.id;

                //     // is child of given item
                //     return item.parent == parentID;

                // });
                
                // save parentID for later use by navbar
                $scope.parentID = parentID;
            });

        }

        //Navbar event
        $scope.onBack = function(){
            $rootScope.setActiveView('subnav'); 
            if(!$ionicHistory.backView())
                $rootScope.go('root.charts.summary', {}, 'back')
            else
                $ionicHistory.goBack(-1);
        };


        // $scope.onListBackClick = function(){

        //     if($scope.parentID == 0) return;

        //     EnergyUnitFactory.get().then(function(result) {
    
        //         // find parent 
        //         var item = _.find(result.objects, function(item) {
        //             return item.id == $scope.parentID; 
        //         });

        //         // load parent items
        //         $scope.loadEnergyUnits(item.parent ? item.parent : 0);
        //     });
            
        // }


        // first time load
        $scope.loadEnergyUnits(0);



        /********************************************************************
         *
         *
         *  Destroy
         *
         *
        *********************************************************************/


        //Unsubscribe from broadcast on controller destroy event
        $scope.$on('$destroy', function () {
            destroyMe();
            onRemoveMeter();
            onReset();
        });

    }])

},{}],9:[function(require,module,exports){
angular.module('app.controllers.charts.summary.edit', [])

    .controller('chartsEditCtrl', ['$scope', '$rootScope', '$filter', 'seriesService', 'EnergyUnitFactory', 'uiGridConstants', '$q', '$window', '$http', '$timeout', '$interval', 'csv2json', 'LanguageFactory', 'DataSource', '$ionicPopover', '$ionicHistory',
    						function ($scope, $rootScope, $filter, seriesService, EnergyUnitFactory, uiGridConstants, $q, $window, $http, $timeout, $interval, csv2json, LanguageFactory, DataSource, $ionicPopover, $ionicHistory) {


		$ionicPopover.fromTemplateUrl('template/popover-list-menu.html', { scope: $scope }).then(function(popover) {
			$scope.popover = popover;
  		});

        $scope.categtoryOptions=[];
        $scope.editableFields = {
                building:["name","yearbuild", "address", "buildingarea", "employeenumber","refrigerationunits","cookingfacility","numberofrooms", "description", "energysystemintro"],
                meter:["name","manufacturer","modelname","samplerate","description"],
                campus:["name","description"],
        }

        var setupEditableFields = function(unitType){
	        switch(unitType){
	            case 1: 
	            	$scope.currentFields = $scope.editableFields['building'];
	            	$scope.extra = "buildingparam";
	            	break;
	            case 2: 
	            	$scope.currentFields = $scope.editableFields['campus'];
	            	$scope.extra = "campusparam";
	            	break;
	            case 3: 
	            	$scope.currentFields = $scope.editableFields['meter'];
	            	$scope.extra = "meterparam";
	            	break;
	        }

        }

        DataSource.getUnitByID($rootScope.$stateParams.uid).then(function(unit){
        	if(!unit){
        		console.log('WARNING: No Energy Unit match id:', $rootScope.$stateParams.uid);
        		return;
        	}

	        //$scope.formData.name = node.name;
	        $scope.extra="";
	        $scope.currentFields=[];

	        //Setup editable fields
	        setupEditableFields(unit.type);

	        // translate labels

	        // $scope.translateLabel = function (txt) {
	        //     var hash = {
	        //         "description": "介绍",
	        //         "type": "类型",
	        //         "name": "名称",
	        //         "value": "信息",
	        //         "address": "地址",
	        //         "buildingarea": "建筑范围",
	        //         "yearbuild": "建筑年份",
	        //         "manufacturer": "制造商",
	        //         "modelname": "型号",
	        //         "samplerate": "取点频率",
	        //         "gpslocation": "GPS位置",
	        //         "category": "类别"
	        //     };
	        //     return hash[txt] || txt;
	        // }
	        $scope.translateLabel=LanguageFactory.getTranslatedLabel;

	        // Bind form with data        
	        $scope.currentFields=$scope.currentFields||[];
            $scope.currentUnit = unit;
            $scope.formData=angular.copy(unit);
			
			// Handling new unit
			if(unit.id == 0)
            	$scope.editForm.$setDirty();
        })




        /* CONFIGURATION EDITING RELATED */

   //      var meterPromptConfig = function(){
			// /* CREATE NEW METER */
	  //       $scope.newMeterConfig = {
	  //           isVisible: false,
	  //           title: '节点名称',
	  //           view: "template/dialog.prompt.html",
	  //           containerID: 'meter-container',
	  //           model: [{
	  //               type: 'input',
	  //               name: '名称', //name
	  //               value: ''
	  //           },{
	  //               type: 'input',
	  //               name: '类别', //category
	  //               value: ''
	  //           }],
	  //           onOk: function(){
	  //               var node = {
	  //                   parent: $scope.formData.id,
	  //                   //campus: $scope.formData.campus,
	  //                   //influxKey: Math.random().toString(36).substring(7),
	  //                   name: this.model[0].value,
	  //                   type: parseInt(this.model[1].value)||1
	  //               }
	  //               $rootScope.$broadcast('create-meter', node);
	  //               this.hide();
	  //           },
	  //           onCancel: function(){
	  //               this.hide();
	  //           }
	  //       }
   //      }



        $scope.getCategory=function(id){
            var item=_.find($scope.categtoryOptions,function(d){
                    return id==d.id;
                });
            if(item) return item.name||"";
            return "";
        }
        
        $scope.getType=function(id){
            var item=_.find($scope.typeOptions,function(d){
                    return id==d.id;
                });
            if(item) return item.name||"";
            return "";
        }
        $scope.setType=function(unit, typeid){
        	unit.type = typeid;
        	setupEditableFields(unit.type);
		}

        $scope.setCategory=function(unit,categoryID){
            
            $scope.formData.category=categoryID;

        }




        /* PROPERTIES */

        $scope.saveProperties = function() {
        	if($rootScope.$stateParams.uid == 0){
        		delete $scope.formData['id'];
            	EnergyUnitFactory.create($scope.formData).then(function(data){
        			DataSource.Units(true).then(function(result){
        				$scope.editForm.$setPristine();
        				$rootScope.goBack(-1);
        				$rootScope.setActiveView('subnav');
        			})	
            	});
			}else{
	            var toupdate={}
	            $scope.currentFields.forEach(function(d){
					toupdate[d]=$scope.formData[$scope.extra] ? $scope.formData[$scope.extra][d]||$scope.formData[d] : $scope.formData[d];
	            });
	            unitParam={name:toupdate['name']};
	            delete toupdate['name'];
	            $scope.redraw();
	            //TODO: save data
	            EnergyUnitFactory.update($scope.formData,unitParam,toupdate).then(function(data){
	                // This is to feedback success.
	            });
	            $scope.formData = null;

	            $rootScope.go('root.charts.summary', {}, 'back');
	        }
        }

        $scope.resetProperties = function(){
			
			// Reseting properties for new meters deletes it
			if($scope.currentUnit.id == 0){
        		DataSource.Units(true).then(function(units){
            		$scope.editForm.$setPristine();
	            	$ionicHistory.goBack(-1);
	            	//$rootScope.go('root.charts.summary', {}, 'back');
        		});
        	}

        	$scope.formData = angular.copy($scope.currentUnit);
        	$scope.editForm.$setPristine();
        }









        
        EnergyUnitFactory.getCategories().then(function(result){
            $scope.categtoryOptions=result.objects;
        });

		EnergyUnitFactory.getType().then(function(result){
            $scope.typeOptions=result.objects;
        });




        //Unsubscribe from broadcast on controller destroy event
        $scope.$on('$destroy', function () {

        });

}]);

},{}],10:[function(require,module,exports){
angular.module('app.controllers.charts.summary.import', [])

    .controller('chartsImportCtrl', ['$scope', '$rootScope', 'uiGridConstants', '$http', 'csv2json', 'DataSource', '$timeout', '$ionicPopover', '$compile', function ($scope, $rootScope, uiGridConstants, $http, csv2json, DataSource, $timeout, $ionicPopover, $compile) {

        /* IMPORT DATA */

        DataSource.getUnitByID($rootScope.$stateParams.uid).then(function(unit){
        	$scope.formData = angular.copy(unit);
        	initImportPrompt();
		});

        // Import button click event
        $scope.onFileSelected = function(content){

            // HACK: remove space after delimiter,
            //       otherwise regex fails to find match in csv2json

            content = content.replace(/, /g, ',');

            // Convert CSV to JSON & bind to grid

            var json = csv2json.toJson(content);

            json = _(json).sortBy(function(item) {
                return item.date;
            });

            var id = 0;
            json = _.map(json, function(item){
                var date = moment(item.date).valueOf();
                return { date: date, value: item.value, id: id++ };
            });

            $scope.importGridOptions.data = json;

            // Digest

            $rootScope.resize();
        }

        // Merge/Replace prompt configuration


		$scope.popData = [
            { name: 'merge',  title: 'Merge with existing' }, 
            { name: 'replace', title: 'Overwrite existing' }
        ];
        
        $scope.popSelected = function(item){

        	$timeout(function(){
        		$scope.gridOptions.api.selectAll();
	        	var rows = $scope.gridOptions.api.getSelectedRows();
	        	$scope.importConfig.data = rows;

	            switch(item.name)
	            {
		            case 'merge':
		                $scope.saveImport({ replace: 'False'})
		                break;
		            case 'replace':
		            	$scope.saveImport({ replace: 'True'})
		                break;
	            }
        	})

	        $scope.popover.hide();
        }

        $ionicPopover.fromTemplateUrl('template/popover-list-menu.html', { scope: $scope }).then(function(popover) {
            $scope.popover = popover;
        });

        $scope.importConfig = {
            isVisible: false,
            title: 'Import type',
            containerID: 'meter-container',
            hideFooter: true,
            view: "template/dialog.prompt.import.html",
            onMerge: function(){
                $scope.saveImport({ replace: 'False'})
                $scope.importConfig.hide();
            },
            onReplace: function(){
                $scope.saveImport({ replace: 'True'})
                $scope.importConfig.hide();
            }
        }

        // Import save button click event, available after $scope.onFileSelected
        $scope.onSaveImport = function(e){
            //$scope.popover.show(e);
            //$scope.importConfig.show();
        }

        // Saving import data, triggered by $scope.importConfig.onMerge & $scope.importConfig.onReplace
        $scope.saveImport = function(options){

            var points = angular.copy($scope.importGridOptions.data);

            // Check for valid date
            if(moment(points[0].date).isValid()){

                points = _.map(points, function(item){
                    var date = moment(item.date).valueOf()  / 1000;
                    return { date: date, value: item.value };
                });

            } else if(moment(points[0].date / 1000).isValid()){

                points = _.map(points, function(item){
                    var date = moment(item.date / 1000).valueOf();
                    return { date: date, value: item.value };
                });

            } else {

                alert('Cannot parse Date field..'); return;

            }

            // Get import start and end dates
            var minDate = _.min(points, function(o){ return Math.round(moment(o.date).valueOf()); });
            var maxDate = _.max(points, function(o){ return Math.round(moment(o.date).valueOf()); });

            // Build date/value array
            points = _.map(points, function(item){
                return '[' + (moment(item.date).valueOf()) + ',' + item.value + ']';
            });


            // Submit data to the server
            //var data = { points: '[' + points + ']', time_format: 's', erase_flag: 'False'};
            var data = { points: '[' + points + ']', time_format: 's', erase_flag: options.replace, start_utc: '' + minDate.date + '', end_utc: '' + maxDate.date + '' };
            $http({
                url:'/api/putseries/' + $rootScope.$stateParams.uid + '/',
                data: data,
                method: 'POST'
            })
            .then(
                function(success) {
                    $scope.importGridOptions.data = [];
	        		$scope.gridOptions.api.setRowData($scope.importGridOptions.data);
                },
                function(failure) {
                    alert('An error occured while processing your import request.');
                }
            );
        }

        $scope.cancelImport = function(){
            $scope.importGridOptions.data = [];
	        $scope.gridOptions.api.setRowData($scope.importGridOptions.data);
        }

        $scope.promptConfig = function(){
        	return initImportPrompt;
        }

		/* INSERT DATA */
		var initImportPrompt = function(){
	        $scope.newImportEntryConfig = {
	            isVisible: true,
	            title: 'New record',
	            view: "template/ui.grid.chart.import.edit.dialog.html",
	            containerID: 'meter-container',
	            model: [
	                {
	                    type: 'input',
	                    name: 'date',
	                    value: moment().format('YYYY/MM/DD 00:00'),
	                    isDatePickerOpen: false,
	                    applyDateTime: function() {
	                        this.isDatePickerOpen = false;
	                    },
	                    getDate: function(){
	                        return moment(this.value).format('YYYY/MM/DD HH:mm');
	                    }
	                },
	                {
	                    type: 'input',
	                    name: 'value',
	                    value: 0
	                },
	                {
	                    type: 'hidden',
	                    value: 0
	                }
	            ],
	            onOk: function() {
	                if(moment(this.model[0].value).isValid() && this.model[1].value >= 0){

	                    var entry = { date: moment(this.model[0].value).format('YYYY/MM/DD HH:mm'), value: this.model[1].value };

	                    if(this.model[2].value > 0){

	                        // This is an existing entity

	                        var id = this.model[2].value;

	                        // Find edited entry
	                        var oldEntry = _.find($scope.importGridOptions.data, function(item){
	                            return item.id == id;
	                        });

	                        // Find entry index
	                        var index = $scope.importGridOptions.data.indexOf(oldEntry);

	                        // Apply changes
	                        $scope.importGridOptions.data[index].date = entry.date;
	                        $scope.importGridOptions.data[index].value = entry.value;

	                        $scope.gridOptions.api.setRowData($scope.importGridOptions.data);

	                    }else{

	                        // This is new entity

	                        // Find last ID in array
	                        var maxEntity = _.max($scope.importGridOptions.data, function(item){
	                            return item.id;
	                        });


	                        // Apply ID to entry for later editing
	                        entry.id = maxEntity.id > 0 ? maxEntity.id + 1 : 1;

	                        // Insert new entity into data array
	                        $scope.importGridOptions.data.push(entry);

	                        $scope.gridOptions.api.setRowData($scope.importGridOptions.data);

	                    }

	                    this.hide();
	                }
	                else{
	                    alert('Invalid entry values.');
	                }
	            },
	            onCancel: function(){
	                this.hide();
	            }
	        }

		}
		$scope.lastID = 1;

        $scope.addImportEntry = function(){

        	var newData = angular.copy($scope.importGridOptions.data);
        	newData.splice(0, 0,  { id: ++$scope.lastID, date: moment().format('YYYY/MM/DD 00:00'), value: 0 });
        	$scope.importGridOptions.data = newData; 

			$scope.gridOptions.api.setRowData($scope.importGridOptions.data);


            // $scope.newImportEntryConfig.title = '添加新数据';
            // $scope.newImportEntryConfig.model[0].value = moment().format('YYYY/MM/DD 00:00');
            // $scope.newImportEntryConfig.model[1].value = 0;
            // $scope.newImportEntryConfig.model[2].value = 0;
            // // $scope.newImportEntryConfig.model[2].value = maxID > 0 ? maxID : 1;
            // console.log('$scope.newImportEntryConfig ' , $scope.newImportEntryConfig);

            // $scope.newImportEntryConfig.show();

        }

        $scope.editImportRow = function(grid, row){
            $scope.newImportEntryConfig.title = '编辑现有数据';
            $scope.newImportEntryConfig.model[0].value = row.entity.date;
            $scope.newImportEntryConfig.model[1].value = row.entity.value;
            $scope.newImportEntryConfig.model[2].value = row.entity.id;

            $scope.newImportEntryConfig.show();
        }



        $scope.importGridOptions={

		 	// selectWithCheckboxOnly: true,
			// enableRowSelection: false,
   			// enableSelectAll: true,
   			// enableGroupHeaderSelection: false,
			// multiSelect: true,
			// enableFullRowSelection: false,
			enableRowSelection: false,
            paginationPageSize: 50,
			enablePaging: false,
		    enableSelectAll: true,
		    multiSelect: true,
		    modifierKeysToMultiSelect: true, //<-- doesnt work and drives me nuts!!!
			enableColumnMenus: false,
            enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
            enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
        }


        $scope.importGridOptions.columnDefs = [
            { field: 'date', displayName: 'Date', width: "*", resizable: true,  type: 'date', cellFilter: 'date:\'yyyy-MM-dd HH:mm\'' },
            { field: 'value', displayName: 'Value', width: "*", resizable: true,  }
        ];

 		$scope.importGridOptions.data = [];

        $scope.importGridOptions.onRegisterApi = function (gridApi) {

	        $scope.gridApi = gridApi;
			//$scope.gridApi.core.notifyDataChange( uiGridConstants.dataChange.OPTIONS);

	    }

	     $scope.getTableHeight = function() {
			var rowHeight = 30; // row height
			var headerHeight = 30; //  header height
			return {
				height: ($scope.importGridOptions.data.length * rowHeight + headerHeight) + "px"
			};
	    };


	    // expose data as a CollectionView to get events
	    //$scope.data = new wijmo.collections.CollectionView(data);






	var columnDefs = [
		{
            headerName: " ", checkboxSelection: true, suppressSizeToFit: true, width: 30
        },
	    {
            headerName: "Date", field: "date", width: 100, cellEditor: DatepickerEditor, editable: true
        },
        {
            headerName: "Value", field: "value", width: 100, editable: true
        }
	    
	];

		$scope.deleteSelected = function(){

				$scope.importGridOptions.data = _.filter($scope.importGridOptions.data, function(item){
					return $scope.selectedRows.indexOf(item) == -1;
				});
		        $scope.gridOptions.api.setRowData($scope.importGridOptions.data);
		}

		function onSelectionChanged() {
			if(!$scope.gridOptions.api) return;
			$scope.$apply(function(){
			    $scope.selectedRows = $scope.gridOptions.api.getSelectedRows();
			})
		    
		}

		$scope.gridOptions = {
			enableColResize: true,
		    columnDefs: columnDefs,
		    rowData: [],
		    rowSelection: 'multiple',
			suppressRowClickSelection: true,
			suppressHorizontalScroll: true,
			onSelectionChanged: onSelectionChanged
		};

		$timeout(function(){
			$scope.gridOptions.api.sizeColumnsToFit();
		});







        function DatepickerEditor() {
        }

        DatepickerEditor.prototype.onKeyDown = function (event) {
            var key = event.which || event.keyCode;
            if (key == 37 ||  // left
                key == 39) {  // right
                event.stopPropagation();
            }
        };

        DatepickerEditor.prototype.init = function (params) {

            this.container = document.createElement('div');
            this.container.style = "border: 1px solid #ccc;background: #e6e6e6;padding: 1px;width: 100%;text-align:center;display:inline-block;outline:none";
            this.container.tabIndex = "0"; // to allow the div to capture keypresses


            $scope.dtProxy = {
                value: params.value,
                select: function(date){
                    this.currentDate = date;
                    params.stopEditing();
                }
            };

            var dtHtml ='<input type="text" ng-model="dtProxy.value" style="width: 100%; height: auto; padding: 4px;" /><uib-datepicker ng-model="dtProxy.value" ng-change="dtProxy.select(dtProxy.value)" show-weeks="true" starting-day="1" class="datepicker"></uib-datepicker>';
            var dtTemplate = $compile(dtHtml)($scope);
            angular.element(this.container).append(dtTemplate);

            this.currentDate = params.value;
        };

        // gets called once when grid ready to insert the element
        DatepickerEditor.prototype.getGui = function () {
            return this.container;
        };

        DatepickerEditor.prototype.afterGuiAttached = function () {
            this.container.focus();
        };

        DatepickerEditor.prototype.getValue = function () {
            //return moment(this.currentDate).format('YYYY/MM/DD HH:mm');
            return moment($scope.dtProxy.value).format('YYYY/MM/DD HH:mm'); 
        };

        // any cleanup we need to be done here
        DatepickerEditor.prototype.destroy = function () {
        };

        DatepickerEditor.prototype.isPopup = function () {
            return true;
        };




    }])
// .directive('uiGridCell', ['$timeout', 'uiGridSelectionService', function ($timeout, uiGridSelectionService) {
//   return {
//     restrict: 'A',
//     require: '^uiGrid',
//     priority: -200,
//     scope: false,
//     link: function ($scope, $elm, $attr, uiGridCtrl) {
//       if ($scope.col.isRowHeader) {
//         return;
//       }
      
//       var touchStartTime = 0;
//       var touchTimeout = 300;
      
//       registerRowSelectionEvents();
      
//       function selectCells(evt) {
//         // if we get a click, then stop listening for touchend
//         $elm.off('touchend', touchEnd);
        
//         if (evt.shiftKey) {
//           uiGridSelectionService.shiftSelect($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect);
//         }
//         else if (evt.ctrlKey || evt.metaKey) {
//           uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect, $scope.grid.options.noUnselect);
//         }
//         else {
//           uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, ($scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect), $scope.grid.options.noUnselect);
//         }
//         $scope.$apply();
        
//         // don't re-enable the touchend handler for a little while - some devices generate both, and it will
//         // take a little while to move your hand from the mouse to the screen if you have both modes of input
//         $timeout(function() {
//           $elm.on('touchend', touchEnd);
//         }, touchTimeout);
//       };

//       function touchStart(evt) {
//         touchStartTime = (new Date()).getTime();

//         // if we get a touch event, then stop listening for click
//         $elm.off('click', selectCells);
//       };

//       function touchEnd(evt) {
//         var touchEndTime = (new Date()).getTime();
//         var touchTime = touchEndTime - touchStartTime;

//         if (touchTime < touchTimeout ) {
//           // short touch
//           selectCells(evt);
//         }
        
//         // don't re-enable the click handler for a little while - some devices generate both, and it will
//         // take a little while to move your hand from the screen to the mouse if you have both modes of input
//         $timeout(function() {
//           $elm.on('click', selectCells);
//         }, touchTimeout);
//       };

//       function registerRowSelectionEvents() {
//         $elm.addClass('ui-grid-disable-selection');
//         $elm.on('touchstart', touchStart);
//         $elm.on('touchend', touchEnd);
//         $elm.on('click', selectCells);
//       }
//     }
//   };
// }])

},{}],11:[function(require,module,exports){
angular.module('app.controllers.charts.summary', [])

    .controller('chartsCtrl', ['$scope', '$rootScope', '$filter', 'seriesService', 'EnergyUnitFactory', 'uiGridConstants', '$q', '$window', '$http', '$timeout', '$interval', 'csv2json', 'LanguageFactory', function ($scope, $rootScope, $filter, seriesService, EnergyUnitFactory, uiGridConstants, $q, $window, $http, $timeout, $interval, csv2json,LanguageFactory) {
        $scope.formData = null;

        $scope.startDate = moment().subtract(1, 'M').valueOf();
        $scope.endDate = moment().valueOf();

        $scope.minDate = moment().subtract(2, 'y').valueOf();
        $scope.maxDate = moment().valueOf();

        // auto refresh feature
        var stopRefresh, stopCountdown;
        $scope.countdown = 15;
        $scope.toggleRefresh = false;
        $scope.$watch('toggleRefresh', function(newVal){
            if ($scope.toggleRefresh)
            {
                $scope.countdown = 15;
                stopCountdown = $interval(function() {
                    $scope.countdown--;
                }, 1000);

                stopRefresh = $interval(function() {
                    $scope.countdown = 15;
                    if(!$rootScope.isBusy){
                        var chart = $scope.chartOptions1.getHighcharts();
                        var extremes = chart.xAxis[0].getExtremes();
                        chart.xAxis[0].setExtremes(moment(extremes.min).add(15, 'seconds'), moment(extremes.max).add(15, 'seconds'));
                    }
                }, 15000);
            }
            else
            {
                if(angular.isDefined(stopCountdown)){
                    $interval.cancel(stopCountdown);
                    stopCountdown = undefined;
                }
                if(angular.isDefined(stopRefresh)){
                    $interval.cancel(stopRefresh);
                    stopRefresh = undefined;
                }
            }
        });

        $scope.meters = [];

        /* CHART RELATED */

        // Initial chart extremes
        // $timeout(function(){
        //     var chart = $scope.chartOptions1.getHighcharts();
        //     chart.xAxis[0].setExtremes($scope.startDate, $scope.endDate);
        //     $scope.redraw();
        // });

        // Chart redraw
        $scope.redraw = function () {
            var chart = $scope.chartOptions1.getHighcharts();
            if(chart){
                chart.redraw();
                chart.reflow();
                $timeout(function () {
                    angular.element($window).triggerHandler('resize');
                });
            }
        };
        $timeout($scope.redraw);

        var minLimit, maxLimit;

        var unbindSerieChecked = $rootScope.$on('chart-serie-checked', function (event, node) {

            // Find meter on chart by id
            var items = $scope.chartOptions1.series.filter(function(item) {
                return item.cachedID == node.id;
            });

            // Plot or remove meter from the chart, influxKey param must be present
            if (items.length == 0 && node.influxKey) {

                //Load data for navigator and init main series
        		var seriesOptions={interval:"auto"};
        		if(node.disagg) seriesOptions.disagg=node.disagg;
        		        
            	seriesService
                    .load(node.euid, $scope.minDate, $scope.maxDate, seriesOptions)
                    .then(function (data) {
                        data=data[0]||{};
                        var points=data.points||[];
                        points = points.reverse();

                        var chartSeries = { id: node.id, name: node.name, color: node.color, data: [], cachedID: node.id, influxKey: node.influxKey, yAxis: 0, euid: node.euid, disagg: node.disagg, nodetype: node.type };
                        var navSeries = { name: node.name, xAxis: 1, yAxis: 3, data: points, color: node.color, cachedID: node.id, euid: node.euid, disagg: node.disagg, enableMouseTracking: false };

                        if(node.type == 4) // occupancy rate
                        {
                            $scope.chartOptions1.options.yAxis[1].visible = true;                            
                            chartSeries.yAxis = 1
                        }

                        if(node.type == 7) // temp
                        {
                            $scope.chartOptions1.options.yAxis[2].visible = true;                            
                            chartSeries.yAxis = 2
                        }

                        // Init main data serie with no data
                        $scope.chartOptions1.series.push(chartSeries);

                        // Add retrived data to navigator
                        $scope.chartOptions1.series.push(navSeries);

                        var _minLimit = _.min(points, function(item) { return item[0]; } )[0];
                        var _maxLimit = _.max(points, function(item) { return item[0]; } )[0];

                        //minLimit = minLimit < _minLimit ? minLimit : _minLimit;
                        //maxLimit = maxLimit > _maxLimit ? maxLimit : _maxLimit;
                        


                        // HACK: fake serie to fix chart panning 
                        $scope.chartOptions1.series.push({ 
                            data:[{ x: _maxLimit, y: 0}, { x: _minLimit, y: 0}], 
                            color: 'rgba(0,0,0,1)',
                            enableMouseTracking:false,
                            fake: true
                        });

                        // Add retrived data to navigator
                        $scope.chartOptions1.series.push(navSeries);
                        //console.log('$scope.chartOptions1.series ' , $scope.chartOptions1.series);

                        // Add table column
                        var fieldName = 'field' + node.id;
                        $scope.addColumn(fieldName, node.name, node.color, {
                            dailyavg: '-',
                            dailymax: '-',
                            dailymin: '-',
                            hourlymax: '-',
                            hourlymin: '-',
                            peakPercent: '-'
                        });

                        // Trigger AfterSetExtremes event
                        $timeout(function(){
                            var chart = $scope.chartOptions1.getHighcharts();
                            var ax=chart.xAxis[0].getExtremes();
                            var startDate=ax.min;
                            var endDate=ax.max;

                            // [ minLimit [min max] maxLimit ]
                            //if(ax.min > _maxLimit || ax.max < _minLimit){
                                endDate = _maxLimit;// - (ax.max - ax.min) / 2; // 
                                startDate = endDate - (ax.max - ax.min);
                            //}

                            chart.xAxis[0].setExtremes(startDate+1, endDate+1);
                            //afterSetExtremes(null,{chart:chart,startDate:startDate,endDate:endDate});
                            //chart.xAxis[0].setExtremes(moment(startTick).subtract(1, 'M'), moment(startTick));
                        });
                    });

            } else if (items.length > 0) {

                // remove chart and nav series
                for (var i = 0; i < items.length; i++) {
                    var index = $scope.chartOptions1.series.indexOf(items[i]);
                    if (index > -1){

                        
                        if($scope.chartOptions1.series[index].nodetype == 4) // occupancy rate
                        {
                            $scope.chartOptions1.options.yAxis[1].visible = false;
                        }

                        if($scope.chartOptions1.series[index].nodetype == 7) // temp
                        {
                            $scope.chartOptions1.options.yAxis[2].visible = true;                            
                        }

                        $scope.chartOptions1.series.splice(index, 1);

                    }
                }

                // remove table column
                $scope.removeColumn('field' + node.id);

                // hide meter details
                meterDetails = null;

            }
        });

        var onLayoutResize = $rootScope.$on('layout-resize', function () {
            $scope.redraw();
        });

        //Highstock chart options
        $scope.chartOptions1 = {
            options: {
                chart: { margin: [50, 0, 0, 0], panning: true, panKey: 'shift' },
                title:  null,
                legend: { enabled: false },
                navigator: {
                    enabled: true,
                    adaptToUpdatedData:false,
                    xAxis: {
                        min: $scope.minDate,
                        max: $scope.maxDate,
                        ordinal: false
                    },
                    series:{
                        name:'Navigator',
                        enableMouseTracking: false,
                        data: []
                    },
                },
                scrollbar: { enabled: false, liveRedraw: false },
                rangeSelector: {
                    enabled: false,
                    buttons: null,
                    // {
                    //     type: 'day',
                    //     count: 1,
                    //     text: '1d'
                    // },{
                    //     type: 'week',
                    //     count: 1,
                    //     text: '1w'
                    // }, {
                    //     type: 'week',
                    //     count: 6,
                    //     text: '6w'
                    // }, {
                    //     type: 'month',
                    //     count: 1,
                    //     text: '1M'
                    // },{
                    //     type: 'month',
                    //     count: 3,
                    //     text: '3M'
                    // },{
                    //     type: 'month',
                    //     count: 6,
                    //     text: '6M'
                    // },{
                    //     type: 'year',
                    //     count: 1,
                    //     text: '1year'
                    // },{
                    //     type: 'all',
                    //     text: 'All',
                    //     count: 0
                    // }],
                    //selected: 3, 
                    inputEnabled: false, 
                    //inputDateFormat: '%Y-%m-%d'
                },
                xAxis:{
                    ordinal: false,
                    type: 'datetime',
                    minorGridLineWidth: 0,
                    min: $scope.startDate,
                    max: $scope.endDate,
                    events : {
                        afterSetExtremes : afterSetExtremes
                    },
                    opposite: true,
                },
                yAxis: [
                    {
                        // Meter
                        title: null, //{ text: '能耗有效功率(kW)' },
                        minorGridLineWidth: 0, tickPixelInterval: 100, opposite: false, labels: { align: 'left', x: 5, y: -3 }
                    },
                    {
                        // Occupancy rate
                        visible: false,
                        title: { text: '入住率' }, endOnTick: true,
                        minorGridLineWidth: 0, gridLineWidth: 0, opposite: true, min: 0, max: 150, tickInterval: 25,  tickPosition: 'outside',
                        labels: { format: '{value}', align: 'right', x: -15, style: { color: '#2C5384' } },
                    },
                    {
                        // Temperature
                        visible: false,
                        title: { text: '平均温度' },
                        minorGridLineWidth: 0, gridLineWidth: 0, opposite: true, min: -20, max: 90, tickInterval: 5, tickPosition: 'outside',
                        labels: { format: '{value}°C', align: 'right', x: -75, style: { color: '#2C5384' } },
                    }
                ],
                plotOptions: {
                    areaspline: { fillOpacity: 0.0 },
                    series: {
                        lineWidth:2,
                        states:{
                            hover:{
                                enable:false,
                                lineWidth:2
                            }
                        },
                        fillOpacity: 0.1, 
                        marker: { enabled: false, symbol: 'triangle' }
                    },
                    line: { marker: { enabled: false, symbol: 'triangle' }, gapSize:2 }
                },
                tooltip: {
                    crosshairs: false
                },
                // tooltip: {
                //     shared: false,
                //     valueSuffix: '',
                //     pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b> ({point.change}%)<br/>',
                //     valueDecimals: 2
                // },
                credits: { enabled: false }
            },
            series: [],
            useHighStocks: true
        };

        function afterSetExtremes(e,options) {
            e=e||{};
            e.target=e.target||{}
            var charts=e.target.chart||options.chart;

            // load threshold 
            if($scope.t)
                $timeout.cancel($scope.t);

            $scope.t = $timeout(function () {
                loadData(e,options)
            },500);
            

            function loadData(ev,option) {
                if(!option && !ev.min && !ev.max) return;


                $scope.startDate = Math.round(ev.min)||option.startDate;
                $scope.endDate = Math.round(ev.max)||option.endDate;

                if (!$scope.startDate || !$scope.endDate) return;

                charts.showLoading('Loading...');


                var promises = _.map($scope.chartOptions1.series, function (serie) {
                    
                    if (!serie.influxKey) return;
                    
                    var loadOptions={interval:"auto"};
                    if(serie.disagg)
                        loadOptions.disagg=serie.disagg; 
                    

                    return seriesService.load(serie.euid, $scope.startDate, $scope.endDate,loadOptions).then(function (data) {
                            data=data[0]||{};
                            var points=data.points||[];
                            points = points.reverse();

                            serie.data = points;

                            seriesService.summaryStats(points).then(function (result) {
                                var fieldName = 'field' + serie.cachedID;
                                var info = $scope.gridOptions1.data;
                                info[0][fieldName] = result['dailyavg']
                                info[1][fieldName] = result['dailymax']
                                info[2][fieldName] = result['dailymin']
                                info[3][fieldName] = result['hourlymax']
                                info[4][fieldName] = result['hourlymin']
                                info[5][fieldName] = result['peakPercent']
                                info[6][fieldName] = result['loadingFactor']
                            });
                        });

                });

                $q.all(promises).then(
                    function(data){

                        //charts.xAxis[0].setExtremes(e.min, e.max);
                        charts.hideLoading();

                        loadedItems = [];

                        $timeout(function(){
                            $scope.redraw();
                        })

                    },
                    function(reason){
                        charts.hideLoading();
                        $timeout(function(){
                            //$scope.redraw();
                        })
                    }
                )
            }
        }


        /* FILTER BAR */

        $scope.showMeterDetails = function(meter){
            $scope.meterDetails = !$scope.meterDetails;// == meter ? null : meter;
            $timeout(function () {
                angular.element($window).triggerHandler('resize');
            });
        }

        $scope.removeMeter = function(evt, meter){
            $rootScope.$broadcast('remove-meter', meter);
        }

        $scope.resetMeters = function(){
            $rootScope.setActiveView('subnav');
            $rootScope.$broadcast('reset-meters');
        }

        // on hover/blur
        $scope.highlightSeries = function(meter, highlight){

            // var meterIndex = $scope.chartOptions1.series.indexOf(meter);
            // if(meterIndex > -1){
            //     $scope.chartOptions1.series[meterIndex].lineWidth = highlight ? 3 : 2;
            // }
            // changing lineheight is slow
            // _.each($scope.chartOptions1.series, function(series) {
            //     if(series == meter)
            //         series.shadow = series == meter && highlight ? true : false
            // //     if(!series.influxKey) return;

            // //     var lineWidth = 1;
            // //     if(highlight)
            // //         lineWidth = series == meter ? 3 : 1;
            // //     else
            // //         lineWidth = 2;

            // //     series.lineWidth = lineWidth;
            // //     //series.dashStyle = series == meter ? 'Solid' : 'Dash';
            // })
        }

        /* SUMMARY STATISTICS */

        $scope.removeColumn = function (fieldName) {
            // find field name
            var columns = $scope.gridOptions1.columnDefs.filter(function (col) {
                return col.field == fieldName;
            });

            //find field index and remove column
            var colIndex = $scope.gridOptions1.columnDefs.indexOf(columns[0]);
            $scope.gridOptions1.columnDefs.splice(colIndex, 1);
        }

        $scope.addColumn = function (fieldName, displayName, color, seriesResult) {
            var col = { field: fieldName, displayName: displayName, width: "160", resizable: true,  headerCellTemplate: headerCellTemplate, cellTemplate: cellTemplate, cellStyle: { color: color, 'font-weight': 'bold' }, headerCellStyle: { 'background-color': color }, enableColumnMenu: false, };
            $scope.gridOptions1.columnDefs.push(col);

            var info = $scope.gridOptions1.data;
            info[0][fieldName] = seriesResult['dailyavg']
            info[1][fieldName] = seriesResult['dailymax']
            info[2][fieldName] = seriesResult['dailymin']
            info[3][fieldName] = seriesResult['hourlymax']
            info[4][fieldName] = seriesResult['hourlymin']
            info[5][fieldName] = seriesResult['peakPercent']
            info[6][fieldName] = seriesResult['loadingFactor']
        }

        var headerCellTemplate = '';
            // '<div role="columnheader" ng-class="{ \'sortable\': sortable }" ui-grid-one-bind-aria-labelledby-grid="col.uid + \'-header-text \' + col.uid + \'-sortdir-text\'" aria-sort="{{col.sort.direction == asc ? \'ascending\' : ( col.sort.direction == desc ? \'descending\' : (!col.sort.direction ? \'none\' : \'other\'))}}">' +
            //     '<div role="button" tabindex="0" class="ui-grid-cell-contents ui-grid-header-cell-primary-focus" col-index="renderIndex" ng-style="col.colDef.headerCellStyle">' +
            //         '<span class="ui-grid-header-cell-label" ui-grid-one-bind-id-grid="col.uid + \'-header-text\'">{{ col.displayName }}</span> ' +
            //         '<span ui-grid-one-bind-id-grid="col.uid + \'-sortdir-text\'" ui-grid-visible="col.sort.direction" aria-label="{{getSortDirectionAriaLabel()}}">' +
            //         '   <i ng-class="{ \'ui-grid-icon-up-dir\': col.sort.direction == asc, \'ui-grid-icon-down-dir\': col.sort.direction == desc, \'ui-grid-icon-blank\': !col.sort.direction }" title="{{col.sort.priority ? i18n.headerCell.priority + \' \' + col.sort.priority : null}}" aria-hidden="true"></i>' +
            //         '   <sub class="ui-grid-sort-priority-number">{{col.sort.priority}}</sub>' +
            //         '</span>' +
            //     '</div>' +
            //     '<div ui-grid-filter></div>' +
            // '</div>';

        var cellTemplate =
            '<div class="ui-grid-cell-contents" ng-style="col.colDef.cellStyle">{{COL_FIELD }}</div>';

        $scope.gridOptions1 = {
            rowHeight: 40,
            headerRowHeight: 0,
            showHeader: false,
            headerTemplate: headerCellTemplate,
            enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
            enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
            columnDefs: [
                { field: 'field1', id: "used", displayName: '统计数据', width: "250", resizable: true, pinnedLeft:true, enableColumnMenu: false, sort: { direction: uiGridConstants.ASC } }
            ],
            data:[
                {"field1":"显示时段日平均能耗(Daily Average)"},
                {"field1":"显示时段每日最高能耗(Daily Max)："},
                {"field1":"显示时段每日最低能耗(Daily Min)："},
                {"field1":"日内最高小时能耗(Hourly Max):"},
                {"field1":"日内最低小时能耗(Hourly Min)："},
                {"field1":"高峰用电百分比(Peak Energy %):"},
                {"field1":"系统负载因数 (Load Factor):"},
            ]
        }

        $scope.gridOptions1.onRegisterApi = function (gridApi) {

            $scope.gridApi1 = gridApi;
        }

        $scope.closeConfig = function(){

            $scope.formData = null;
        }

        // Send node edit event
        $scope.edit = function (node, evt) {
            evt.preventDefault();
            evt.stopPropagation();
            $rootScope.$broadcast('chart-serie-edit', node);
        };

        //Unsubscribe from broadcast on controller destroy event
        $scope.$on('$destroy', function () {
            unbindSerieChecked();
            onLayoutResize();
        });

    }])

},{}],12:[function(require,module,exports){
angular.module('app.controllers.charts.summary.list', [])

    .controller('chartsListCtrl', ['$scope', '$rootScope', '$filter', 'seriesService', 'EnergyUnitFactory', 'uiGridConstants', '$q', '$window', '$http', '$timeout', '$interval', 'csv2json', 'LanguageFactory', function ($scope, $rootScope, $filter, seriesService, EnergyUnitFactory, uiGridConstants, $q, $window, $http, $timeout, $interval, csv2json,LanguageFactory) {

    	// TODO: MERGE FROM LOCAL

    }]);

},{}],13:[function(require,module,exports){
require('./home.summary.js');

angular.module('app.controllers.home', [
		'app.controllers.home.summary'
	]);

},{"./home.summary.js":14}],14:[function(require,module,exports){
angular.module('app.controllers.home.summary', [])

    .controller('homeCtrl', [
        '$ionicHistory', '$scope', '$rootScope', '$state', 'toastr', 'toastrConfig', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
        function ($ionicHistory, $scope, $rootScope, $state, toastr, toastrConfig, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {





            /********************************************************************
             *
             *
             *  Table
             *
             *
            *********************************************************************/

            // $scope.getGridHeight = function() {
            //     var headerHeight = 75;
            //     var minLength = Math.max($scope.gridOptions1.data.length, 3); // At least 3;
            //     return {
            //         height: (Math.min($scope.gridOptions1.paginationPageSize, minLength) * $scope.gridOptions1.rowHeight + headerHeight) + "px"
            //     };
            // };


            // var numberAsStringSortFn = function(a, b, c, d, e) {
            //     var valA = parseInt(c.entity.value);
            //     var valB = parseInt(d.entity.value);
            //     if (valA == valB) return 0;
            //     if (valA < valB) return -1;
            //     return 1;
            // };
            // var usageTemplate= '<div ng-if="row.entity.usage">{{row.entity.usage}}</div><div ng-if="!row.entity.usage">评估进行中 </div>';
            // var saving_moneyTemplate= '<div ng-if="row.entity.saving_money">{{row.entity.saving_money}}</div><div ng-if="!row.entity.saving_money">评估进行中 </div>';
            // var saving_co2Template= '<div ng-if="row.entity.saving_co2">{{row.entity.saving_co2}}</div><div ng-if="!row.entity.saving_co2">评估进行中 </div>';
            // $scope.gridOptions = {
            //     enableRowSelection: true,
            //     enableRowHeaderSelection: false,
            //     multiSelect: false,
            //     enableSelectAll: false,
            //     rowHeight: 55,
            //     enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
            //     columnDefs: [
            //         { field: 'campus', displayName: '区域名称', width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, sort: { direction: uiGridConstants.ASC } },
            //         { field: 'name', displayName: '建筑名称', width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, },
            //         { field: 'type', displayName: '能效等级', width: 200, resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellClass: 'text-center', sortingAlgorithm: numberAsStringSortFn, type: 'number', cellTemplate: '<uib-rating ng-model="row.entity.value" max="5" state-on="\'icon-star\'" state-off="\'hide-star\'" readonly="true">{{row.entity.value}}</uib-rating>' },
            //         // { field: 'usage', displayName: '总能耗', cellTemplate:usageTemplate,width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellClass: 'text-center', sortingAlgorithm: numberAsStringSortFn, type: 'number' },
            //         // { field: 'saving_money', displayName: '总节能潜力', cellTemplate:saving_moneyTemplate,width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellClass: 'text-center', sortingAlgorithm: numberAsStringSortFn, type: 'number' },
            //         // { field: 'saving_co2', displayName: '碳排减少空间', cellTemplate:saving_co2Template, width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellClass: 'text-center', sortingAlgorithm: numberAsStringSortFn, type: 'number' },
            //     ]
            // }

            // var url = 'api/energyunit/?format=json';

            // //TODO: CACHE THIS
            // $http.get(url/*, {cache: $templateCache}*/).then(function(result) {
            //     $scope.gridOptions.data = result.data.objects;
            // },function(err){
            //     console.log('err', err);
            // });

            // $scope.gridOptions.onRegisterApi = function(gridApi) {
            //     $scope.gridApi1 = gridApi;
            //     $scope.gridApi1.selection.on.rowSelectionChanged($scope, function (row) {
            //         $state.go('root.recommendations.summary', { id: row.entity.id });
            //     });
            // };


            /********************************************************************
            *
            *
            *  News feed
            *
            *
            *********************************************************************/


            // $scope.showNews = function(item) {
            //     $scope.selectedNews = item;
            //     $scope.newsFeedSwiper.swiper.slideNext();
            // }

            // $scope.hideNews = function(item) {
            //     $scope.newsFeedSwiper.swiper.slidePrev();
            // }


            // $scope.onNewsHeadlinesReady = function(swpr) {
            // console.log('onNewsHeadlinesReady ' , swpr);
            //     $scope.newsHeadlinesSwiper = swpr;
            // }

            // $scope.onNewsReady = function(swpr) {
            //     $scope.newsFeedSwiper = swpr;
            // }

            // $scope.getCategoryColor = function(categ){
            //     switch(categ){
            //         case '建议': return 'orange';
            //         case '新闻': return 'blue';
            //         case '报警': return 'magenta';
            //         default: return '#aaa';
            //     }
            // }

            // $scope.onBack = function(){
            //     console.log('on back button clicked');
            //     $scope.newsVisible = !$scope.newsVisible;
            // }


            //MiscSelectionFactory.get({name:'blog_post'}).then(function(result){
                //$scope.newsItems=$scope.convertTo(result.objects, 'created', false);
                // $timeout(function () {
                //     $scope.newsFeedSwiper.swiper.update(true);
                //     $scope.newsHeadlinesSwiper.swiper.update(true);
                // }, 5000);

            // var swiper = new Swiper('.swiper-container', {
            //})
            //     scrollbar: '.swiper-scrollbar',
            //     scrollbarHide: true,
            //     slidesPerView: 'auto',
            //     centeredSlides: true,
            //     spaceBetween: 30,
            //     grabCursor: true
            // });
        }
    ])    

    .controller('mapCtrl', [
        '$ionicHistory', '$scope', '$rootScope', '$state', 'toastr', 'toastrConfig', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'DataSource', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
        function ($ionicHistory, $scope, $rootScope, $state, toastr, toastrConfig, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, DataSource, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {


            /********************************************************************
             *
             *
             *  Baidu map
             *
             *
            *********************************************************************/


            var longitude = 121.47537;
            var latitude = 31.232844;

            $scope.mapOptions = {
                center: {
                    longitude: longitude,
                    latitude: latitude
                },
                enableScrollWheelZoom: false,
                zoom: 10,
                city: 'ShangHai',
                markers: [],
                onMarkerClick: function (marker) {
                    if (marker){
                        $scope.$apply(function () {
                            $rootScope.$state.go('root.reports.summary', { id: marker.id });
                        });
                    }
                },
                onMarkerTap: function(marker){
                    if(marker){

                        $rootScope.$apply(function(){
                            _.each(DataSource.EnergyUnits(), function(next){
                              next.__selected = next.id == marker.id;
                              next.__highlighted = false;
                            });
                        });

                        toastrConfig.positionClass = 'bottom-left';
                        toastrConfig.maxOpened = 1; 
                        toastrConfig.closeHtml = '<button class="svg-building"></button>';
                        toastrConfig.autoDismiss = true;
                        toastrConfig.toastClass = 'custom-toast';
                        toastrConfig.target = '.map-marker-toast'; //TODO: change this
                        toastrConfig.templates = {
                            toast: 'templates/unit.toast.html',
                            progressbar: 'templates/toast.progressbar.html'
                        };
                        console.log('marker ' , marker);

                        toastr.info(marker.name, marker.data_campus, { 
                            extraData: marker.id,
                            closeButton: true,
                            extendedTimeOut: 60000,
                            timeOut: 60000,
                            onTap: function(toast){
                                $rootScope.setActiveView('subnav');
                                $rootScope.go('root.home.unit', { id: toast.scope.extraData });
                            }
                        });
                    }
                },
                onMarkerMouseOver: function(target){
                    var building = _.find(DataSource.EnergyUnits(), function(item){
                        return item.id == target.id;
                    });

                    $rootScope.$apply(function(){
                        building.__highlighted = true;
                    })
                },
                onMarkerMouseOut: function(e){
                    $rootScope.$apply(function(){

                        var building = _.find(DataSource.EnergyUnits(), function(item){
                            return item.id == e.target.customInfo.id;
                        });

                        building.__highlighted = false;
                    })


                }
            };

            $scope.zoomIn = function(){
                $scope.mapOptions.zoom = $scope.mapOptions.zoom + 1;
            }

            $scope.zoomOut = function(){
                $scope.mapOptions.zoom = $scope.mapOptions.zoom - 1;
            }

            if(platformService.isMobile){
                $scope.mapOptions.scaleCtrl = false;
                $scope.mapOptions.navCtrl = false;
            }

            // TODO: Simplify this
            $scope.$watchCollection(function(){
                return DataSource.EnergyUnits();
            }, 
                function(value){
                    $scope.loadData();
                }
            );


            //Watch for authorization to load data
            $scope.$watch(function(){
                            return $rootScope.isAuthorized();        
                        }, 
                        function(value){
                            if(value){
                                $timeout(function(){
                                    $scope.loadData();
                                })
                            }
                        }
            );


            DataSource.changed().then(function(){

            });

            // Load data for markers
            $scope.loadData = function(){
                //TODO: REFACTOR THIS AND CACHE DATA
                //$http.get('api/energyunit/?format=json&type__name=Building').then(function(result) {

                    //var buildingList = DataSource.EnergyUnits(); //result.data.objects;

                    /******************************************************
                    *
                    * Map related after 2016.01.03 modifications
                    *
                    *******************************************************/

                    _.forEach(DataSource.EnergyUnits(), function(building){
                        
                        
                        // fallback gps
                        building.buildingParam=building.buildingParam||{};

                        var geoPoint = building.GPSlocation ? building.GPSlocation.split(',') : [];
                        // marker preset
                        var marker = {
                            id: building.id,
                            source: building,
                            name: building.name,
                            data_campus: building.campus,
                            data_rating: building.value,
                            icon: 'static/image/building_icon3.png',
                            iconHover: 'static/image/building_icon4.png',
                            width: 49,
                            height: 60,
                            title: building.name,
                            content: '<a href="reports/' + building.id + '/summary">进入报告页</a>' //UGLY, but no other way
                        }
                        if(geoPoint.length==2){
                            $scope.mapOptions.markers.push(angular.extend(marker,
                                {
                                    longitude: geoPoint[0],
                                    latitude: geoPoint[1]
                                }
                            ));
                        }else{
                            geoService.toGPS(building.id).then(
                                function(success)
                                {
                                    //address to gps
                                    $scope.mapOptions.markers.push(angular.extend(marker,
                                        {
                                            longitude: success.location.lng,
                                            latitude: success.location.lat
                                        }
                                    ));
                                },
                                function(failure)
                                {
                                    //TODO: Error handling and log service
                                    //console.log('cannot get GPS coordinate due to incorrect address');
                                }
                            );
                        }
                        // retriving address

                    });
                // },function(err){
                //     console.log('err', err);
                // });

            }


            $timeout(function(){
                $scope.loadData();
            })

        }
    ]);




    //  TODO: DELETE ME
    //  MOVED: ../account/account.login.js

    // .controller('loginCtrl',[
    // '$scope', '$rootScope','$state', 'accountService', 'localStorageService',function ($scope, $rootScope, $state,accountService,localStorageService) {
        
    //     $scope.signin=function(){
    //     var formData={
    //         username:$scope.username,
    //         password:$scope.password
    //     }
    //     accountService.signin(formData).then(
    //         function(token){
    //             localStorageService.set('token',token);
    //             $state.go('root.home')
    //         },
    //         function(err){
    //             console.log(err);
    //         })

    //     }
    // }]);
},{}],15:[function(require,module,exports){
 
angular.module('app.controllers.nav', [])
    .controller('unitsCtrl', [
        '$ionicHistory', '$ionicScrollDelegate', '$ionicViewSwitcher', '$scope', '$rootScope', '$state', 'toastr', 'toastrConfig', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'DataSource', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
        function ($ionicHistory, $ionicScrollDelegate, $ionicViewSwitcher, $scope, $rootScope, $state, toastr, toastrConfig, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, DataSource, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {


            $scope.buildingListConfig = {
                template: 'template/energy-unit-groupped-list.html',
                data: DataSource.EnergyUnits(),
                datasource: function(){
                    var units = DataSource.EnergyUnits();
                    var evens = _.filter(units, function(obj) {
                        return !$scope.search.term || $scope.search.term.length == 0 || obj.name.toLowerCase().indexOf($scope.search.term.toLowerCase()) >= 0;
                    });

                    return evens;
                },
                filter: function(){
                  return searchTerm;
                },
                onMouseEnter: function(e, item){
                    //item.__highlighted = true;
                },
                onMouseLeave: function(e, item){
                    item.__highlighted = false;
                },
                onClick: function(item, index, e){
                    $ionicViewSwitcher.nextDirection('forward');
                    //TODO: Highlight marker
                    // $scope.navtype = 1; // to sitemap
                    
                    _.each($scope.buildingListConfig.datasource(), function(next){
                      next.__selected = next.id == item.id;
                      next.__highlighted = false;
                    })

                    console.log('item ' , item.id, item);
                    $rootScope.$state.go('root.home.unit', {id: item.id});

                    // Content is hidden and map is shown at energyunit selection view
                    // Hereby switch to sitemap or display user last visited section, but for selected unit

                    // item.__selected = true;
                    // $scope.selectedUnit = item;

                    // if($scope.sitemapItem) {
                    //   $rootScope.$state.go($scope.sitemapItem.href,  {id: $scope.selectedUnit.id});
                    // }

                }
            }
        }
    ])

    .controller('sitemapCtrl', [
        '$ionicHistory', '$ionicScrollDelegate', '$ionicViewSwitcher', '$scope', '$rootScope', '$state', 'toastr', 'toastrConfig', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'DataSource', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
        function ($ionicHistory, $ionicScrollDelegate, $ionicViewSwitcher, $scope, $rootScope, $state, toastr, toastrConfig, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, DataSource, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {

            $scope.load = function(){
                $scope.selectedUnit = _.find(DataSource.EnergyUnits(), function(item){
                    return item.id == $rootScope.$stateParams.id;
                });

                // watch datasource for changes to update selected energy unit
                DataSource.changed().then(function(){
                    $scope.load();
                })
            }

            // initial load
            $scope.load();
            

            $scope.sitemapConfig = {
                template: 'template/sitemap.html',
                data: 
                {
                    "能源报告":          [
                                            { name: '综述指标', href: 'root.home.unit.reports.summary', icon: 'svg-monitor' },
                                            { name: 'DAILY', href: 'root.home.unit.reports.daily', icon: 'svg-monitor' },
                                            { name: '能耗构成', href: 'root.home.unit.reports.disagg', icon: 'svg-pie-chart' },
                                            { name: '历史比较', href: 'root.home.unit.reports.monthly', icon: 'svg-calendar' },
                                            { name: '能耗对比', href: 'root.home.unit.reports.regular', icon: 'svg-combo-chart' },
                                        ],
                    "优化方案":          [
                                            { name: "异常警报", href: 'root.home.unit.reports.alerts', icon: 'svg-alert' },
                                            { name: "节能方案", href: 'root.home.unit.recommendations.summary', icon: 'svg-light-bulb' },
                                            //{ name: "实时监测", href: 'root.home.unit.recommendations.configuration', icon: 'icon-cog' }
                                        ],
                    "分析工具":          [
                                            { name: "实时诊断", href: 'root.home.unit.tools.analysis', icon: 'svg-settings' },
                                            { name: "策略分析", href: 'root.home.unit.tools.strategies', icon: 'svg-flask' },
                                        ],
                },
                onClick: function(item, index, e){

                    $scope.navtype = 2; // keep sitemap view on selection

                    // Select clicked and deselect other sitemap items
                    _.each($scope.sitemapConfig.data, function(categories){
                        _.each(categories, function(next){
                            next.__selected = next == item;
                        })
                    })

                    // show content on mobile
                    $rootScope.setActiveView('content');

                    // EXCEPTION: Show Data page specific navigation
                    if(item.href == 'root.charts.summary')  {
                        $scope.navtype = 3;                  
                        $ionicScrollDelegate.scrollTop();   
                    }

                    $scope.sitemapItem = item;
                    $ionicViewSwitcher.nextDirection('forward');
                    $rootScope.$state.go(item.href, { id: $rootScope.$stateParams.id});
                }
            }
            

        }
    ])

},{}],16:[function(require,module,exports){
require('./news.summary.js');

angular.module('app.controllers.news', [
		'app.controllers.news.summary'
	]);

},{"./news.summary.js":17}],17:[function(require,module,exports){
angular.module('app.controllers.news.summary', [])

    .controller('newsCtrl', [
    	'$scope', '$rootScope', '$state', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache',
		function ($scope, $rootScope, $state, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache) {
			$scope.newsItems = [];
			
			$scope.convertTo = function (arr, key, dayWise) {
                var groups = {};
                for (var i=0;l= arr.length, i<l;i++) {
                    console.log(arr[i][key]);

                    arr[i][key] = moment(arr[i][key]).format('MMM DD, YYYY');
                    groups[arr[i][key]] = groups[arr[i][key]] || [];
                    groups[arr[i][key]].push(arr[i]);
                }
                return groups;
            };


            // Watch for authorization to load data
            $scope.$watch(function(){
                    return $rootScope.isAuthorized();        
                }, 
                function(value){
                    if(value)
                        $scope.load();
                }
            );

            // News category color 
            $scope.getCategoryColor = function(categ){
                switch(categ){
                    case '建议': return 'orange';
                    case '新闻': return 'blue';
                    case '报警': return 'magenta';
                    default: return '#aaa';
                }
            }

            $scope.load = function(){
                //TODO: Cache news 
                MiscSelectionFactory.get({name:'blog_post'}).then(function(result){
                    $scope.originalItems = result.objects;
                    $scope.newsItems=$scope.convertTo(result.objects, 'created', false);
                })
            }
		}
	]);
},{}],18:[function(require,module,exports){
angular.module('app.controllers.recommendations.configuration', [])

    .controller('recommendationsConfigurationCtrl', [
        '$scope', '$rootScope','FormService', function ($scope, $rootScope,FormService) {
            var configid=$rootScope.building
            var categories={'overall':{},'peak':{},'hvac':{},'lighting':{}};
            $scope.data={};
            FormService.load({energy_unit_id:$rootScope.$stateParams.id}).then(
                function(result) {
                    // for (key in categories){
                    //     for (item in result){
                    //         if(item.startsWith(key)){
                    //             if(item.contains('is_active')){
                    //                 categories[key]['enabled']=result[item]
                    //             }else{
                    //                 categories[key]['properties']=categories[key]['properties']||[];

                    //                 categories[key]['properties'].push({
                    //                     "name": item,
                    //                     "title": "title1",
                    //                     "value": result[item],
                    //                     "required": true,
                    //                     "regex": "^[0-9]$"
                    //                    });
                    //             }
                    //         }
                    //     }
                    // }
                    $scope.data = result;
                },
                function(error) {
                    console.log(error);
                }
            );

            $scope.save = function() {
                // var saveData={};
                // for (key in $scope.data){
                //     var d=$scope.data[key];
                //     saveData[key+'_is_active']=d['enabled'];

                //     for(var i=0;i< d['properties'].length;i++){
                //         saveData[d['properties'][i]['name']]=d['properties'][i]['value']||"";
                //     }
                // }
                var saveData=$scope.data;
                FormService.save(saveData,{energy_unit_id:$rootScope.$stateParams.id}).then(null,function(err){
                    console.log(err);
                })
            };
        }
    ])
},{}],19:[function(require,module,exports){
require('./recommend.nav.js');
require('./recommend.summary.js');
require('./recommend.summary.details.js');
require('./recommend.strategies.js');
require('./recommend.strategy1.js');
require('./recommend.strategy2.js');
require('./recommend.strategy3.js');
require('./recommend.strategy4.js');
require('./recommend.strategy5.js');
require('./recommend.config.js');


angular.module('app.controllers.recommendations', [
        'app.controllers.recommendations.nav',
        'app.controllers.recommendations.summary',
        'app.controllers.recommendations.summary.details',
        'app.controllers.recommendations.strategies',
        'app.controllers.recommendations.strategies.strategy1',
        'app.controllers.recommendations.strategies.strategy2',
        'app.controllers.recommendations.strategies.strategy3',
        'app.controllers.recommendations.strategies.strategy4',
        'app.controllers.recommendations.strategies.strategy5',
        'app.controllers.recommendations.configuration'
    ]);
},{"./recommend.config.js":18,"./recommend.nav.js":20,"./recommend.strategies.js":21,"./recommend.strategy1.js":22,"./recommend.strategy2.js":23,"./recommend.strategy3.js":24,"./recommend.strategy4.js":25,"./recommend.strategy5.js":26,"./recommend.summary.details.js":27,"./recommend.summary.js":28}],20:[function(require,module,exports){
angular.module('app.controllers.recommendations.nav', [])

    .controller('recommendationsNavCtrl', [
        '$scope', '$rootScope', 'EnergyUnitFactory', function($scope, $rootScope, EnergyUnitFactory) {
            EnergyUnitFactory.getByType(1).then(function(result) {

                //Redirect to first applicable Building if received 0 for ID
                if ($rootScope.$stateParams.id == 0) {
                    $rootScope.$state.go($rootScope.$state.current.name, { id: result[0].id });
                }

                $scope.items = result;

            });

            $scope.selectBuilding = function(building) {
                $rootScope.$state.go($rootScope.$state.current.name, { id: building.id });
            }

        }
    ])

},{}],21:[function(require,module,exports){
angular.module('app.controllers.recommendations.strategies', [])

    .controller('recommendationsStrategiesCtrl', [
        '$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', function ($scope, $rootScope, FormService, uiGridConstants, $http) {

            $scope.info = function(row) {
                console.log(row);
            };

            var imageCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <div  style="width: 130px; height: 80px; background: url({{row.entity.image}}) no-repeat center center; background-size: cover;"></div>' +
                    '</div>';

            var titleCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <h4 ng-bind="row.entity.name"></h4>' +
                    '   <p ng-bind="row.entity.description"></p>' +
                    '</div>';

            var categoryCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <h4 ng-bind="row.entity.category"></h4>' +
                    '</div>';


            var actionCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <button class="btn btn-default btn-blue" ng-click="grid.appScope.execute(row.entity)">进入分析结果</button>' +
                    '</div>';


            $scope.execute = function(entity) {
                $rootScope.$state.go(entity.route);
            }

            $scope.gridOptions1 = {
                enableRowSelection: false,
                enablePaginationControls: false,
                enableRowHeaderSelection: false,
                multiSelect: false,
                enableSelectAll: false,
                paginationPageSize: 3,
                rowHeight: 100,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                columnDefs: [
                    { field: 'image', displayName: '策略图', width: "150", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellTemplate: imageCellTemplate },
                    { field: 'description', displayName: '详情描述', width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellTemplate: titleCellTemplate },
                    { field: 'category', displayName: '类别', width: "150", resizable: true, headerCellClass: 'green', enableColumnMenu: false, sort: { direction: uiGridConstants.ASC }, cellTemplate: categoryCellTemplate },
                    { field: 'action', displayName: '执行行动', width: "150", resizable: true, headerCellClass: 'green', cellClass: 'fwb tac', enableColumnMenu: false, cellTemplate: actionCellTemplate },
                ],
                data: [
                    { id: '1', 'name': '分时段对比', 'description': '比较在同一楼宇在两个不同是时间段的用电量以及用电规律，可以直观的发现用电异常时段。选择比较的时段可以是一天，一周或者一月。比较两个时段的分时用电量以及用电费用。', 'category': '节能试验室', route: 'root.home.unit.tools.strategies.strategy1', image: 'static/image/strategy1.png' },
                    { id: '2', 'name': '削峰填谷', 'description': '通常情况下，用电高峰通常在白天，晚上则是低谷。但是高峰期的电价是低谷的四倍之多，致使一个企业在高峰用电成本很高。通过模拟找出一部分或者不必要的高峰负荷挪到晚上低谷期，从而就利用了晚上多余的电力，也就达到了节约能源的目的。', 'category': '节能试验室', route: 'root.home.unit.tools.strategies.strategy2', image: 'static/image/strategy2.png' },
                    { id: '3', 'name': '晚间与周末分析', 'description': '大部分用电组成是与楼宇的使用行为相关。晚间于周末的行为用电应为低谷，也是节能的必要。该策略对比在选择时间区域内用户周中，周末以及节假日用电的组成，从中发现潜在问题。', 'category': '节能试验室', route: 'root.home.unit.tools.strategies.strategy3', image: 'static/image/strategy3.png' },
                    { id: '4', 'name': '节能目标分析', 'description': '定期设定合理的节能目标至关重要。用户可以在同一楼宇可选的的时间范围内，调整六组分类能耗的节能潜力，从而看到相应的潜力对整体能耗的影响。', 'category': '策划与分析', route: 'root.home.unit.tools.strategies.strategy4', image: 'static/image/strategy4.png' },
                    { id: '5', 'name': '能耗表现', 'description': '实时的了解能耗进展对节能起到最有效的监督与督促。该工具可以使用户随时查看任意选择时段内的能耗。工具提供灵活的选择，用户可以与从一周上至一年的历史数据进行比较，自动去除了天气和人为因素，从而实时的监视能效进展。', 'category': '策划与分析', route: 'root.home.unit.tools.strategies.strategy5', image: 'static/image/strategy5.png' }
                ]
            };

            //TODO: Keep it DRY, getNumber appeared for second time
            $scope.getNumber = function (num) {
                return new Array(num);
            }

            $scope.gridOptions1.onRegisterApi = function(gridApi) {
                $scope.gridApi1 = gridApi;
            };

        }
    ]).controller('analysisCtrl', [
        '$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', function ($scope, $rootScope, FormService, uiGridConstants, $http) {

            $scope.info = function(row) {
                console.log(row);
            };

            var imageCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <div  style="width: 130px; height: 80px; background: url({{row.entity.image}}) no-repeat center center; background-size: cover;"></div>' +
                    '</div>';

            var titleCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <h4 ng-bind="row.entity.name"></h4>' +
                    '   <p ng-bind="row.entity.description"></p>' +
                    '</div>';

            var categoryCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <h4 ng-bind="row.entity.category"></h4>' +
                    '</div>';


            var actionCellTemplate =
                '<div class="ui-grid-cell-contents p0">' +
                    '   <button class="btn btn-default btn-blue" ng-click="grid.appScope.execute(row.entity)">进入分析结果</button>' +
                    '</div>';


            $scope.execute = function(entity) {
                $rootScope.$state.go(entity.route);
            }

            $scope.gridOptions1 = {
                enableRowSelection: false,
                enablePaginationControls: false,
                enableRowHeaderSelection: false,
                multiSelect: false,
                enableSelectAll: false,
                paginationPageSize: 3,
                rowHeight: 100,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                columnDefs: [
                    { field: 'image', displayName: '诊断图', width: "150", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellTemplate: imageCellTemplate },
                    { field: 'description', displayName: '详情描述', width: "*", resizable: true, headerCellClass: 'green', enableColumnMenu: false, cellTemplate: titleCellTemplate },
                    { field: 'category', displayName: '类别', width: "150", resizable: true, headerCellClass: 'green', enableColumnMenu: false, sort: { direction: uiGridConstants.ASC }, cellTemplate: categoryCellTemplate },
                    { field: 'action', displayName: '执行措施', width: "150", resizable: true, headerCellClass: 'green', cellClass: 'fwb tac', enableColumnMenu: false, cellTemplate: actionCellTemplate },
                ],
                data: [
                    { id: '4', 'name': '能耗透析', 'description': '通过实时的数据采集，采用不同的颜色显示出不同时段下用电负荷的变化情况，可以较为直观的看出任意时段的用能情况。', 'category': '实时分析', route: 'root.home.unit.tools.heatmap', image: 'static/image/strategy7.png' }
                ]
            };

            //TODO: Keep it DRY, getNumber appeared for second time
            $scope.getNumber = function (num) {
                return new Array(num);
            }

            $scope.gridOptions1.onRegisterApi = function(gridApi) {
                $scope.gridApi1 = gridApi;
            };

        }
    ]);

},{}],22:[function(require,module,exports){
angular.module('app.controllers.recommendations.strategies.strategy1', [])

    .controller('strategy1Ctrl', [
        '$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', '$q', 'seriesService', '$timeout', '$window', 'UtilityService',function ($scope, $rootScope, FormService, uiGridConstants, $http, $q, seriesService, $timeout, $window,UtilityService) {
            var cancelLoad = $q.defer();
            $scope.compareConfig = { mode: 'day', minMode: 'day', maxMode: 'year', dt1: moment().valueOf(), dt2: moment().valueOf() };
            $scope.time = 0;
            $scope.sliderConfig = {
                floor: 0, ceil: 4, onChange: function () { $scope.change(); }, showTicks: true, showTicksValues: true,
                translate: function(value) {
                    switch (value) {
                        case 0: return '0h';
                        case 1: return '30m';
                        case 2: return '1h';
                        case 3: return '1:30';
                        case 4: return '2h';
                    }
                }
            }

            $scope.load = function () {
                $scope.loading = true;
                $http.get('/api/stratege/0', { timeout: cancelLoad.promise }).then(function (result) {
                   $scope.loading = false;
                   $scope.resultData = result;
                   $scope.applyCompare();
                });

            }
            $scope.load();

            // Start with utc offset 8 hours to match Highcharts global configuration
            var pointStart = moment().utc().utcOffset(-480).startOf('day').valueOf();
            var pointInterval = 3600 * 1000;

            $scope.chartOptions1 = {
                options: {
                    chart: {
                        alignTicks: true, spacingBottom: 15,
                        spacingTop: 0,
                        spacingLeft: 0,
                        spacingRight: 0
                    },
                    title: null,
                    legend: {
                        enabled: true,
                        layout: 'horizontal',
                    },
                    plotOptions: {
                        series: {
                            pointStart: pointStart,
                            pointInterval: pointInterval
                        }
                    },
                    xAxis: {
                        showFirstLabel: true, showLastLabel: false,
                        tickWidth: 0, min: pointStart,
                        startOnTick: true, endOnTick: true,
                        type: 'datetime',
                        tickInterval: 60 * 60 * 1000 * 2,
                        labels: {
                            rotation: 0,
                            y: -5,
                            x: 5,
                            align: 'left',
                            formatter: function () {
                                return Highcharts.dateFormat('%H:%M', this.value);
                            }
                        }
                    },
                    yAxis: {
                        title: { text: '' }, gridLineWidth: 1, minorGridLineWidth: 0, min: 0, labels: { align: 'left', x: 5, y: -5 }, showFirstLabel: false, showLastLabel: false
                    },
                    tooltip: {
                        pointFormat: '{series.name}: <b>{point.y:.2f}kW</b><br>' ,
                        shared: true, followPointer: true, crosshairs: {
                            color: 'green',
                            dashStyle: 'dash'
                        },
                    },
                    credits: false
                },
                series: [
                    {
                        name: moment($scope.compareConfig.dt1).utc().utcOffset(-480).format('MMM DD, YYYY'),
                        data: [], // 24 hours
                        color: Highcharts.getOptions().colors[1]
                    },
                    {
                        name: moment($scope.compareConfig.dt2).utc().utcOffset(-480).format('MMM DD, YYYY'),
                        data: [],
                        color: Highcharts.getOptions().colors[2]
                    }
                ]
            }

            $scope.setMode = function (mode) {
                switch (mode) {
                    case 'day':
                        $scope.compareConfig.mode =
                        $scope.compareConfig.minMode =
                        $scope.compareConfig.maxMode = 'day';
                        break;
                    case 'week':
                        $scope.compareConfig.mode = 'week';
                        $scope.compareConfig.minMode =
                        $scope.compareConfig.maxMode = 'day';
                        break;
                    case 'month':
                        $scope.compareConfig.mode =
                        $scope.compareConfig.minMode = mode;
                        $scope.compareConfig.maxMode = 'year';
                        break
                }
            }

            $scope.formatPeriod = function (date) {
                var result = '', dt = moment(date).utc().utcOffset(-480);
                switch ($scope.compareConfig.mode) {
                    case 'day':
                        result = dt.format('MMM DD, YYYY');
                        break;
                    case 'week':
                        result = 'Week ' + dt.week();
                        break;
                    case 'month':
                        result = dt.format('MMMM YYYY');
                        break;
                }
                return result;
            };

            $scope.applyCompare = function () {

                var pointStart,
                    pointStart2,
                    tickInterval,
                    pointInterval,
                    name1,
                    name2,
                    data1,
                    data2,
                    formatter,
                    date1 = moment($scope.compareConfig.dt1).utc().utcOffset(-480),
                    date2 = moment($scope.compareConfig.dt2).utc().utcOffset(-480);

                var displaySeries=function(start1,start2,mode){
                    var interval=60*60*1000*24; // one day
                    var pointInterval="15m";
                    if(mode=="week"){
                        interval*=7;
                    }else if(mode=="month"){
                        interval*=30;
                        pointInterval="60m";
                    }
                    $q.all(
                        [
                            seriesService.load($rootScope.$stateParams.id,start1,start1+interval,{interval:pointInterval}),
                            seriesService.load($rootScope.$stateParams.id,start2,start2+interval,{interval:pointInterval}),
                            UtilityService.getEnergyPrice()
                        ]
                    ).then(function(result){
                        var series1=((result[0][0]||{}).points||[]).reverse(),
                            series2=((result[1][0]||{}).points||[]).reverse(),
                            data1 = [0],
                            data2 = [0];

                        $scope.range1={};
                        $scope.range2={};

                        $scope.price=result[2];

                        if(series1.length){

                            data1 =_.map(series1,function(d){
                                return d[1];
                            })

                            var time=series1[0][0];
                            var p=UtilityService.isSummer(time) ? $scope.price['s'] : $scope.price['ns'];
                            $scope.range1.stats=UtilityService.getAreaUnderCurve(series1,{partitions:true});
                            $scope.range1.charge={'h':$scope.range1.stats['h']*p['h'],'m':$scope.range1.stats['m']*p['m'],'l':$scope.range1.stats['l']*p['l']};
                        }

                        if(series2.length){

                            data2 = _.map(series2,function(d){
                                return d[1];
                            });

                            var time=series2[0][0];
                            var p=UtilityService.isSummer(time) ? $scope.price['s'] : $scope.price['ns'];
                            $scope.range2.stats=UtilityService.getAreaUnderCurve(series2,{partitions:true});
                            $scope.range2.charge={'h':$scope.range2.stats['h']*p['h'],'m':$scope.range2.stats['m']*p['m'],'l':$scope.range2.stats['l']*p['l']};
                        }

                        $scope.chartOptions1.series[0].data  = data1;
                        $scope.chartOptions1.series[1].data  = data2;

                    });
                }

                // Close Compare configuration Popup
                $scope.isCompareOpen = false;

                switch ($scope.compareConfig.mode) {
                    case 'day':
                        // start of day
                        pointStart=date1.startOf('day').valueOf();
                        pointStart2=date2.startOf('day').valueOf();
                      // tick interval
                        //tickInterval = 60 * 60 * 1000 * 4; // *2 to fit hours

                        // point interval
                        pointInterval = 60 * 60 * 1000/4;

                        // Serie name for Tooltip and Legend
                        name1 = date1.format('MMM DD, YYYY');
                        name2 = date2.format('MMM DD, YYYY');
                       // label format
                        format = '%H:%M'; // hour & minutes

                        break;
                    case 'week':
                        // start of week
                        pointStart = date1.startOf('isoweek').valueOf();
                        pointStart2=date2.startOf('isoweek').valueOf();
                        // tickInterval = 60 * 60 * 24 * 1000;
                        pointInterval = 60 * 60  * 1000/4;

                        // Serie name for Tooltip and Legend
                        name1 = 'Week ' + date1.week();
                        name2 = 'Week ' + date2.week();

                         // label format
                        format = '%A'; // Week number
                        break;
                    case 'month':
                        // start of month
                        pointStart = date1.startOf('month').valueOf();
                        pointStart2= date2.startOf('month').valueOf();
                        // tick interval
                        // tickInterval = 60 * 60  * 1000;

                        // point interval
                        pointInterval = 60 * 60 * 1000;

                        // Serie name for Tooltip and Legend
                        name1 = date1.format('MMMM YYYY');
                        name2 = date2.format('MMMM YYYY');

                        // label format
                        format = '%e'; // Month
                        break;
                }
               $scope.chartOptions1.options.xAxis.min = pointStart;

                // start of day
                $scope.chartOptions1.options.plotOptions.series.pointStart = pointStart;

                // tick interval
                $scope.chartOptions1.options.xAxis.tickInterval = tickInterval;
                // point interval
                $scope.chartOptions1.options.plotOptions.series.pointInterval = pointInterval;

                // Serie name for Tooltip and Legend
                $scope.chartOptions1.series[0].name = name1;
                $scope.chartOptions1.series[1].name = name2;

                displaySeries(pointStart,pointStart2,$scope.compareConfig.mode);

                $scope.chartOptions1.options.xAxis.labels.formatter = function () {
                    return Highcharts.dateFormat(format, this.value);
                };
            };

            $scope.getDatepickerClass = function (date, mode) {
                return '';
            }

            $timeout(function () {
                angular.element($window).triggerHandler('resize');
            });

            $scope.onCancelStrategy = function () {
                $rootScope.$state.go('root.home.unit.recommendations.strategies');
            }

            $scope.$on('$destroy', function () {
                cancelLoad.resolve();
            });
    }])
},{}],23:[function(require,module,exports){
angular.module('app.controllers.recommendations.strategies.strategy2', [])

    .controller('strategy2Ctrl', ['$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', '$q', 'AllMetersService', 'UtilityService', '$timeout', '$window', function ($scope, $rootScope, FormService, uiGridConstants, $http, $q, AllMetersService, UtilityService, $timeout, $window) {
        var cancelLoad = $q.defer();
        $scope.sliderConfig = {
            floor: 0, ceil: 4, onChange: function() { $scope.change(); }, showTicks: true, showTicksValues: true,
            translate: function (value) {
                switch (value) {
                    case 0: return '0h';
                    case 1: return '30m';
                    case 2: return '1h';
                    case 3: return '1:30';
                    case 4: return '2h';
                }
            }
        }


        $scope.highchartNG={
                    options: {
                    chart: { alignTicks: false },
                    title: null, //{ text: '_', style: { 'color': 'white' } },
                    xAxis: { type: 'datetime', labels: { align: 'left', x: 5, y: 14, format: '{value:%B}' } }, // long month
                    yAxis: [
                         {
                            // Energy
                            gridLineWidth: 1, minorGridLineWidth: 0,
                            title: { text: '总电费', style: { color: '#5AA5E9' } },
                            labels: { format: '{value} ￥', style: { color: '#5AA5E9' } }
                        }
                    ],
                    tooltip: {
                        pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b> ({point.percentage:.0f}%)<br/>',
                        shared: true
                    },
                    plotOptions: {
                        column: {
                            stacking: 'normal'
                        }
                    },
                    credits: { enabled: false }
                },
                series: [
                    {
                        type: 'column', name: '节省', id: 'save',
                        tooltip: { pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b><br/>' },
                        data: [],
                    },
                    {
                        type: 'column', name: '能耗', id: 'realdata', color: '#5AA5E9',
                        tooltip: { pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b><br/>' },
                        data: [],
                    }
                ]
        }
        $scope.time = 1;
        var p=UtilityService.getEnergyPrice()
        p.then(function(result){
            $scope.price=result;
        });
        $scope.change = function () {
            if (!$scope.highchartData) return;
            var groupedEnergy = [], savedEnergy = [];
            var stats= { usage: { h: 0, m: 0, l: 0 }, charge: { h: 0, m: 0, l: 0 }, change: { h: 0, m: 0, l: 0 }, priceDiff: { h: 0, m: 0, l: 0 } };
            for (key in $scope.highchartData){
                if($scope.highchartData.hasOwnProperty(key)) {
                    var d = $scope.highchartData[key];

                    var time = d[0];
                    var p = UtilityService.isSummer(time) ? $scope.price['s'] : $scope.price['ns'];
                    var peakHours = UtilityService.isSummer(time) ? 7 : 6;
                    var e = d[1];

                    //var eDiff = e['h'] * $scope.time / peakHours; <-- !!! WARNING: e['h'] is originaly written, but not defined
                    var eDiff = e['m'] * $scope.time / peakHours;

                    var total = e['h'] * p['h'] + e['m'] * p['m'] + e['l'] * p['l'];
                    var save = (e['h'] * $scope.time / peakHours) * (p['h'] - p['l']);
                    stats['usage']['h'] += e['h'] || 0;
                    stats['usage']['m'] += e['m'] || 0;
                    stats['usage']['l'] += e['l'] || 0;

                    stats['change']['h'] -= eDiff;
                    stats['change']['l'] += eDiff;

                    groupedEnergy.push([new Date(time).getTime(), total]);
                    savedEnergy.push([new Date(time).getTime(), save]);
                }
            }
            stats['charge']['h'] = stats['usage']['h'] * p['h'];
            stats['charge']['m'] = stats['usage']['m'] * p['m'];
            stats['charge']['l'] = stats['usage']['l'] * p['l'];
            stats['priceDiff']['h']=stats['change']['h']*p['h'];
            stats['priceDiff']['l']=stats['change']['l']*p['l'];
            $scope.stats = stats;

            $scope.chartGaugeOptions1.series[0].data = [{ name: '高峰能耗', y: (stats['usage'].h || 0) + (stats['change'].h || 0) }, { name: '平谷能耗', y: (stats['usage'].m||0) }, { name: '低谷能耗', y: (stats['usage'].l||0) + (stats['change'].l||0) }];

            $scope.chartGaugeOptions2.series[0].data = [{ name: '高峰费用', y: (stats['charge']['h']||0) + (stats['priceDiff']['h']||0) }, { name: '平谷费用', y: (stats['charge']['m']||0) }, { name: '低谷费用', y: (stats['charge']['l']||0) + (stats['priceDiff']['l']||0) }];

            var dataserie = _.find($scope.highchartNG.series, function (d) {
                return d.id == 'realdata'
            });
            var saveserie = _.find($scope.highchartNG.series, function(d) {
                return d.id == 'save'
            });

            dataserie.data=groupedEnergy;
            saveserie.data=savedEnergy;
        }
        $scope.load = function () {
            $scope.loading = true;
            var allPromises=[];
            allPromises.push($http.get('/api/stratege/0', { timeout: cancelLoad.promise }));
            if ($rootScope.$stateParams.id > 0) {
                var curtime = new Date();
                var lastyear=new Date(curtime);
                lastyear.setYear(lastyear.getFullYear()-1);
                allPromises.push(AllMetersService.load($rootScope.$stateParams.id, lastyear.getTime(),curtime.getTime()));
            }else{
                allPromises.push($q.reject({error:"no building selected"}));
            }
            $q.all(allPromises).then(function(result){
                // After this request is finished, then remove the "loading" view
                $scope.loading = false;

                //$scope.resultData = result[0];
                var points = ((result[1][0] || {}).points || []).reverse();

                var groupedData=_.groupBy(points,function(d){
                    var date=new Date(d[0]);
                    var day="0"+date.getDate();
                    var month="0"+(date.getMonth()+1);
                    var year = date.getFullYear();
                    return year + "/" + month.slice(-2); // ex: 2015/11
                });

                $scope.highchartData=[];

                for (key in groupedData){
                    if(groupedData.hasOwnProperty(key)){
                        var d=groupedData[key];
                        var energy=UtilityService.getAreaUnderCurve(d,{partitions:true});
                        $scope.highchartData.push([key,energy]);
                    }
                }

                $scope.change();

            },function(err){
                console.log("error",err);
            })
        }
        $scope.load();


        //TODO: Define chart options
        $scope.onCancelStrategy = function () {
            $rootScope.$state.go('root.home.unit.recommendations.strategies');
        }


        $scope.chartGaugeOptions1 = {
            options: {
                chart: {
                    type: 'pie'
                },
                title:'',
                // title:{text:'时间段能耗比例'},
                tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
                legend: {
                    enabled: true,
                    layout: 'vertical',
                    align: 'right',
                    width: 200,
                    verticalAlign: 'middle',
                    useHTML: true,
                    labelFormatter: function() {
                        return '<div style="width:150px;"><div style="margin-bottom: 5px;text-align: left; width:100px;float:left;">' + this.name + '</div><div style="width:40px; float:left;text-align:left;">' + this.y.toFixed(2) + '</div></div>';
                    }
                },
                plotOptions: {
                    pie: { allowPointSelect: false, cursor: 'pointer', showInLegend: true }
                },
                credits: { enabled: false },
            },
            series: [
                {
                    data: [],
                    type: 'pie', colorByPoint: true, size: '100%',
                    dataLabels: { enabled: false, color: '#6e6e6e', distance: 10, style: { "fontSize": "14px" }, format: '<b>{point.name}</b>: {point.percentage:.1f} %' }
                }
            ],
            loading: false
        };

        $scope.chartGaugeOptions2 = {
            options: {
                chart: { type: 'pie' },
                title: { text: '' },
                tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
                legend: {
                    enabled: true,
                    layout: 'vertical',
                    align: 'right',
                    width: 200,
                    verticalAlign: 'middle',
                    useHTML: true,
                    labelFormatter: function() {
                        return '<div style="width:150px;"><div style="margin-bottom: 5px;text-align: left; width:100px;float:left;">' + this.name + '</div><div style="width:40px; float:left;text-align:left;">' + this.y.toFixed(2) + '</div></div>';
                    }
                },
                plotOptions: {
                    pie: { allowPointSelect: false, cursor: 'pointer', showInLegend: true },
                },
                credits: { enabled: false }
            },
            series: [
                {
                    data: [],
                    type: 'pie', name: "Source", colorByPoint: true, size: '100%',
                    dataLabels: { enabled: false, color: '#6e6e6e', distance: 10, style: { "fontSize": "14px" }, format: '<b>{point.name}</b>: {point.percentage:.1f} %' }
                }
            ],
            loading: false
        };

        $scope.$on('$destroy', function () {
            cancelLoad.resolve();
        });

    }])
},{}],24:[function(require,module,exports){
angular.module('app.controllers.recommendations.strategies.strategy3', [])

    .controller('strategy3Ctrl', ['$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', '$q', '$window', '$timeout', 'seriesService','UtilityService',function ($scope, $rootScope, FormService, uiGridConstants, $http, $q, $window, $timeout,seriesService,UtilityService) {

        var cancelLoad = $q.defer();
        $scope.dateConfig = { selected: null, minDate: -1 };

        $scope.sliderConfig = {
            minValue: 9, maxValue: 18,
            options: {
                id: 'slider1', floor: 0, ceil: 23, showTicks: true, showTicksValues: true, step: 1,
                onChange: function (id) {
                    $scope.change();
                }
            }
        }

        // Start with utc offset 8 hours to match Highcharts global configuration
        var pointStart = moment().utc().utcOffset(-480).startOf('day').valueOf();
        var pointInterval = 3600 * 1000;

        $scope.chartOptions1 = {
            options: {
                chart: {
                    alignTicks: true, spacingBottom: 15, spacingTop: 0, spacingLeft: 0, spacingRight: 0,
                    type: 'column'
                },
                title: null,
                legend: {
                    enabled: true,
                    layout: 'horizontal',
                },
                plotOptions: {
                    column: {
                        stacking: 'normal',
                        dataLabels: {
                            enabled: true,
                            color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white',
                            format: '{point.y:.2f}' ,
                            style: {
                                textShadow: '0 0 3px black'
                            }
                        }
                    }
                },
                xAxis: {
                    categories: [
                        'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Hollidays'
                    ],
                    tickWidth: 0,
                    startOnTick: true, endOnTick: true,
                    labels: {
                        rotation: 0,
                        align: 'center'
                    }
                },
                yAxis: {
                    title: { text: '' }, gridLineWidth: 1, minorGridLineWidth: 0, min: 0, labels: { align: 'left', x: 5, y: -5 }, showFirstLabel: false, showLastLabel: false
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.y:.2f}kWh</b><br>' ,
                    shared: true, followPointer: true, crosshairs: {
                        color: 'rgba(0,0,0,0.05)',
                        dashStyle: 'dash'
                    },
                },
                credits: false
            },
            series: [
                {
                    name: '白天用电',
                    data: [],
                    color: Highcharts.getOptions().colors[1]
                },
                {
                    name: '晚间用电',
                    data: [],
                    color: Highcharts.getOptions().colors[0]
                }
            ]
        }

        $scope.getDateRange = function () {
            if ($scope.events && $scope.events.length > 0)
                return moment($scope.events[0].date).format('MMM DD, YYYY') + ' - ' + moment($scope.events[$scope.events.length - 1].date).format('MMM DD, YYYY');
            else
                return '---';
        };

        $scope.change=function(){
            var dailyDayAndNight=[];
            for(key in $scope.highchartData){
                if($scope.highchartData.hasOwnProperty(key)){
                    var d=$scope.highchartData[key];
                    var token={day:{sum:0,count:0},night:{sum:0,count:0}};
                    var energy={};
                    d.forEach(function(m){
                        var h=new Date(m[0]).getHours();
                        if(h>=$scope.sliderConfig.minValue&&h<$scope.sliderConfig.maxValue){
                            //Day time
                            token['day']['sum']+=m[1];
                            token['day']['count']++;
                        }else{
                            token['night']['sum']+=m[1];
                            token['night']['count']++;
                        }
                    });
                    energy['day']=token.day.sum/token.day.count*($scope.sliderConfig.maxValue-$scope.sliderConfig.minValue);
                    energy['night']=token.night.sum/token.night.count*(24-($scope.sliderConfig.maxValue-$scope.sliderConfig.minValue));
                    dailyDayAndNight.push([key,energy]);
                }
            }
            var weekdaySplit=_.groupBy(dailyDayAndNight,function(d){
                var date=moment(new Date(d[0]));
                return date.format('E');
            })
            var data1=[];data2=[];
            for(key in weekdaySplit){
                if(weekdaySplit.hasOwnProperty(key)){
                    var d=weekdaySplit[key];
                    var energy={day:0,night:0};
                    d.forEach(function(e){
                        energy['day']+=e[1]['day']||0;
                        energy['night']+=e[1]['night']||0;
                    });
                    data1.push(energy['day']);
                    data2.push(energy['night']);
                }
            }
            $scope.chartOptions1.series[0].data = data1;
            $scope.chartOptions1.series[1].data = data2;

        }

        $scope.load = function(dateStart, dateEnd){
            dateStart = moment(dateStart);
            dateEnd = moment(dateEnd);

            seriesService.load($rootScope.$stateParams.id,dateStart.valueOf(),dateEnd.valueOf(),{interval:"15m"}).then(function(result){

                var data=result[0].points.reverse();
                var groupedData=_.groupBy(data,function(d){
                    var date=new Date(d[0]);
                    var day="0"+date.getDate();
                    var month="0"+(date.getMonth()+1);
                    var year = date.getFullYear();
                    return year + "/" + month.slice(-2) + "/" + day.slice(-2); // ex: 2015/11/11
                });
                $scope.highchartData=groupedData;
                var groupedEnergy=[]
                for (key in groupedData){
                    if(groupedData.hasOwnProperty(key)){
                        var d=groupedData[key];
                        var energy= UtilityService.getAreaUnderCurve(d,{partitions:true});
                        groupedEnergy.push([key,energy]);
                    }
                }
                $scope.weekdayEnergy={};
                groupedData=_.groupBy(groupedEnergy,function(d){
                    var date=moment(new Date(d[0]));
                    return date.format('E');
                })
                for (key in groupedData){
                    if(groupedData.hasOwnProperty(key)){
                        var d=groupedData[key];
                        var energy={h:0,m:0,l:0};
                        d.forEach(function(e){
                            energy['h']+=e[1]['h']||0;
                            energy['m']+=e[1]['m']||0;
                            energy['l']+=e[1]['l']||0;
                        });
                        $scope.weekdayEnergy[key]=energy;
                    }
                }
                $scope.change();

            })
        }

        $scope.applyDateRange = function () {
            var data1, data2;

            //TODO: Use this daterange for API requests
            //TODO: Fine tune daterange picker
            var dateStart = moment($scope.events[0].date);
            var dateEnd = moment($scope.events[$scope.events.length - 1].date);

            // Close Compare configuration Popup
            $scope.isCompareOpen = false;
            $scope.load(dateStart, dateEnd);
        };


        // initial load
        $scope.events = [
            { date: moment().startOf('isoweek'), status: 'full', label: 'start' },
            { date: moment().endOf('isoweek'), status: 'full', label: 'start' }
        ];
        $scope.applyDateRange();

        /**********************************
        *
        * WARNING: BUG: First day of the month always selected: https://github.com/angular-ui/bootstrap/issues/3879
        *
        ***********************************/

        $scope.getDayClass = function (date, mode) {
            if (!$scope.events) return '';

            if (mode === 'day') {
                for (var i = 0; i < $scope.events.length; i++) {
                    if (moment(date).startOf('day').valueOf() === moment($scope.events[i].date).startOf('day').valueOf()) {
                        return $scope.events[i].status;
                    }
                }
            }
            return '';
        };

        $scope.$watch('dateConfig.selected', function () {
            if (!$scope.dateConfig.selected) return;
            $scope.events = [];

            /*
            * week range selection
            */
            var selected = moment($scope.dateConfig.selected).clone().startOf('isoweek');

            if ($scope.start && $scope.end && $scope.start.valueOf() == selected.valueOf() && $scope.end.valueOf() != $scope.start.clone().endOf('isoweek').valueOf()) {
                $scope.start = $scope.end = null;
            }

            if (!$scope.start || $scope.start > selected || moment($scope.end).diff(selected, 'days') == 6) {
                $scope.start = selected;
                $scope.end = selected.clone().endOf('isoweek');
            } else {
                $scope.end = selected.clone().endOf('isoweek');
            }

            if ($scope.start)
                $scope.events.push({ date: $scope.start, status: 'full', label: 'start' })

            if ($scope.end) {
                $scope.events.push({ date: $scope.end, status: 'full', label: 'end' })

                var start = moment($scope.start);
                var end = moment($scope.end);
                var diff = moment($scope.end).diff($scope.start, 'days');
                var nexDate = start.clone();
                for (var i = 1; i <= diff; i++) {
                    nexDate = start.add(1, 'days');
                    $scope.events.push({ date: nexDate.clone(), status: 'partially' })
                }

            }
            $scope.dateConfig.selected = null;
        });

        $scope.onCancelStrategy = function () {
            $rootScope.$state.go('root.home.unit.recommendations.strategies');
        }

        $scope.$on('$destroy', function () {
            cancelLoad.resolve();
        });

    }])
},{}],25:[function(require,module,exports){
angular.module('app.controllers.recommendations.strategies.strategy4', [])

    .controller('strategy4Ctrl', ['$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', '$q', '$timeout', '$window', 'seriesService', 'UtilityService', function ($scope, $rootScope, FormService, uiGridConstants, $http, $q, $timeout, $window, seriesService, UtilityService) {

        var cancelLoad = $q.defer();

        // dateConfig altered by "angular.daterange.js" at runtime
        $scope.dateConfig = { selected: null, maxDate: moment() };

        var pointStart = moment().subtract(1, 'week').valueOf();
        var pointInterval = 3600 * 1000;

        $scope.time = 0;



        // $scope.sliderConfig = {
        //     floor: 0, ceil: 3, onChange: function () { $scope.change(); }, showTicks: true, showTicksValues: true,
        //     translate: function(value) {
        //         switch (value) {
        //             case 0: return '1m';
        //             case 1: return '3m';
        //             case 2: return '6m';
        //             case 3: return '12m';
        //         }
        //     }
        // }


        $scope.slider1Config = { id: 1, value: 0, floor: 0, ceil: 30, onChange: function () {onSliderChange(this);}, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } }
        $scope.slider2Config = { id: 2, value: 0, floor: 0, ceil: 30, onChange: function () { onSliderChange(this); }, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } }
        $scope.slider3Config = { id: 3, value: 0, floor: 0, ceil: 30, onChange: function () { onSliderChange(this); }, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } }
        $scope.slider4Config = { id: 4, value: 0, floor: 0, ceil: 30, onChange: function () { onSliderChange(this); }, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } }
        $scope.slider5Config = { id: 5, value: 0, floor: 0, ceil: 30, onChange: function () { onSliderChange(this); }, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } }
        $scope.slider6Config = { id: 6, value: 0, floor: 0, ceil: 30, onChange: function () { onSliderChange(this); }, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } }


        var onSliderChange = function(slider){
            // $scope.$apply(function(){
            var data = _.map($scope.chartOptions1.series[slider.id].data, function(d) {
                var lastPerc = $scope.chartOptions1.series[slider.id].lastValue; // last selected percentage

                if(lastPerc)
                    d[1] = d[1] * 100 / (100 - lastPerc); // restore original value
                d[1]=d[1] - (d[1]* slider.value / 100); // substruct original value with selected percentage
                return d;
            });
            $scope.stats[slider.id].modifiedEnergy=$scope.stats[slider.id].originalEnergy*(1-slider.value/100);
            $scope.chartOptions1.series[slider.id].data = data;
            $scope.chartOptions1.series[slider.id].lastValue = slider.value;
            // });
        }


        $scope.load = function () {
            $timeout(function(){

                $scope.dateConfig.setRange(moment().subtract(1, 'week'),
                    moment());

                $scope.applyDateRange();

            })
        }
        $scope.load();


        $scope.chartOptions1 = {
            options: {
                chart: {
                    alignTicks: true, spacingBottom: 15, spacingTop: 0, spacingLeft: 0, spacingRight: 0,
                    type: 'area'
                },
                title: null,
                legend: {
                    enabled: true,
                    layout: 'horizontal',
                },
                tooltip: {},
                plotOptions: {
                    area: {
                        stacking: 'normal',
                        dataLabels: {
                            enabled: false,
                            format: '{point.y:.1f}', // one decimal
                            color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white',
                            style: {
                                textShadow: '0 0 3px black'
                            }
                        },
                        tooltip: {
                            format: '{point.y:.1f}', // one decimal
                            valueDecimals: 2
                        },
                        marker: { enabled: false }
                    },
                    series: {
                            pointStart: pointStart,
                            pointInterval: pointInterval
                    }
                },
                xAxis: {
                    min: pointStart,
                    tickWidth: 0,
                    startOnTick: false, endOnTick: false, type: 'datetime',
                    tickInterval: 60 * 60 * 1000 * 2,
                    labels: {
                        rotation: 0,
                        align: 'center'
                    }
                },
                yAxis: {
                    title: { text: '' }, gridLineWidth: 1, minorGridLineWidth: 0, min: 0, labels: { align: 'left', x: 5, y: -5 }, showFirstLabel: false, showLastLabel: false
                },
                tooltip: {
                    shared: true, followPointer: true, crosshairs: {
                        color: 'rgba(0,0,0,0.05)',
                        dashStyle: 'dash'
                    },
                },
                credits: false
            },
            series: [
                // {
                //     name: "照明用电",
                //     data: [65.16, 77.00, 67.46, 47.12, 19.29, 12.42, 13.22],
                //     zIndex: 6,
                //     fillOpacity: 0.5,
                //     lineWidth: 1
                // }, {
                //     name: "设备与插座",
                //     data: [60.16, 72.00, 67.46, 47.12, 19.29, 12.42, 13.22],
                //     zIndex: 5,
                //     fillOpacity: 0.5,
                //     lineWidth: 1
                // }, {
                //     name: "取暖用电",
                //     data: [55.16, 68.00, 67.46, 47.12, 19.29, 12.42, 13.22],
                //     zIndex: 4,
                //     fillOpacity: 0.5,
                //     lineWidth: 1
                // }, {
                //     name: "动力用电",
                //     data: [30.16, 40.00, 50.46, 40.12, 35.29, 25.42, 30.22],
                //     zIndex: 3,
                //     fillOpacity: 0.5,
                //     lineWidth: 1
                // }, {
                //     name: "空调制冷",
                //     data: [40.16, 50.00, 60.46, 50.12, 46.29, 30.42, 40.22],
                //     zIndex: 2,
                //     fillOpacity: 0.5,
                //     lineWidth: 1
                // }, {
                //     name: "特殊用电",
                //     data: [50.16, 60.00, 70.46, 60.12, 57.29, 35.42, 50.22],
                //     zIndex: 1,
                //     fillOpacity: 0.5,
                //     lineWidth: 1
                // }
            ]
        }

        var colors=['purple','blue','green','yellow','orange','red'];
        $scope.displaySeries=function(startTime,endTime){
                    var interval=60*24; // one month
                    pointInterval="auto";

                    $q.all([seriesService.load($rootScope.$stateParams.id,startTime,endTime,{interval:pointInterval}),
                        seriesService.load($rootScope.$stateParams.id,startTime,endTime,{interval:pointInterval,disagg:"all"})])
                    .then(function(result){
                        var series=result[1];
                        $scope.chartOptions1.series=[];
                        $scope.sliders=[];
                        $scope.stats=[];
                        for(var i=0;i<series.length;i++){
                            var sdata=series[i];
                            var data=(sdata.points||[]).reverse();
                            $scope.chartOptions1.series[i]={
                                name: sdata.usage||"",
                                data: data,
                                fillOpacity: 0.5,
                                color:colors[i%colors.length],
                                lineWidth: 1
                            }
                            var energy=UtilityService.getAreaUnderCurve(data);
                            $scope.stats.push({
                                id:i,
                                name:sdata.usage||"",
                                originalEnergy:energy,
                                modifiedEnergy:energy
                            })
                            $scope.sliders[i]={id: i, value: 0, name:sdata.usage,color:colors[i%colors.length],floor: 0, ceil: 30, step: 5, onChange: function () { onSliderChange(this); }, showTicks: true, showTicksValues: true, translate: function(value) { return value + ''; } };
                        }


                        $timeout(function(){
                            angular.element($window).triggerHandler('resize');
                        });

                    });
        }

        $scope.applyDateRange = function () {
            var data1, data2;

            //TODO: Use this daterange for API requests
            //TODO: Fine tune daterange picker
            var dateStart = $scope.dateConfig.getStart();
            var dateEnd = $scope.dateConfig.getEnd();

            var pointStart = dateStart.clone().valueOf();
            var pointEnd = dateEnd.clone().valueOf();

            // Close Compare configuration Popup
            $scope.isCompareOpen = false;


            $scope.chartOptions1.options.xAxis.min = pointStart;
            $scope.chartOptions1.options.xAxis.max = pointEnd;

            // start of day
            $scope.chartOptions1.options.plotOptions.series.pointStart = pointStart;
            $scope.chartOptions1.options.plotOptions.series.pointEnd = pointEnd;

            // tick interval
            $scope.chartOptions1.options.xAxis.tickInterval = 3600 * 1000 * 24;
            // point interval
            $scope.chartOptions1.options.plotOptions.series.pointInterval = 3600 * 1000;

            $scope.displaySeries(pointStart, pointEnd);
        }

        $scope.setRange = function(mode){
            switch(mode){
                case "past week":

                    $timeout(function(){
                        $scope.dateConfig.setRange(moment().subtract(1, 'week'),
                            moment());
                    });

                    break;
                case "last month":

                    $timeout(function(){
                        $scope.dateConfig.setRange(moment().subtract(1, 'month').startOf('month'),
                            moment().subtract(1, 'month').endOf('month'));
                    });

                    break;
                case "this month":

                    $timeout(function(){
                        $scope.dateConfig.setRange(moment().startOf('month'),
                            moment());
                    });

                    break;
                case "this quarter":

                    $timeout(function(){
                        $scope.dateConfig.setRange(moment().startOf('quarter'),
                            moment());
                    });

                    break;
                case "this year":

                    $timeout(function(){
                        $scope.dateConfig.setRange(moment().startOf('year'),
                            moment());
                    });

                    break;
            }
        }



        $timeout(function () {
            angular.element($window).triggerHandler('resize');
        });

        $scope.onCancelStrategy = function () {
            $rootScope.$state.go('root.home.unit.recommendations.strategies');
        }

        $scope.$on('$destroy', function () {
            cancelLoad.resolve();
        });

    }])
},{}],26:[function(require,module,exports){
angular.module('app.controllers.recommendations.strategies.strategy5', [])

    .controller('strategy5Ctrl', ['$scope', '$rootScope', 'FormService', 'uiGridConstants', '$http', '$q', '$timeout', '$window', 'seriesService', 'UtilityService', function ($scope, $rootScope, FormService, uiGridConstants, $http, $q, $timeout, $window, seriesService, UtilityService) {

        var cancelLoad = $q.defer();

        $scope.compareWith = 1; // 1 month

        // Start with utc offset 8 hours to match Highcharts global configuration
        $scope.pointStart = moment().utc().utcOffset(-480).startOf('day').valueOf();
        $scope.pointEnd = moment().utc().utcOffset(-480).startOf('day').valueOf();
        var pointInterval = 3600 * 1000;

        // dateConfig altered by "angular.daterange.js" at runtime
        $scope.dateConfig = { selected: null, maxDate: moment() };


        $scope.load = function () {
            $timeout(function(){
                $scope.dateConfig.setRange(moment().subtract(1, 'week'), moment());
                $scope.applyDateRange();
            })
        }
        $scope.load();

        // DEMO: TODO: Ensure datasource and transformation valid
        $scope.displaySeries=function(startTime,endTime){
            var interval=60*60*1000*24; // one day
            var pointInterval="60m";

            // if(mode=="week"){
            //     interval*=7;
            // }else if(mode=="month"){
            //     interval*=30;
            //     pointInterval="60m";
            // }
            $q.all([seriesService.load($rootScope.$stateParams.id,startTime,endTime,{interval:pointInterval}), // This is building series.
                    seriesService.load($rootScope.$stateParams.id,startTime,endTime,{interval:pointInterval,predict:true}), // This is predicted building
                    seriesService.load($rootScope.$stateParams.id,startTime,endTime,{interval:pointInterval,disagg:"all"}), // This is the aggregated series;
                    seriesService.load($rootScope.$stateParams.id,startTime,endTime,{interval:pointInterval,predict:true,disagg:"all"}) // This is aggregated predicted series
                        ]).then(function(result){
                var series1=((result[0][0]||{}).points||[]).reverse();
                var series2=((result[1][0]||{}).points||[]).reverse();
                var original=UtilityService.getAreaUnderCurve(series1);
                var predict=UtilityService.getAreaUnderCurve(series2);
                // calculate the stats of each
                $scope.stats=[];
                var matching={};
                result[2].forEach(function(s){
                        var e=UtilityService.getAreaUnderCurve(s.points.reverse());
                        matching[s.usage]={name:s.usage,original:e};
                })
                result[3].forEach(function(s){
                        var e=UtilityService.getAreaUnderCurve(s.points.reverse());
                        if(!matching[s.usage]) matching[s.usage]={name:s.usage};
                        matching[s.usage]['predict']=e;
                })
                var chart2Data={categories:[],data1:[],data2:[]};
                for (var key in matching){
                    $scope.stats.push(matching[key]);
                    chart2Data.categories.push(matching[key]['name']);
                    chart2Data.data1.push(matching[key]['original']);
                    chart2Data.data2.push(matching[key]['predict']);
                }

                $scope.chartOptions1.series[0].data = series1;
                $scope.chartOptions1.series[1].data = series2;
                $scope.chartOptions3.series[0].data = [
                    { y: original, color: Highcharts.getOptions().colors[0] },
                    { y: predict, color: Highcharts.getOptions().colors[1] },
                ];
                $scope.chartOptions2.options.xAxis.categories=chart2Data.categories;
                $scope.chartOptions2.series[0].data=chart2Data.data1;
                $scope.chartOptions2.series[1].data=chart2Data.data2;

                //$scope.range1.stats=UtilityService.getAreaUnderCurve(series1,{partitions:true});
                //var p=UtilityService.isSummer(time) ? $scope.price['s'] : $scope.price['ns'];

                // $scope.range1.charge={'h':$scope.range1.stats['h']*p['h'],'m':$scope.range1.stats['m']*p['m'],'l':$scope.range1.stats['l']*p['l']};
                // var series2=result[1][0]||{}
                // series2=(series2.points||[]).reverse();
                // var time=series2[0][0];
                // $scope.chartOptions1.series[1].data =_.map(series2,function(d){
                //     return d[1];
                // })
                //$scope.range2.stats=UtilityService.getAreaUnderCurve(series2,{partitions:true});
                //var p=UtilityService.isSummer(time) ? $scope.price['s'] : $scope.price['ns'];

                //$scope.range2.charge={'h':$scope.range2.stats['h']*p['h'],'m':$scope.range2.stats['m']*p['m'],'l':$scope.range2.stats['l']*p['l']};
            });
        }

        $scope.applyDateRange = function () {
            var data1, data2;

            var dateStart = $scope.dateConfig.getStart();
            var dateEnd = $scope.dateConfig.getEnd();

            $scope.pointStart = dateStart.clone().valueOf();
            $scope.pointEnd = dateEnd.clone().valueOf();

            // Close Compare configuration Popup
            $scope.isCompareOpen = false;

            $scope.chartOptions1.options.xAxis.min = $scope.pointStart;
            $scope.chartOptions1.options.xAxis.max = $scope.pointEnd;

            // start of day
            $scope.chartOptions1.options.plotOptions.series.pointStart = $scope.pointStart;
            $scope.chartOptions1.options.plotOptions.series.pointEnd = $scope.pointEnd;

            // tick interval
            $scope.chartOptions1.options.xAxis.tickInterval = 3600 * 1000 * 24;

            // point interval
            $scope.chartOptions1.options.plotOptions.series.pointInterval = 3600 * 1000;

            $scope.displaySeries($scope.pointStart, $scope.pointEnd);
        }

        $scope.onCompare = function(){
            switch($scope.compareWith)
            {
                case 1:
                    break;
                case 3:
                    break;
                case 6:
                    break;
                case 12:
                    break;
            }
        }

        $scope.chartOptions1 = {
            options: {
                chart: { type: 'areaspline', alignTicks: true, spacingBottom: 15, spacingTop: 0, spacingLeft: 0, spacingRight: 0 },
                title: null,
                legend: {
                    enabled: true,
                    layout: 'horizontal',
                },
                plotOptions: {
                    series: { pointStart: $scope.pointStart, pointEnd: $scope.pointEnd, pointInterval: pointInterval },
                    areaspline: {
                        fillOpacity: 0.2, states: { hover: { enabled: false } }
                    }
                },
                xAxis: {
                    type: 'datetime',
                    min: $scope.pointStart, max: $scope.pointEnd,
                    showFirstLabel: true, showLastLabel: false, startOnTick: false, endOnTick: false, tickWidth: 0, tickInterval: 60 * 60 * 1000 * 2,
                    labels: {
                        rotation: 0,
                        y: -5,
                        x: 5,
                        align: 'left',
                        formatter: function () {
                            return Highcharts.dateFormat('%e %b', this.value);
                        }
                    }
                },
                yAxis: {
                    title: { text: '' }, gridLineWidth: 1, minorGridLineWidth: 0, min: 0, labels: { align: 'left', x: 5, y: -5 }, showFirstLabel: false, showLastLabel: false
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.y:.2f}kW</b><br>' ,
                    shared: true, followPointer: true, crosshairs: {
                        color: 'green',
                        dashStyle: 'dash'
                    },
                },
                credits: false
            },
            series: [
                {
                    name: 'before',
                    data: [],
                    dashStyle: 'dash',
                    lineWidth: 0.5
                },
                {
                    name: 'after',
                    data: [],
                    lineWidth: 1
                }
            ]
        }


        $scope.chartOptions2 = {
            options: {
                chart: { polar: true, type: 'area' },
                title: null,
                pane: { size: '80%' },
                xAxis: { categories: ["照明用电", "设备与插座", "取暖用电", "动力用电", "空调制冷", "特殊用电"], tickmarkPlacement: 'on', lineWidth: 0 },
                yAxis: { gridLineInterpolation: 'polygon', minorGridLineWidth: 0, lineWidth: 0, min: 0 },
                tooltip: { shared: true, pointFormat: '<span style="color:{series.color}">{series.name}: <b>{point.y:,.0f} kWh</b><br/>' },
                plotOptions: { area: { marker: { enabled: false } } },
                legend: { enabled: false }
            },
            series: [
                {
                    name: 'Before',
                    data: [20, 15, 17, 13, 18, 22],
                    dashStyle: 'longdash',
                    pointPlacement: 'on',
                    lineWidth: 1.5,
                    fillOpacity: 0.2,
                    lineWidth: 0.5
                }, {
                    name: 'After',
                    data: [19, 13, 14, 12, 14, 15],
                    pointPlacement: 'on',
                    fillOpacity: 0.2,
                    lineWidth: 1
                }
            ]
        }

        $scope.chartOptions3 = {
            options: {
                chart: {
                    type: 'bar', colorByPoint: true
                },
                title: null,
                legend: {
                    enabled: false,
                    layout: 'horizontal',
                },
                plotOptions: {
                    bar: { states: { hover: { enabled: false } } }
                },
                xAxis: {
                    categories: ['Before', 'After'],
                },
                yAxis: {
                    min: 0, title: null, labels: { overflow: 'justify' }
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.y:.2f}kW</b><br>' ,
                    shared: true, followPointer: true
                },
                credits: false
            },
            series: [
                {
                    data: []
                }
            ]
        }

        $timeout(function () {
            angular.element($window).triggerHandler('resize');
        });

        $scope.onCancelStrategy = function () {
            $rootScope.$state.go('root.home.unit.recommendations.strategies');
        }

        $scope.$on('$destroy', function () {
            cancelLoad.resolve();
        });

    }])

},{}],27:[function(require,module,exports){
angular.module('app.controllers.recommendations.summary.details', [])

    .controller('recommendationsSummaryDetailsCtrl', ['$scope', '$rootScope', 'RecommendationFactory', 'uiGridConstants', '$timeout', '$ionicPopup', '$ionicPopover', function($scope, $rootScope, RecommendationFactory, uiGridConstants, $timeout, $ionicPopup, $ionicPopover){
        

        /********************************************************************
         *
         *
         *  Recommendation status
         *
         *
        *********************************************************************/

        $scope.getStatusName = function(id){
            switch(id)
            {
                case 1: return '效果核实';
                case 2: return '实施中';
                case 3: return '开始审批';
                case 4: return '未读';
                case 5: return '已完成';
            }
            return '---';
        }

        $scope.onSetStatus = function(){

                $scope.status = {
                    comment: '',
                    newStatus: $scope.selectedRow.status
                }

                // TODO: Translate popup text
                $scope.statusPopup = $ionicPopup.show({
                    template:   
                                '<button ng-click="popover.show($event)" ng-bind="getStatusName(status.newStatus)"></button>' +
                                '<textarea ng-model="status.comment" style="min-height: 150px; border: solid 1px #eee; padding: 10px;" placeholder="Status change reason..."></textarea>',
                    title:      'Change status',
                    // subTitle: 'Sub time',
                    scope: $scope,
                    buttons: [
                        { text: 'Cancel', onTap: function(e) { return; } },
                        {
                            text: '<b>Save</b>',
                            type: 'button-positive',
                            onTap: function(e) {
                                return $scope.status;
                            }
                        }
                    ]
                });

                // Once closed
                $scope.statusPopup.then(function(res) {
                    $scope.setStatus(res.newStatus, res.comment);
                });
        }

        
        //Saving status
        $scope.setStatus = function(status, comment) {
            RecommendationFactory.update({ status: status, id: $rootScope.$stateParams.rid, comment: comment }).then(function (data) {
                $scope.statusPopup.close();
                $scope.refreshHistory($rootScope.$stateParams.rid);
                $scope.selectedRow.status = status; 
            });
        };

        var statusPopoverTemplate = '<ion-popover-view>' +
                                    '   <ion-content> ' +
                                    '       <button class="cyellow" ng-click="status.newStatus = 4; popover.hide()" ng-class="{pressed: selectedRow.status == 4}">未读</button>' +
                                    '       <button class="corange" ng-click="status.newStatus = 3; popover.hide()" ng-class="{pressed: selectedRow.status == 3}">开始审批</button>' +
                                    '       <button class="cgreen" ng-click="status.newStatus = 2; popover.hide()" ng-class="{pressed: selectedRow.status == 2}">实施中</button>' +
                                    '       <button class="cred" ng-click="status.newStatus = 1; popover.hide()" ng-class="{pressed: selectedRow.status == 1}">效果核实</button>' +
                                    '       <button class="cblue" ng-click="status.newStatus = 5; popover.hide()" ng-class="{pressed: selectedRow.status == 5}">已完成</button>' +
                                    '   </ion-content>'+
                                    '</ion-popover-view>';
        $scope.popover = $ionicPopover.fromTemplate(statusPopoverTemplate, { scope: $scope });



        /********************************************************************
         *
         *
         *  Initial load
         *
         *
        *********************************************************************/
        
        $scope.chartOptions1 = { options: { title: null } }

        $scope.load = function(){

            RecommendationFactory.getByBuilding($rootScope.$stateParams.id).then(function(result) {
                var recommendations = _.map(result, function(d) {
                    d.saving_potentialText = "¥" + d.saving_potential + " /月";
                    switch (d.complexity) {
                        case 1:
                            d.complexityText = "低";
                            break;
                        case 2:
                            d.complexityText = "中";
                            break;
                        case 3:
                            d.complexityText = "高";
                            break;
                    }
                    switch (d.paybacktime) {
                        case 1:
                            d.paybacktimeText = '短期';
                            break;
                        case 2:
                            d.paybacktimeText = '中期';
                            break;
                        case 3:
                            d.paybacktimeText = '中长期';
                            break;
                    }
                    return d;
                });

                $scope.selectedRow = _.find(recommendations, function(item) {
                    return item.id == $rootScope.$stateParams.rid;
                })


                //$scope.gridDetailsOptions.data = [$scope.selectedRow];
                // $scope.chartGaugeOptions0.series[0].data[0] = [$scope.selectedRow.energy_saved];
                // $scope.chartGaugeOptions1.series[0].data[0] = $scope.selectedRow.paybacktime;
                // $scope.chartGaugeOptions2.series[0].data[0] = $scope.selectedRow.complexity;

                $scope.money = $scope.selectedRow.saving_potential * 12;
                $scope.co2 = $scope.selectedRow.energy_saved * 12 * 0.527;

                $scope.description = $scope.selectedRow.description;
                //$scope.comment = row.entity.comment;

                //Load comments
                $scope.refreshHistory($scope.selectedRow.id);

                if($scope.selectedRow.highchart_plot && $scope.selectedRow.highchart_plot.length > 0)
                    $scope.chartOptions1 = $scope.$eval($scope.selectedRow.highchart_plot);

            });

        }


        $scope.load();



        /********************************************************************
         *
         *
         *  History log table
         *
         *
        *********************************************************************/


        $scope.statusLogGrid={
            enableFiltering: true,
            enableRowSelection: true,
            enablePaging: false,
            // enablePaginationControls: true,
            enableRowHeaderSelection: false,
            // paginationTemplate: paginationTemplate,
            multiSelect: false,
            enableSelectAll: false,
            // paginationPageSize: 3,
            enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
            // enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
            columnDefs:[
                { field: 'date_of_change', displayName: '修改日期', width: "125", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', type: 'date', enableColumnMenu: false, sort: { direction: uiGridConstants.DESC } },
                { field: 'old_status', displayName: '前状态', width: "*", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false, visible: false },
                { field: 'new_status', displayName: '修改后状态', width: "*", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false },
                { field: 'comment', displayName: '进展描述', width: "*", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false, visible: true },
            ],
            data:[]
        }

        $scope.statusLogGrid.onRegisterApi = function (gridApi) {
            $scope.gridApi2 = gridApi;
            gridApi.selection.on.rowSelectionChanged($scope, function(row) {

                // Fix Status columns width to stretch Comment column
               // gridApi.grid.getColumn('old_status').width = '150';
                gridApi.grid.getColumn('new_status').width = '150';

                // Show Comment column
                $scope.statusLogGrid.columnDefs[2].visible = true;

                // Stretch Comments panel
                $scope.isLogRowSelected = true;

                // Apply changes to grid
                gridApi.grid.queueGridRefresh();

                // Trigger window resize event
                $rootScope.resize();


                $scope.selectedLogRow = row;
                console.log('$scope.selectedLogRow', $scope.selectedLogRow);

                $scope.statusPopup = $ionicPopup.show({
                    template:   
                                '<button class="flex flex-row jcc">'+
                                '   <span class="flex-resize tal" ng-bind="selectedLogRow.entity.old_status"></span>' +
                                '   <span class="flex-noresize svg-arrow-right svg-25 svg-blue"></span>' +
                                '   <span class="flex-resize tar" ng-bind="selectedLogRow.entity.new_status"></span>' +
                                '</button>' +
                                '<div class="b1eee" ng-bind="selectedLogRow.entity.comment" style="background: #fff; min-height: 150px; max-width: 100%; padding: 10px;"></div>',
                    title:      'History log',
                    // subTitle: 'Sub time',
                    scope: $scope,
                    buttons: [
                        { text: 'close', onTap: function(e) { return; } },
                    ]
                });



            });
        };


        $scope.hideLog = function() {
            // Stratch Status columns width
            //$scope.gridApi2.grid.getColumn('old_status').width = '*';
            $scope.gridApi2.grid.getColumn('new_status').width = '*';

            // Hide Comment column
            //$scope.statusLogGrid.columnDefs[2].visible = false;

            // Restore Comments panel
            $scope.isLogRowSelected = false;

            // Apply changes to grid
            $scope.gridApi2.grid.queueGridRefresh();

            // Trigger window resize event
            $rootScope.resize();
        }

        $scope.refreshHistory = function(recommendationID){
            return RecommendationFactory.getStatusLog(recommendationID).then(function (result) {

                // //TODO: Remove this once "commment" available
                // result.objects = _.map(result.objects, function (d) {
                //     d.comment = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
                //     return d;
                // });

                $scope.statusLogGrid.data = result.objects;
                $scope.statusLogGrid.minRowsToShow = result.objects.length;

                $rootScope.resize();
            });
        }


        $scope.getNumber = function(num) {
            return new Array(num);
        }


        /********************************************************************
         *
         *
         *  Sample recommendation chart
         *
         *
        *********************************************************************/

        // $scope.chartOptions1 = {
        //     options: {
        //         chart: {
        //             type: 'column', panning: true, margin: [55, 0, 0, 0] 
        //         },
        //         title: null,
        //         xAxis: {
        //             categories: [
        //                 'Jan',
        //                 'Feb',
        //                 'Mar',
        //                 'Apr',
        //                 'May',
        //                 'Jun',
        //                 'Jul',
        //                 'Aug',
        //                 'Sep',
        //                 'Oct',
        //                 'Nov',
        //                 'Dec'
        //             ],
        //             crosshair: true,
        //             opposite: true,
        //             gridLineWidth: 0
        //         },
        //         yAxis: {
        //             lineWidth: 0,
        //             lineColor: '#fff',
        //             gridLineWidth: 0,
        //             minorGridLineWidth: 0, 
        //             min: 0,
        //             labels: { align: 'left', x: 10, y: -5 },
        //             title: null,//{ text: '能源效率' },
        //             tickInterval: 25, // TODO: WARNING: HARDCODED use principle commented above once live
        //             max: 250,
        //             showLastLabel: false
        //         },
        //         tooltip: {
        //             headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
        //             pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' +
        //                 '<td style="padding:0"><b>{point.y:.1f} mm</b></td></tr>',
        //             footerFormat: '</table>',
        //             shared: true,
        //             useHTML: true
        //         },
        //         plotOptions: {
        //             column: {
        //                 pointPadding: 0.2,
        //                 borderWidth: 0
        //             }
        //         }
        //     },
        //     series: [
        //         {
        //             name: '当前楼宇',
        //             showInLegend: false,
        //             data: [49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]

        //         }, {
        //             name: '行业平均',
        //             showInLegend: false,
        //             data: [83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3]

        //         }, {
        //             name: '优质楼宇',
        //             showInLegend: false,
        //             data: [48.9, 38.8, 39.3, 41.4, 47.0, 48.3, 59.0, 59.6, 52.4, 65.2, 59.3, 51.2]

        //         }
        //     ]
        // };

        $timeout(function(){
            $rootScope.resize();
        });
}])








        // TEMP


        /********************************************************************
         *
         *
         *  Indicators
         *
         *
        *********************************************************************/


        // // middle big gauge
        // $scope.chartGaugeOptions0 = {
        //     options: {
        //         chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15, spacingLeft: 0, spacingRight: 0 },
        //         title: null,
        //         exporting: { enabled: false },
        //         pane: { center: ['50%', '50%'], size: '100%', startAngle: 115, endAngle: -115, background: null },
        //         plotOptions: {
        //             gauge: {
        //                 dataLabels: { enabled: true, style: { 'fontSize': '20px' }, y: 20, borderWidth: 0 },
        //                 dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
        //                 pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
        //             }
        //         },
        //         yAxis: {
        //             pane: 0,
        //             min: 0,
        //             max: 3000,
        //             lineColor: null,
        //             reversed: true,
        //             minorTickInterval: 1,
        //             tickPixelInterval: 10,
        //             minorTickPosition: 'outside',
        //             tickPosition: 'outside',
        //             tickWidth: 1,
        //             tickPositions: [0, 1000, 2000, 3000],
        //             labels: { step: 1, distance: 15, rotation: 'auto' },
        //             title: { text: 'kWh', align: 'middle', style: { 'fontSize': '12px' }, y: 7 }, // Y Title
        //             plotBands: [
        //                 { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1000, color: '#55BF3B' }, // green
        //                 { innerRadius: '90%', outerRadius: '100%', from: 1000, to: 2000, color: '#ffcc00' }, // yellow
        //                 { innerRadius: '90%', outerRadius: '100%', from: 2000, to: 3000, color: '#DF5353' } // red
        //             ],
        //             dataLabels: {
        //                  formatter: function () {
        //                  var kmh = this.y,
        //                  mph = Math.round(kmh * 0.621);
        //             }
        //         },
        //         },
        //         credits: false
        //     },
        //     series: [
        //         {
        //             name: 'kWh',
        //             data: [0]
        //         }
        //     ],

        // };

        // // left small gauge
        // $scope.chartGaugeOptions1 = {
        //     options: {
        //         chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15 },
        //         title: null,
        //         exporting: { enabled: false },
        //         pane: { center: ['50%', '60%'], size: '75%', startAngle: 115, endAngle: -115, background: null },
        //         plotOptions: {
        //             gauge: {
        //                 dataLabels: {
        //                     borderWidth: 0,
        //                     enabled: true,
        //                      formatter: function () {
        //                         switch(this.y) {
        //                             case 1:
        //                                 return 'EASY';
        //                             case 2:
        //                                 return 'NORMAL';
        //                             case 3:
        //                                 return 'HARD';
        //                         }
        //                     }
        //                 },
        //                 dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
        //                 pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
        //             }
        //         },
        //         yAxis: {
        //             pane: 0,
        //             min: 0,
        //             max: 3,
        //             lineColor: null,
        //             reversed: true,
        //             minorTickInterval: 1,
        //             tickPixelInterval: 10,
        //             minorTickPosition: 'outside',
        //             tickPosition: 'outside',
        //             tickWidth: 1,
        //             tickPositions: [0, 1, 2, 3],
        //             labels: { step: 1, distance: 15, rotation: 'auto' },
        //             title: { text: '回收周期', align: 'left', align: 'middle', style: { 'fontSize': '12px' }, y: 7, style:  { 'color': '#aaa' } }, // Y Title
        //             plotBands: [
        //                 { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1, color: '#55BF3B' }, // green
        //                 { innerRadius: '90%', outerRadius: '100%', from: 1, to: 2, color: '#ffcc00' }, // yellow
        //                 { innerRadius: '90%', outerRadius: '100%', from: 2, to: 3, color: '#DF5353' } // red
        //             ]
        //         },
        //         credits: false
        //     },
        //     series: [
        //         {
        //             name: '回收周期',
        //             data: [0]
        //         }
        //     ],

        // };

        // // right small gauge
        // $scope.chartGaugeOptions2 = {
        //     options: {
        //         chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15 },
        //         title: null,
        //         exporting: { enabled: false },
        //         pane: { center: ['50%', '60%'], size: '75%', startAngle: 115, endAngle: -115, background: null },
        //         plotOptions: {
        //             gauge: {
        //                 dataLabels: {
        //                     borderWidth: 0,
        //                     enabled: true,
        //                     formatter: function () {
        //                         switch(this.y) {
        //                             case 1:
        //                                 return 'EASY';
        //                             case 2:
        //                                 return 'NORMAL';
        //                             case 3:
        //                                 return 'HARD';
        //                         }
        //                     }
        //                 },
        //                 dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
        //                 pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
        //             }
        //         },
        //         yAxis: {
        //             pane: 0,
        //             min: 0,
        //             max: 3,
        //             lineColor: null,
        //             reversed: true,
        //             minorTickInterval: 1,
        //             tickPixelInterval: 10,
        //             minorTickPosition: 'outside',
        //             tickPosition: 'outside',
        //             tickWidth: 1,
        //             tickPositions: [0, 1, 2, 3],
        //             labels: { step: 1, distance: 15, rotation: 'auto' },
        //             title: { text: '回收周期', align: 'left', align: 'middle', style: { 'fontSize': '12px' }, y: 7, style:  { 'color': '#aaa' } }, // Y Title
        //             plotBands: [
        //                 { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1, color: '#55BF3B' }, // green
        //                 { innerRadius: '90%', outerRadius: '100%', from: 1, to: 2, color: '#ffcc00' }, // yellow
        //                 { innerRadius: '90%', outerRadius: '100%', from: 2, to: 3, color: '#DF5353' } // red
        //             ]
        //         },
        //         credits: false
        //     },
        //     series: [
        //         {
        //             name: '回收周期',
        //             data: [0]
        //         }
        //     ],

        // };
},{}],28:[function(require,module,exports){
angular.module('app.controllers.recommendations.summary', [])

    .controller('recommendationsSummaryCtrl', ['$scope', '$rootScope', 'uiGridConstants', 'RecommendationFactory', '$timeout', '$injector', '$timeout', '$window', 'html2pdf',
        function ($scope, $rootScope, uiGridConstants, RecommendationFactory, $timeout, $injector, $timeout, $window, html2pdf) {

            var chartCapsuleBarOptions =  { max: 3, capsules: 10, value: 0, title: '难度系数', titlePosition: 'right' };

            $scope.progressMax1 = 3000;
            $scope.progressMax2 = 3;
            $scope.progressMax3 = 3;
            $scope.progressCurrent1 = 0;
            $scope.progressCurrent2 = 0;
            $scope.progressCurrent3 = 0;
            // $scope.description = '安装冷机群控系统 器检测温度分层线位置，以调整，供同冷时主需机在开温启度台梯数度及垂水直泵等频距率离。上布置温度传 其水次机组蓄与冷，冰均用蓄可水冷直系池接统往用相于比可水以，蓄水和冷蓄消，冷防因系水而统池即一等使般共在投用蓄资，冷因较阶而低段可，也首以可先节以因省保为水持一池较般结高用构的于部制空分冷调及效的占率冷地； 道的单即可独。投资。如下图，按照酒店现有冷机配置，只需新增左侧蓄冷水池和相应';
            $scope.description = '';

            $scope.export = function(){
                html2pdf.export($("#export-container"), 'Recommendations.Summary');
            }

            $scope.getStatus = function(row, col) {
                var status = row.entity.status + "";
                switch (status) {
                    case "1":
                        return "效果核实";
                    case "2":
                        return "实施中";
                    case "3":
                        return "开始审批";
                    case "4":
                        return "未读";
                    case "5":
                        return "已完成";
                    case "6":
                        return "不可用";
                }
                return '---';

            };


            // Alert type color 
            $scope.getCategoryColor = function(categ){
                switch(categ){
                    case 1: return 'rgb(255, 204, 0)';
                    case 2: return 'rgb(255, 204, 0)';
                    case 3: return 'rgb(255, 204, 0)';
                    case 4: return 'rgb(1, 185, 195)';
                    case 5: return 'rgb(1, 185, 195)';
                    default: return '#dfdfdf';
                }
            }

            // var statusCellTemplate =
            //     '<div class="ui-grid-cell-contents">' +
            //         '   <div uib-dropdown dropdown-append-to-body>' +
            //         '       <a class="dropdown-toggle" uib-dropdown-toggle role="menu" aria-labelledby="single-button" ng-click="grid.appScope.onStatusClick($event)">' +
            //         '           <span ng-class="{cred: row.entity.status == 1, cgreen: row.entity.status == 2, corange: row.entity.status == 3, cyellow: row.entity.status == 4}" ng-bind="grid.appScope.getStatus(row, col)">---</span> <i class="icon-down-open fs8" style="color: #333"></i>' +
            //         '       </a>' +
            //         '       <ul class="dropdown-menu uib-dropdown-menu">' +
            //         '           <li>' +
            //         '               <a class="cyellow" ng-click="grid.appScope.setStatus(row, col, \'4\')">未读</a>' +
            //         '           </li>' +
            //         '           <li>' +
            //         '               <a class="corange" ng-click="grid.appScope.setStatus(row, col, \'3\')">开始审批</a>' +
            //         '           </li>' +
            //         '           <li>' +
            //         '               <a class="cgreen" ng-click="grid.appScope.setStatus(row, col, \'2\')">实施中</a>' +
            //         '           </li>' +
            //         '           <li>' +
            //         '               <a class="cred" ng-click="grid.appScope.setStatus(row, col, \'1\')">效果核实</a>' +
            //         '           </li>' +
            //         '           <li>' +
            //         '               <a class="cblue" ng-click="grid.appScope.setStatus(row, col, \'5\')">已完成</a>' +
            //         '           </li>' +
            //         '       </ul>' +
            //         '   </div>'
            // '</div>';

            var rowTemplate = '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader, \'new-entry\': row.entity.status == 4 }"  ui-grid-cell></div>'


            var statusCellTemplate =
                '<div class="ui-grid-cell-contents jcc">' +
                    ' <span ng-class="{cred: row.entity.status == 1, cgreen: row.entity.status == 2, corange: row.entity.status == 3, cyellow: row.entity.status == 4}" ng-bind="grid.appScope.getStatus(row, col)">---</span>' +
                '</div>';

            var categoryCellTemplate =
                    '<div class="ui-grid-cell-contents icon-contents">' +
                        '<button class="btn btn-link flex flex-center flex-noresize jcc p0 tac" style="width: 50px; height: 50px; border-radius: 100%; text-align: center;" ng-style="{background: grid.appScope.getCategoryColor(row.entity.category)}">' +
                        '   <i class="svg-light-bulb svg-30 svg-white" ng-show="row.entity.category == \'1\'"></i>' +
                        '   <i class="svg-light-bulb svg-30 svg-white" ng-show="row.entity.category == \'2\'"></i>' +
                        '   <i class="svg-light-bulb svg-30 svg-white" ng-show="row.entity.category == \'3\'"></i>' +
                        '   <i class="svg-snowflake svg-30 svg-white" ng-show="row.entity.category == \'4\'"></i>' +
                        '   <i class="svg-snowflake svg-30 svg-white" ng-show="row.entity.category == \'5\'"></i>' +
                        '</button>' +
                    '</div>';

            var descriptionCellTemplate =
                '<div class="ui-grid-cell-contents desc">' +
                    '<h3 class="m0">{{row.entity.title}}</h3>' + 
                    '<div ng-bind="row.entity.description | stripTags">...</div>' + 
                '</div>';

            var ePotentialCellTemplate =
                '<div class="ui-grid-cell-contents">' +
                    '<h3 class="m0"><sub>¥</sub>{{row.entity.saving_potential}} <sub>/月</sub></h3>' + 
                '</div>';


            var field5CellTemplate =
                '<div class="ui-grid-cell-contents">' +
                    '   <span ng-bind="row.entity.complexityText" ng-class="{cred: row.entity.complexityText == \'高\', cgreen: row.entity.complexityText == \'低\', cyellow: row.entity.complexityText == \'中\'}"></i>' +
                    '</div>';

            var paginationTemplate =
                    '<div ui-grid-pager class="table-footer ui-grid-pager-panel" ng-show="grid.options.enablePaginationControls">' +
                    '    <div class="pull-left pagination-info">Showing {{ grid.api.pagination.getPage() }} to {{ grid.api.pagination.getTotalPages() }} of {{grid.api.grid.options.totalItems}} entries</div>' +
                    '        <div class="pull-right">' +
                    '            <ul class="pagination">' +
                    '                <li>' +
                    '                    <a href="#" aria-label="Previous" ng-click="pagePreviousPageClick()">' +
                    '                        <span aria-hidden="true"><i class="icon-left-open"></i></span>' +
                    '                    </a>' +
                    '                </li>' +
                    '                <li ng-repeat="i in grid.appScope.getNumber(grid.api.pagination.getTotalPages()) track by $index" ng-class="{active: grid.api.pagination.getPage() == $index + 1}"><a ng-click="grid.api.pagination.seek($index + 1)" ng-bind="$index + 1"></a></li>' +
                    '                <li>' +
                    '                    <a href="#" aria-label="Next" ng-click="pageNextPageClick()">' +
                    '                        <span aria-hidden="true"><i class="icon-right-open"></i></span>' +
                    '                    </a>' +
                    '                </li>' +
                    '            </ul>' +
                    '        </div>' +
                    '    </div>';
                    '</div>';

            $scope.toggleCompleted = function() {

                if ($scope.completedRecommendationToggle) {
                    $scope.gridApi1.grid.clearAllFilters(undefined,true);
                } else {
                    $scope.gridApi1.grid.columns[0].filters[0].noTerm=true;
                    $scope.gridApi1.grid.columns[0].filters[0].condition = function(term,cellValue){
                        if(cellValue==5) return false;
                        return true;
                    };
                    $scope.gridApi1.grid.queueGridRefresh();
                }

            }

            // Load

            $scope.load = function(start, end){

                if ($rootScope.$stateParams.id > 0) {
                    RecommendationFactory.getByDateRange($rootScope.$stateParams.id, start, end).then(function(result) {
                        $scope.gridOptions1.data = _.map(result, function(d) {
                            d.saving_potentialText = "¥" + d.saving_potential + " /月";
                            switch (d.complexity) {
                                case 1:
                                    d.complexityText = "低";
                                    break;
                                case 2:
                                    d.complexityText = "中";
                                    break;
                                case 3:
                                    d.complexityText = "高";
                                    break;
                            }
                            switch (d.paybacktime) {
                                case 1:
                                    d.paybacktimeText = '短期';
                                    break;
                                case 2:
                                    d.paybacktimeText = '中期';
                                    break;
                                case 3:
                                    d.paybacktimeText = '中长期';
                                    break;
                            }
                            return d;
                        });
                        $scope.toggleCompleted();

                        $timeout(function () {
                            //$scope.gridApi1.selection.selectRowByVisibleIndex(0);
                        });
                    });

                }

            }



            // Main table config
            $scope.gridOptions1 = {
                enableFiltering: true,
                enableRowSelection: true,
                enablePaging: false,
                enablePaginationControls: true,
                enableRowHeaderSelection: false,
                multiSelect: false,
                enableSelectAll: false,
                rowTemplate: rowTemplate,
                rowHeight: 75,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                columnDefs: [
                    { field: 'status', displayName: '当前状态', width: "100", resizable: true, cellClass: 'tac', headerCellClass: 'tac', enableColumnMenu: false, cellTemplate: statusCellTemplate },
                    { field: 'category', displayName: '分类', width: "100", resizable: true, cellClass: 'cell-icon tac', headerCellClass: 'tac', enableColumnMenu: false, cellTemplate: categoryCellTemplate },
                    { field: 'title', displayName: '建议描述概述', width: "*", resizable: true, enableColumnMenu: false, cellClass: '', cellTemplate: descriptionCellTemplate },
                    { field: 'saving_potentialText', id: "used", displayName: '节能潜力', width: "120", resizable: true, cellClass: 'fs24', enableColumnMenu: false, cellTemplate: ePotentialCellTemplate, sort: { direction: uiGridConstants.ASC } },
                    { field: 'complexityText', displayName: '难度系数', width: "100", resizable: true, cellClass: 'tac', enableColumnMenu: false, cellTemplate: field5CellTemplate },
                    { field: 'paybacktimeText', displayName: '回收周期', width: "100", resizable: true, cellClass: 'tac', enableColumnMenu: false, },
                    { field: 'date_of_creation', displayName: '提交时间', width: "150", resizable: true, cellClass: 'tac', type: 'date', cellFilter: 'date:"yyyy-MM-dd"', enableColumnMenu: false, },
                ],
                data: [
                    // { "field1": "¥ 1237 / 月", "field2": "1", "field3": "1", "field4": "过渡季节冷却塔直接供冷回风控制", 'field5': '高', 'field6': '长期', 'field7': { max1: 20000, max2: 20000, max3: 20000, current1: 17000, current2: 13000, current3: 4000 }, 'field8': { money: 5250, co2: 2950 } },
                    // { "field1": "¥ 2672 / 月", "field2": "2", "field3": "2", "field4": "安装冷机群控系统器", 'field5': '低', 'field6': '中长期', 'field7': { max1: 20000, max2: 20000, max3: 20000, current1: 10000, current2: 3000, current3: 9000 }, 'field8': { money: 8310, co2: 4510 } },
                    // { "field1": "¥ 3450 / 月", "field2": "1", "field3": "2", "field4": "二次水泵变频调试", 'field5': '中', 'field6': '短期', 'field7': { max1: 20000, max2: 20000, max3: 20000, current1: 7000, current2: 19000, current3: 15000 }, 'field8': { money: 3750, co2: 2380 } },
                    // { "field1": "¥ 4450 / 月", "field2": "1", "field3": "2", "field4": "二次水泵变频调试", 'field5': '中', 'field6': '短期', 'field7': { max1: 20000, max2: 20000, max3: 20000, current1: 6000, current2: 3000, current3: 8000 }, 'field8': { money: 13285, co2: 8735 } },
                ]
            };

            $scope.dateConfig = { selected: null, maxDate: moment() };
            $timeout(function(){

                $scope.dateConfig.setRange(moment().subtract(1, 'year'), moment());
                $scope.applyDateRange();

            })

            $scope.applyDateRange = function () {
                var data1, data2;

                var dateStart = $scope.dateConfig.getStart();
                var dateEnd = $scope.dateConfig.getEnd();

                var pointStart = dateStart.clone().valueOf();
                var pointEnd = dateEnd.clone().valueOf();

                $scope.isCompareOpen = false;


                $scope.load(moment(dateStart).startOf('day'), moment(dateEnd).endOf('day'));
                // 
                // AlertService.getByDateRange($rootScope.$stateParams.id, moment(dateStart).startOf('day'), moment(dateEnd).endOf('day')).then(function(data){
                //     $scope.gridOptions1.data = data;
                // });
            }



            var gridDetailsHeaderCellTemplate =
                '<div role="columnheader" style="border-bottom: solid 1px #eee;">' +
                '    <div class="ui-grid-cell-contents plr15" style="background: #91c46b; color: #fff;" col-index="renderIndex" title="TOOLTIP">' +
                '        <span class="ui-grid-header-cell-label fwn">' +
                '          {{ col.displayName CUSTOM_FILTERS }}' +
                '        </span>' +
                '    </div>' +
                '</div>';

            $scope.gridDetailsOptions = {
                enableFiltering: false,
                enableRowSelection: false,
                enablePaging: false,
                enablePaginationControls: false,
                enableRowHeaderSelection: false,
                multiSelect: false,
                enableSelectAll: false,
                rowHeight: 50,
                paginationPageSize: 1,
                showHeader: true,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                columnDefs: [
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'status', displayName: '当前状态', width: "100", resizable: true, cellClass: 'fwb tac ptb10 plr15', enableColumnMenu: false, cellTemplate: statusCellTemplate },
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'category', displayName: '分类', width: "100", resizable: true,  cellClass: 'fwb icon ptb10 plr15', enableColumnMenu: false, cellTemplate: categoryCellTemplate },
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'title', displayName: '建议描述概述', width: "*", resizable: true, enableColumnMenu: false, },
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'saving_potentialText', id: "used", displayName: '节能潜力', width: "120", resizable: true, cellClass: 'fwb', enableColumnMenu: false, sort: { direction: uiGridConstants.ASC } },
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'complexityText', displayName: '难度系数', width: "100", resizable: true, cellClass: 'fwb tac', enableColumnMenu: false, cellTemplate: field5CellTemplate },
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'paybacktimeText', displayName: '回收周期', width: "100", resizable: true, cellClass: 'fwb tac', enableColumnMenu: false, },
                    { headerCellTemplate: gridDetailsHeaderCellTemplate, field: 'date_of_creation', displayName: '提交时间', width: "200", resizable: true, cellClass: 'fwb tac', enableColumnMenu: false, },
                ],
                data: []
            };

            // Main table
            $scope.gridOptions1.onRegisterApi = function(gridApi) {
                $scope.gridApi1 = gridApi;
                gridApi.selection.on.rowSelectionChanged($scope, function (row) {

                    /* capsule bars, this use be a middle bar */
                    //var values = _.pluck($scope.gridOptions1.data, 'energy_saved');
                    //var maxVal = Math.ceil(_.max(values, function(obj) { return Math.ceil(obj); }));
                    //var nextN0 = Math.pow(10, maxVal.toString().length - 1);
                    //var extreme = Math.ceil(maxVal / nextN0) * nextN0;
                    //$scope.chartCapsuleBarOptions = { max: extreme, value: row.entity.energy_saved, capsules: 10, title: '节能能力' }

                    /* OBSOLETE: capsule progress bar */
                    //$scope.chartCapsuleBarOptions = angular.extend({}, chartCapsuleBarOptions, { value: row.entity.paybacktime });

                    /* OBSOLETE: circle bar */
                    //$scope.progressCurrent1 = row.entity.energy_saved;

                    //$scope.selectedRow = row;
                    $rootScope.$state.go('root.home.unit.recommendations.details', { rid: row.entity.id } );

                    // $scope.gridDetailsOptions.data = [row.entity];

                    // $scope.chartGaugeOptions0.series[0].data[0] = [row.entity.energy_saved];
                    // $scope.chartGaugeOptions1.series[0].data[0] = row.entity.paybacktime;
                    // $scope.chartGaugeOptions2.series[0].data[0] = row.entity.complexity;

                    // $scope.money = row.entity.saving_potential * 12;
                    // $scope.co2 = row.entity.energy_saved * 12 * 0.527;

                    // $scope.description = row.entity.description;
                    // //$scope.comment = row.entity.comment;

                    // //Load comments
                    // refreshHistory(row.entity.id);

                    // //$rootScope.resize();
                });

            }

            // Main table individual row details
            $scope.hideDetails = function(){
                $scope.selectedRow = null;
                $scope.isLogRowSelected = false;
                $timeout(function(){
                    $rootScope.resize();
                },100);
            }

            // Prevent main table row selection for status column
            $scope.onStatusClick = function($event){
                $event.preventDefault();
                $event.stopPropagation();
            }

            // History log table
            $scope.statusLogGrid={
                enableFiltering: true,
                enableRowSelection: true,
                enablePaging: true,
                enablePaginationControls: true,
                enableRowHeaderSelection: false,
                paginationTemplate: paginationTemplate,
                multiSelect: false,
                enableSelectAll: false,
                paginationPageSize: 3,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                columnDefs:[
                    { field: 'date_of_change', displayName: '修改日期', width: "125", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false },
                    //{ field: 'old_status', displayName: '前状态', width: "*", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false },
                    { field: 'new_status', displayName: '修改后状态', width: "*", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false },
                    { field: 'comment', displayName: '进展描述', width: "*", resizable: true, headerCellClass: 'pl15', cellClass: 'plr15 fs14', enableColumnMenu: false, visible: true },
                ],
                data:[]
            }

            // History log table
            $scope.statusLogGrid.onRegisterApi = function (gridApi) {
                $scope.gridApi2 = gridApi;
                gridApi.selection.on.rowSelectionChanged($scope, function(row) {

                    // Fix Status columns width to stretch Comment column
                   // gridApi.grid.getColumn('old_status').width = '150';
                    gridApi.grid.getColumn('new_status').width = '150';

                    // Show Comment column
                    //$scope.statusLogGrid.columnDefs[2].visible = true;

                    // Stretch Comments panel
                    $scope.isLogRowSelected = true;

                    // Apply changes to grid
                    gridApi.grid.queueGridRefresh();

                    // Trigger window resize event
                    $timeout(function () {
                        angular.element($window).triggerHandler('resize');
                    });

                });
            };

            $scope.hideLog = function() {
                // Stratch Status columns width
                //$scope.gridApi2.grid.getColumn('old_status').width = '*';
                $scope.gridApi2.grid.getColumn('new_status').width = '*';

                // Hide Comment column
                //$scope.statusLogGrid.columnDefs[2].visible = false;

                // Restore Comments panel
                $scope.isLogRowSelected = false;

                // Apply changes to grid
                $scope.gridApi2.grid.queueGridRefresh();

                // Trigger window resize event
                $rootScope.resize();
            }

            var refreshHistory = function(recommendationID){
                return RecommendationFactory.getStatusLog(recommendationID).then(function (result) {

                    // //TODO: Remove this once "commment" available
                    // result.objects = _.map(result.objects, function (d) {
                    //     d.comment = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
                    //     return d;
                    // });

                    $scope.statusLogGrid.data = result.objects;
                    $rootScope.resize();
                });
            }


            $scope.getNumber = function(num) {
                return new Array(num);
            }

            $scope.setStatus = function(row, col, status) {
                var id = row.entity.id;

                // Popup for Comment on Status change
                var modalService = $injector.get('modalService');
                modalService.show({}, {
                    templateUrl: '/static/views/recommendations/templates/status.comment.html'
                }).then(function (data) {

                    //TODO: Save comment, keeping it in memory meantime
                    row.entity.comment = data.comment;

                    //Saving status
                    RecommendationFactory.update({ status: status, id: id, comment:data.comment }).then(function (data) {
                        row.entity.status = status;
                        refreshHistory(id);
                        $timeout(function () {
                            $scope.gridApi1.grid.modifyRows($scope.gridOptions1.data);
                        });
                    });

                });

            };


            /*

            Indicators

            */

            // middle big gauge
            $scope.chartGaugeOptions0 = {
                options: {
                    chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15, spacingLeft: 0, spacingRight: 0 },
                    title: null,
                    exporting: { enabled: false },
                    pane: { center: ['50%', '50%'], size: '100%', startAngle: 115, endAngle: -115, background: null },
                    plotOptions: {
                        gauge: {
                            dataLabels: { enabled: true, style: { 'fontSize': '20px' }, y: 20, borderWidth: 0 },
                            dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
                            pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
                        }
                    },
                    yAxis: {
                        pane: 0,
                        min: 0,
                        max: 3000,
                        lineColor: null,
                        reversed: true,
                        minorTickInterval: 1,
                        tickPixelInterval: 10,
                        minorTickPosition: 'outside',
                        tickPosition: 'outside',
                        tickWidth: 1,
                        tickPositions: [0, 1000, 2000, 3000],
                        labels: { step: 1, distance: 15, rotation: 'auto' },
                        title: { text: 'kWh', align: 'middle', style: { 'fontSize': '12px' }, y: 7 }, // Y Title
                        plotBands: [
                            { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1000, color: '#55BF3B' }, // green
                            { innerRadius: '90%', outerRadius: '100%', from: 1000, to: 2000, color: '#ffcc00' }, // yellow
                            { innerRadius: '90%', outerRadius: '100%', from: 2000, to: 3000, color: '#DF5353' } // red
                        ],
                        dataLabels: {
                             formatter: function () {
                             var kmh = this.y,
                             mph = Math.round(kmh * 0.621);
                        }
                    },
                    },
                    credits: false
                },
                series: [
                    {
                        name: 'kWh',
                        data: [0]
                    }
                ],

            };

            // left small gauge
            $scope.chartGaugeOptions1 = {
                options: {
                    chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15 },
                    title: null,
                    exporting: { enabled: false },
                    pane: { center: ['50%', '60%'], size: '75%', startAngle: 115, endAngle: -115, background: null },
                    plotOptions: {
                        gauge: {
                            dataLabels: {
                                borderWidth: 0,
                                enabled: true,
                                 formatter: function () {
                                    switch(this.y) {
                                        case 1:
                                            return 'EASY';
                                        case 2:
                                            return 'NORMAL';
                                        case 3:
                                            return 'HARD';
                                    }
                                }
                            },
                            dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
                            pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
                        }
                    },
                    yAxis: {
                        pane: 0,
                        min: 0,
                        max: 3,
                        lineColor: null,
                        reversed: true,
                        minorTickInterval: 1,
                        tickPixelInterval: 10,
                        minorTickPosition: 'outside',
                        tickPosition: 'outside',
                        tickWidth: 1,
                        tickPositions: [0, 1, 2, 3],
                        labels: { step: 1, distance: 15, rotation: 'auto' },
                        title: { text: '回收周期', align: 'left', align: 'middle', style: { 'fontSize': '12px' }, y: 7, style:  { 'color': '#aaa' } }, // Y Title
                        plotBands: [
                            { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1, color: '#55BF3B' }, // green
                            { innerRadius: '90%', outerRadius: '100%', from: 1, to: 2, color: '#ffcc00' }, // yellow
                            { innerRadius: '90%', outerRadius: '100%', from: 2, to: 3, color: '#DF5353' } // red
                        ]
                    },
                    credits: false
                },
                series: [
                    {
                        name: '回收周期',
                        data: [0]
                    }
                ],

            };

            // right small gauge
            $scope.chartGaugeOptions2 = {
                options: {
                    chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15 },
                    title: null,
                    exporting: { enabled: false },
                    pane: { center: ['50%', '60%'], size: '75%', startAngle: 115, endAngle: -115, background: null },
                    plotOptions: {
                        gauge: {
                            dataLabels: {
                                borderWidth: 0,
                                enabled: true,
                                formatter: function () {
                                    switch(this.y) {
                                        case 1:
                                            return 'EASY';
                                        case 2:
                                            return 'NORMAL';
                                        case 3:
                                            return 'HARD';
                                    }
                                }
                            },
                            dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
                            pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
                        }
                    },
                    yAxis: {
                        pane: 0,
                        min: 0,
                        max: 3,
                        lineColor: null,
                        reversed: true,
                        minorTickInterval: 1,
                        tickPixelInterval: 10,
                        minorTickPosition: 'outside',
                        tickPosition: 'outside',
                        tickWidth: 1,
                        tickPositions: [0, 1, 2, 3],
                        labels: { step: 1, distance: 15, rotation: 'auto' },
                        title: { text: '回收周期', align: 'left', align: 'middle', style: { 'fontSize': '12px' }, y: 7, style:  { 'color': '#aaa' } }, // Y Title
                        plotBands: [
                            { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1, color: '#55BF3B' }, // green
                            { innerRadius: '90%', outerRadius: '100%', from: 1, to: 2, color: '#ffcc00' }, // yellow
                            { innerRadius: '90%', outerRadius: '100%', from: 2, to: 3, color: '#DF5353' } // red
                        ]
                    },
                    credits: false
                },
                series: [
                    {
                        name: '回收周期',
                        data: [0]
                    }
                ],

            };

            $scope.chartCapsuleBarOptions = chartCapsuleBarOptions;

            // $scope.chartGaugeOptions2 = {
            //     options: {
            //         chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15 },
            //         title: null,
            //         exporting: { enabled: false },
            //         pane: { center: ['10px', '50%'], size: '140%', startAngle: 0, endAngle: 180, background: null },
            //         plotOptions: {
            //             gauge: {
            //                 dataLabels: { enabled: false },
            //                 dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
            //                 pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
            //             }
            //         },
            //         yAxis: {
            //             pane: 0,
            //             min: 0,
            //             max: 3,
            //             lineColor: null,
            //             reversed: true,
            //             minorTickInterval: 1,
            //             tickPixelInterval: 10,
            //             minorTickPosition: 'outside',
            //             tickPosition: 'outside',
            //             tickWidth: 1,
            //             tickPositions: [0, 1, 2, 3],
            //             labels: { step: 1, distance: 15, rotation: 'auto' },
            //             title: { text: '难<br/>度<br/>系<br/>数', align: 'left', x: -15, align: 'middle' },
            //             plotBands: [
            //                 { innerRadius: '90%', outerRadius: '100%', from: 0, to: 1, color: '#55BF3B' }, // green
            //                 { innerRadius: '90%', outerRadius: '100%', from: 1, to: 2, color: '#ffcc00' }, // yellow
            //                 { innerRadius: '90%', outerRadius: '100%', from: 2, to: 3, color: '#DF5353' } // red
            //             ]
            //         },
            //         credits: false
            //     },
            //     series: [
            //         {
            //             name: 'Difficulty',
            //             data: [0]
            //         }
            //     ],

            // };


        }
    ])

},{}],29:[function(require,module,exports){
angular.module('app.controllers.reports.alerts', [])
.controller('reportsAlertsCtrl', [ 
	'$scope', '$rootScope', '$state', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache', 'AlertService', '$q',
	function ($scope, $rootScope, $state, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache, AlertService, $q) {

			$scope.newsItems = [];
			
            // grouping by date
			$scope.convertTo = function (arr, key, dayWise) {
                var groups = {};
                for (var i=0;l= arr.length, i<l;i++) {
                    arr[i][key] = moment(arr[i][key]).format('MMM DD, YYYY');
                    groups[arr[i][key]] = groups[arr[i][key]] || [];
                    groups[arr[i][key]].push(arr[i]);
                }
                return groups;
            };

            // Alert type color 
            $scope.getCategoryColor = function(categ){
                switch(categ){
                    case 1: return 'orange';
                    case 2: return 'blue';
                    default: return '#eee';
                }
            }

            // Load
            $scope.load = function(){
                
                $timeout(function(){

                    $scope.dateConfig.setRange(moment().subtract(1, 'week'), moment());
                    $scope.applyDateRange();

                })

            }

            // First time load
            $scope.load();


            /*
            *
            *   Date range filter
            *
            */

            $scope.dateConfig = { selected: null, maxDate: moment() };

            $scope.applyDateRange = function () {
                var data1, data2;

                //TODO: Use this daterange for API requests
                //TODO: Fine tune daterange picker
                var dateStart = $scope.dateConfig.getStart();
                var dateEnd = $scope.dateConfig.getEnd();

                var pointStart = dateStart.clone().valueOf();
                var pointEnd = dateEnd.clone().valueOf();

                // Close Compare configuration Popup
                $scope.isCompareOpen = false;

                // 
                AlertService.getByDateRange($rootScope.$stateParams.id, moment(dateStart).startOf('day'), moment(dateEnd).endOf('day'), true).then(function(data){
                    $scope.gridOptions1.data = data;
                });
            }


            /*
            *
            *   Table configuration
            *
            */

            var rowTemplate = '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader, \'new-entry\': row.entity.alertstatus == 0, \'opened-entry\': row.entity.alertstatus == 1, \'checked-entry\': row.entity.alertstatus == 2 }"  ui-grid-cell></div>'

            var statusCellTemplate =
                '<div class="ui-grid-cell-contents icon-contents">' +
                    '<i class="svg-mail-2 svg-25" ng-show="row.entity.alertstatus == 1"></i>' +
                    '<i class="svg-mail-open svg-25" ng-show="row.entity.alertstatus == 2"></i>' +
                    '<i class="svg-checked svg-25" ng-show="row.entity.alertstatus == 3"></i>' +
                '</div>';

            var typeCellTemplate =
                '<div class="ui-grid-cell-contents icon-contents">' +
                        '<button class="btn btn-link flex flex-center flex-noresize jcc p0 tac" style="width: 50px; height: 50px; border-radius: 100%; text-align: center;" ng-style="{background: grid.appScope.getCategoryColor(row.entity.alerttype)}">' +
                        '   <i class="svg-alert svg-30 svg-white" ng-show="row.entity.alerttype == 1"></i>' +
                        '   <i class="svg-bar-chart svg-30 svg-white" ng-show="row.entity.alerttype == 2"></i>' +
                        '</button>' +
                '</div>';

            var descCellTemplate =
                '<div class="ui-grid-cell-contents desc">' +
                    '<h3 class="m0">{{row.entity.title}}</h3>' + 
                    '<div ng-bind="row.entity.description | stripTags">...</div>' + 
                '</div>';


            var ePotentialCellTemplate =
                '<div class="ui-grid-cell-contents">' +
                    '<h3 class="m0">{{row.entity.saving_potential}} <sub>kWh</sub></h3>' + 
                '</div>';
            
            var eSavedCellTemplate =
                '<div class="ui-grid-cell-contents">' +
                    '<h3 class="m0">{{row.entity.energy_saved}} <sub>kWh</sub></h3>' + 
                '</div>';

             $scope.gridOptions1 = {
                enableFiltering: true,
                enablePaging: false,
                enablePaginationControls: false,
                enableRowHeaderSelection: false,
                multiSelect: false,
                enableSelectAll: false,
                rowTemplate: rowTemplate,
                rowHeight: 75,
                treeRowHeaderAlwaysVisible: false,
                enableHorizontalScrollbar: uiGridConstants.scrollbars.NEVER,
                enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                columnDefs: [
                    { field: 'alertstatus', displayName: '', width: "100", resizable: true, cellClass: 'cell-icon', enableColumnMenu: false, cellTemplate: statusCellTemplate },
                    { field: 'alerttype', displayName: '', width: "100", resizable: true, cellClass: 'cell-icon', enableColumnMenu: false, cellTemplate: typeCellTemplate },
                    { field: 'title', displayName: 'description', width: "*", resizable: true, cellClass: '', enableColumnMenu: false, cellTemplate: descCellTemplate },
                    { field: 'saving_potential', id: "used", displayName: 'saving_potential', width: '200', resizable: true, cellClass: 'fs24', enableColumnMenu: false, cellTemplate: ePotentialCellTemplate },
                    { field: 'energy_saved', displayName: 'energy_saved', width: '200', resizable: true, cellClass: 'fs24', enableColumnMenu: false, cellTemplate: eSavedCellTemplate },
                    { field: 'alert_time', displayName: 'created', width: '200', resizable: true, cellClass: '', enableColumnMenu: false, type: 'date', /*grouping: { groupPriority: 0 },*/ cellFilter: 'date:"yyyy-MM-dd HH:mm"', sort: { direction: uiGridConstants.DESC } },
                ],
                data: []
            };



            /*
            *
            *   Table row changed handler
            *
            */

            $scope.gridOptions1.onRegisterApi = function(gridApi) {
                
                $scope.gridApi1 = gridApi;
                
                gridApi.selection.on.rowSelectionChanged($scope, function (row) {

                    // set alert status to "opened"
                    //AlertService.setStatus($rootScope.$stateParams.id, row.entity.id, 2).then(function(){
                        $rootScope.setActiveView('content'); 
                        $rootScope.go('root.home.unit.reports.alerts.details', {id: $rootScope.$stateParams.id, aid: row.entity.id}, 'forward');
                    //}) 

                });
            }


}])
.controller('reportsAlertDetailsCtrl', [ 
	'$scope', '$rootScope', '$state', '$timeout', '$http', '$window', 'uiGridConstants', 'EnergyUnitFactory', 'AllMetersService','MiscSelectionFactory', 'geoService', '$mdSidenav', 'platformService', '$templateCache', 'AlertService', '$ionicPopup', '$compile',
	function ($scope, $rootScope, $state, $timeout, $http, $window, uiGridConstants, EnergyUnitFactory, AllMetersService,MiscSelectionFactory, geoService, $mdSidenav, platformService, $templateCache, AlertService, $ionicPopup, $compile) {


            $scope.chartOptions1 = { options: {} };


            $scope.load = function(){
                AlertService.getByID($rootScope.$stateParams.id, $rootScope.$stateParams.aid).then(function(data){
                    $scope.alertItem = data;

                    // WARNING: TODO: Best way to save valid JSON into DB  
                    $scope.chartOptions1 = $scope.$eval($scope.alertItem.highchart_plot);
                })
            }

            $scope.load();


            $scope.showPopup = function() {
                $scope.data = {};

                // TODO: Translate popup text
                $scope.statusPopup = $ionicPopup.show({
                    template:   '<button ng-click="setStatus(1)" ng-class="{pressed: alertItem.alertstatus == 1}"><i class="svg-mail svg-25"></i> Unread</button>' +
                                '<button ng-click="setStatus(2)" ng-class="{pressed: alertItem.alertstatus == 2}"><i class="svg-mail-open svg-24"></i> Ignore</button>' +
                                '<button ng-click="setStatus(3)" ng-class="{pressed: alertItem.alertstatus == 3}"><i class="svg-checked svg-25"></i> Discmiss</button>',
                    title:      'Change alert status',
                    // subTitle: 'Sub time',
                    scope: $scope,
                    buttons: [
                        { text: 'Cancel' },
                    //   {
                    //     text: '<b>Save</b>',
                    //     type: 'button-positive',
                    //     onTap: function(e) {
                    //       if (!$scope.data.someVal) {
                    //         e.preventDefault();
                    //       } else {
                    //         return $scope.data.someVal;
                    //       }
                    //     }
                    //   }
                    ]
                });

                // Once closed
                $scope.statusPopup.then(function(res) {
                    
                });

                // Dismiss on timeout
                // $timeout(function() {
                //    myPopup.close(); //close the popup after 3 seconds for some reason
                // }, 3000);
            };


            $scope.setStatus = function(newStatus){
                AlertService.setStatus($rootScope.$stateParams.id, $scope.alertItem.id, newStatus).then(function(){
                    $scope.statusPopup.close();
                    // $rootScope.go('root.home.unit.reports.alerts', {id: $rootScope.$stateParams.id}, 'back');
                })
            };

            var unbindSetStatus = $rootScope.$on('alert:set-status', function(event, data) {
                $scope.showPopup();
            });

            $scope.$on('$destroy', function(){
                unbindSetStatus();
            });


}])
.run(['$rootScope', 'AlertService', function($rootScope) {

    $rootScope.setAlertStatus = function(newStatus){
        $rootScope.$broadcast('alert:set-status', { alertID: $rootScope.$stateParams.aid, newStatus: newStatus });
    }

}]);



                    



                    // TEMP

                    //console.log('$scope.chartOptions1', $scope.chartOptions1);
                    
                    //$scope.chartOptions1 = JSON.parse($scope.alertItem.highchart_plot);



                    // $scope.chartOptions1.options = {
                    //     chart: { type: 'line', animation: false, panning: true, margin: [55, 0, 0, 0] },
                    //     title: null,
                    //     legend: { enabled: false },
                    //     xAxis: {
                    //         type: 'datetime',
                    //         //ordinal: false,
                    //         text: null,
                            
                    //         //marginTop: 50,

                    //         //minPadding: 0,

                    //         lineWidth:1,
                    //         lineColor: "#FFF",

                            
                    //         minorTickInterval: 24 * 3600 * 1000,
                    //         minorTickWidth: 1,
                    //         minorTickLength: 5,
                    //         minorTickColor: '#ccc',
                    //         minorGridLineWidth: 0,
                            
                    //         //tickPixelInterval: 100,
                    //         tickmarkPlacement: 'on',

                    //         tickWidth: 1,
                    //         tickLength: 10,
                    //         tickColor: '#ccc',
                    //         gridLineWidth: 0,

                    //         endOnTick: false,
                    //         startOnTick: false,

                    //         labels: 
                    //         { 
                    //             rotation: 0, 
                    //             align: 'center', 
                    //             y: -25, 
                    //             format: '{value:%b}',
                    //             autoRotation: false,
                    //             style: 
                    //             {
                    //                 textOverflow: 'none'
                    //             },
                    //             formatter: function(args)
                    //             {
                    //                 var min = this.axis.min;
                    //                 var max = this.axis.max;

                    //                 var diffHours = moment(max).diff(moment(min), 'hours');

                    //                 if(diffHours < 24 * 30 * 5)
                    //                 {
                    //                     this.value = moment(this.value).format('MMM<br /><br />D');
                    //                 }
                    //                 else
                    //                 {
                    //                     this.value = moment(this.value).format('MMM');
                    //                 }

                    //                 return this.value; 
                    //             },
                    //             useHtml: true
                    //          },
                    //         showFirstLabel: true,
                    //         showLastLabel: true,

                    //         opposite: true
                    //     },
                    //     yAxis: {
                    //         gridLineColor: "#eee",
                    //         minorGridLineWidth: 0,
                    //         title: null,
                    //         showLastLabel: false,
                    //         endOnTick: false,
                    //         startOnTick: false,
                    //         labels: {
                    //             align: 'left', x: 5, y: -3
                    //         }
                            
                    //     },
                    //     plotOptions: {
                    //         title: null,
                    //         series: {
                    //             pointPadding: 0,
                    //             groupPadding: 0, 
                    //         },
                    //         line: { animation: false, states: { hover: { enabled: false } }, marker: { enabled: false } }
                    //     }
                    // }

                    // $scope.chartOptions1.series = [{ lineWidth: 1, animation: false, color: '#2588E3', 
                    //     data: [[1440190800000,505.34559575036076],[1440277200000,612.96883011544],[1440363600000,606.5574361760462],[1440450000000,342.1636292207792],[1440536400000,354.5245438961039],[1440622800000,650.5888973953823],[1440709200000,688.8129046464646],[1440795600000,613.5637302597402],[1440882000000,634.3740437445889],[1440968400000,664.6148303968253],[1441054800000,344.32588046897547],[1441141200000,364.43460779220777],[1441227600000,333.03053882395375],[1441314000000,649.7186760173159],[1441400400000,640.5012792929293],[1441486800000,610.7399789754691],[1441573200000,629.4322545310246],[1441659600000,334.50017643578644],[1441746000000,321.43771766233766],[1441832400000,548.7486482828282],[1441918800000,558.0549358730158],[1442005200000,599.1159673520924],[1442091600000,560.19053492785],[1442178000000,582.5058713636363],[1442264400000,307.9001796608946],[1442350800000,331.64082949494946],[1442437200000,592.7623219985569],[1442523600000,505.0057433838383],[1442610000000,497.2757017965368],[1442696400000,511.0042191414141],[1442782800000,550.999632085137],[1442869200000,311.1102944444444],[1442955600000,324.0262334559884],[1443042000000,508.24710981240986],[1443128400000,486.82853146464646],[1443214800000,525.9182585353535],[1443301200000,555.191103051948],[1443387600000,579.1271542496393],[1443474000000,370.12038202020204],[1443560400000,311.4876938311688],[1443646800000,513.8767851082251],[1443733200000,433.5395629220779],[1443819600000,474.5473446969697],[1443906000000,442.1087922077922],[1443992400000,511.2527577849928],[1444078800000,298.97135417027414],[1444165200000,264.0818908658008],[1444251600000,435.41763054112556],[1444338000000,403.1344189105339],[1444424400000,439.8354149494949],[1444510800000,361.77505211399705],[1444597200000,421.74244435064935],[1444683600000,283.44025940836934],[1444770000000,251.56555120490617],[1444856400000,464.4063939105339],[1444942800000,453.95905800144294],[1445029200000,419.2116989393939],[1445115600000,455.65955764790755],[1445202000000,358.73855974747465],[1445288400000,274.5691538239538],[1445374800000,253.83438751803746],[1445461200000,273.9875147691197],[1445547600000,386.7901898124098],[1445634000000,456.87621509379505],[1445720400000,516.3543179076478],[1445806800000,475.1644627777777],[1445893200000,305.5114635425685],[1445979600000,301.1114306926407],[1446066000000,412.0632600793651],[1446152400000,422.84798687590177],[1446238800000,408.706617121212],[1446325200000,438.17040924242417],[1446411600000,402.5305871572872],[1446498000000,314.8310083982684],[1446584400000,318.25424283549773],[1446670800000,393.8592391847041],[1446757200000,397.92560797258295],[1446843600000,412.986756017316],[1446930000000,422.7103375396826],[1447016400000,431.43937176767673],[1447102800000,259.3666185281385],[1447189200000,294.5535613492064],[1447275600000,391.4571778499278],[1447362000000,445.0301812698413],[1447448400000,403.4407791774891],[1447534800000,427.35900157287153],[1447621200000,411.685784978355],[1447707600000,251.31691160894658],[1447794000000,301.6930697474747],[1447880400000,318.72050937950934],[1447966800000,328.43070629870124],[1448053200000,307.7136999639249],[1448139600000,233.26834093795088],[1448226000000,261.9196143795093],[1448312400000,259.07357900432896],[1448398800000,319.2443612265512],[1448485200000,400.6169082034631],[1448571600000,442.22857106060604],[1448658000000,462.7990431024531],[1448744400000,410.3582776118326],[1448830800000,410.30046593073587],[1448917200000,267.5939297474747],[1449003600000,277.0155898484848],[1449090000000,413.6792098124098],[1449176400000,408.74658546897547],[1449262800000,447.1666227417027],[1449349200000,398.3856567676768],[1449435600000,387.74959038239535],[1449522000000,279.9326651082251],[1449608400000,220.12152230158733],[1449694800000,372.47162568542575],[1449781200000,377.604425981241],[1449867600000,428.99422862193353],[1449954000000,376.3877497979798],[1450040400000,410.2559895238095],[1450126800000,265.4138887012986],[1450213200000,223.42931692640695],[1450299600000,372.50715442279943],[1450386000000,354.6981808441558],[1450472400000,371.46351138528144],[1450558800000,355.83014306637807],[1450645200000,366.38872658730156],[1450731600000,269.4587221284271],[1450818000000,263.87765119769114],[1450904400000,247.8270772799423],[1450990800000,239.67969051948052],[1451077200000,293.7366026767676],[1451163600000,445.745036933622],[1451250000000,409.7986534415584],[1451336400000,303.01618759740256],[1451422800000,319.1200498412698],[1451509200000,263.6368996536796],[1451595600000,273.9297948629148],[1451682000000,286.721414076479],[1451768400000,399.8302803679653],[1451854800000,481.02527007936504],[1451941200000,463.6293194588745],[1452027600000,381.62262289321785],[1452114000000,300.4720717316017],[1452200400000,304.9431444660894],[1452286800000,417.5643866666667],[1452373200000,414.167783008658],[1452459600000,378.1904962337663],[1452546000000,420.25060677489176],[1452632400000,422.34146939393946],[1452718800000,317.8502034920635],[1452805200000,349.0766727489178],[1452891600000,298.6383547113997],[1452978000000,432.29182514430016],[1453064400000,439.0717698412698],[1453150800000,472.8068181962482],[1453237200000,444.15108143578647],[1453323600000,282.1349015295815],[1453410000000,310.3643756565656],[1453496400000,385.139078059163],[1453582800000,452.742465945166],[1453669200000,416.4099709523809],[1453755600000,381.5249476406925],[1453842000000,431.2439654329004],[1453928400000,278.98991556277053],[1454014800000,312.7175718326117],[1454101200000,446.60641235930734],[1454187600000,412.2586453823954],[1454274000000,430.435967049062],[1454360400000,421.88009253968255],[1454446800000,451.5747493722943],[1454533200000,241.86860696248192],[1454619600000,273.8898349278499],[1454706000000,432.14981267676757],[1454792400000,423.1277068037518],[1454878800000,435.47977361471857],[1454965200000,440.3815508874459],[1455051600000,463.5893939393939],[1455138000000,329.4963045670996],[1455224400000,326.8634309090909],[1455310800000,517.1490766161617],[1455397200000,489.8830633333333],[1455483600000,464.4418633766234],[1455570000000,392.6693884199134],[1455656400000,401.2427521645021],[1455742800000,278.95142670274157],[1455829200000,293.82984252525245],[1455915600000,414.882548044733],[1456002000000,400.5104084126984],[1456088400000,432.7891548124097],[1456174800000,466.488700050505],[1456261200000,411.28626134199123],[1456347600000,345.50247855699854],[1456434000000,327.42282793650793],[1456520400000,478.53443412698414],[1456606800000,434.7871527128427],[1456693200000,462.7679945093794],[1456779600000,467.4608397402598],[1456866000000,311.75853339105333],[1456952400000,349.0589127777778],[1457038800000,462.15974073593077],[1457125200000,469.0638958658008],[1457211600000,451.99655671717176],[1457298000000,439.05844986291487],[1457384400000,419.77536847041847],[1457470800000,284.0085784848484],[1457557200000,301.84402950216446],[1457643600000,405.93166369408357],[1457730000000,477.28690551948046],[1457816400000,502.0885874386724],[1457902800000,498.1414506782107],[1457989200000,514.4273442135642],[1458075600000,285.06973676046175],[1458162000000,301.82182953823957],[1458248400000,495.14410680375175],[1458334800000,502.87906599567106],[1458421200000,542.8388817532466],[1458507600000,484.4529697474748],[1458594000000,498.4566817532467],[1458680400000,315.0796479942279],[1458766800000,280.8917035497835],[1458853200000,468.5844102958153],[1458939600000,482.4638950432901],[1459026000000,537.7239775613276],[1459112400000,514.8225708730159],[1459198800000,492.0008565295815],[1459285200000,292.91076401875887],[1459371600000,281.9661818037518],[1459458000000,426.8395560678211],[1459544400000,417.3113235209235],[1459630800000,444.6083999278499],[1459717200000,402.69913021645016],[1459803600000,309.90261640692637],[1459890000000,291.54768623376617],[1459976400000,279.8127853030302],[1460062800000,444.39529595238093],[1460149200000,452.27632520923527],[1460235600000,480.5545983405483],[1460322000000,455.0557102164503],[1460408400000,423.0477938167388],[1460494800000,320.46535924242426],[1460581200000,286.43725453823953],[1460667600000,509.04163296536797],[1460754000000,487.3433545743145],[1460840400000,445.52751132034626],[1460926800000,486.9127089249638],[1461013200000,478.97845864357856],[1461099600000,345.3159988600289],[1461186000000,292.58664454545453],[1461272400000,416.5299012337663],[1461358800000,446.71298059884555],[1461445200000,452.511636031746],[1461531600000,528.1292124242425],[1461618000000,483.39624305194803],[1461704400000,316.89116505050504],[1461790800000,320.8605186002885],[1461877200000,533.426106991342],[1461963600000,594.103182994228],[1462050000000,591.1726929220779],[1462136400000,597.7127709379508],[1462222800000,539.7619766955266],[1462309200000,365.26932643578635],[1462395600000,380.9336209812409],[1462482000000,527.9071875468975],[1462568400000,560.0883814430014],[1462654800000,519.4578717171718],[1462741200000,539.3312973953824],[1462827600000,517.8372839105339],[1462914000000,303.31366711399704],[1463000400000,304.001865995671],[1463086800000,432.37626913419916],[1463173200000,509.85210582972576],[1463259600000,526.664006010101],[1463346000000,529.5810648268398],[1463432400000,565.38517505772],[1463518800000,325.02523183261184],[1463605200000,381.90153940836933],[1463691600000,547.4520273737373],[1463778000000,561.8598207864358],[1463864400000,513.8013136435787],[1463950800000,480.90094186868686],[1464037200000,460.4769750577201],[1464123600000,276.68703879509377],[1464210000000,360.1589704545454],[1464296400000,480.13283994228],[1464382800000,525.7271258513707],[1464469200000,522.192900007215],[1464555600000,525.8736624386725],[1464642000000,436.65182234487736],[1464728400000,295.8677992135642],[1464814800000,337.72805119047615],[1464901200000,437.0203165079365],[1464987600000,455.801671067821],[1465074000000,441.4470072871573],[1465160400000,404.75050056998566],[1465246800000,423.5892373809523],[1465333200000,336.3205734776334],[1465419600000,315.7278869408369],[1465506000000,472.89991502886005],[1465592400000,449.23043968253967],[1465678800000,499.6687328643578],[1465765200000,396.8161504834055],[1465851600000,418.44770049783546],[1465938000000,336.85781260461766],[1466024400000,315.6302070995671],[1466110800000,446.67743503607505],[1466197200000,406.1534618109668],[1466283600000,485.52300800865805],[1466370000000,465.2145035714285],[1466456400000,428.3757767460317],[1466542800000,360.8071420995671],[1466629200000,338.7626368109668],[1466715600000,445.1008957359307],[1466802000000,391.44342347041845],[1466888400000,398.4717102597403],[1466974800000,409.8027978427129],[1467061200000,416.55629836940835],[1467147600000,422.49662899711404],[1467234000000,399.6352269841269],[1467320400000,502.1906300288601],[1467406800000,400.48774689754686],[1467493200000,386.9590276984127],[1467579600000,473.8545417748917],[1467666000000,475.7948323881674],[1467752400000,388.1042762481962],[1467838800000,423.04718619047617],[1467925200000,427.36790182539687],[1468011600000,421.973080007215],[1468098000000,392.57574399711393],[1468184400000,386.09314306637805],[1468270800000,334.02066524531017],[1468357200000,308.39314543290044],[1468443600000,310.5451416017316],[1468530000000,427.9283382034632],[1468616400000,498.12383334054834],[1468702800000,494.7317886002886],[1468789200000,494.78937963924955],[1468875600000,461.79522501443006],[1468962000000,318.71156209235204],[1469048400000,371.5031099567099],[1469134800000,467.4745983261184],[1469221200000,546.4976289177489],[1469307600000,507.527839011544],[1469394000000,527.4189527705628],[1469480400000,503.0434466810967],[1469566800000,370.56187316738817],[1469653200000,380.91594398989895],[1469739600000,454.24778678210674],[1469826000000,518.0105782323233],[1469912400000,634.3340486291485],[1469998800000,579.970557092352],[1470085200000,551.2260212409813],[1470171600000,332.17366151515154],[1470258000000,377.0044713347764],[1470344400000,506.87492413419915],[1470430800000,570.6421938167388],[1470517200000,568.8928198340548],[1470603600000,567.7783701731602],[1470690000000,569.0171059812408],[1470776400000,350.1289594516594],[1470862800000,329.3542247979798],[1470949200000,587.1589704184703],[1471035600000,514.9425011544012],[1471122000000,555.2709387950938],[1471208400000,0],[1471294800000,0],[1471381200000,0],[1471467600000,0],[1471554000000,0],[1471640400000,0],[1471726800000,0],[1471813200000,0]] 
                    // }]

                    // // JSON.stringify($scope.chartOptions1);
                    // console.log('JSON.stringify($scope.chartOptions1)', JSON.stringify($scope.chartOptions1));



},{}],30:[function(require,module,exports){
  angular.module('app.controllers.reports.consumption', [])
  .controller('reportsConsumptionTrendsCtrl', [
        '$scope', '$rootScope', 'html2pdf', '$timeout', function($scope, $rootScope, html2pdf, $timeout) {

            $scope.chartOptions1 = {
                options: {
                    chart: {
                        type: 'column'
                    },
                    title: null,
                    xAxis: {
                        categories: [
                            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
                        ]
                    },
                    yAxis: {
                        title: {
                            text: '占总能耗%'
                        },
                        plotLines: [
                            {
                                value: 0,
                                width: 1,
                                color: '#808080'
                            }
                        ],
                        min: 0,
                        max: 100
                    },
                    tooltip: {
                        valueSuffix: '%'
                    },
                    legend: {
                        align: 'center',
                        verticalAlign: 'bottom',
                        borderWidth: 0
                    },
                    plotOptions: {
                        column: {
                            stacking: 'percent'
                            //dataLabels: {
                            //    enabled: true,
                            //    color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white',
                            //    style: {
                            //        textShadow: '0 0 3px black'
                            //    }
                            //}
                        }
                    },
                    credits: {
                        enabled: false
                    }
                },
                series: [
                    {
                        name: '照明',
                        data: [15.16, 17.00, 17.46, 17.12, 19.29, 12.42, 13.22, 18.95, 16.95, 14.42, 15.71, 13.30]
                    }, {
                        name: '取暖',
                        data: [16.69, 17.47, 18.08, 17.95, 15.10, 22.96, 16.56, 15.98, 16.95, 16.41, 16.38, 17.43]
                    }, {
                        name: '制冷',
                        data: [16.69, 17.47, 18.58, 14.52, 17.64, 17.75, 15.56, 16.55, 17.29, 13.95, 16.05, 17.09]
                    }, {
                        name: '设备',
                        data: [17.86, 13.95, 17.71, 17.59, 17.77, 15.14, 16.89, 13.58, 16.15, 17.47, 13.90, 15.94]
                    }, {
                        name: '动力',
                        data: [14.10, 17.47, 15.34, 16.41, 15.10, 15.87, 18.89, 18.95, 16.15, 19.93, 18.76, 17.20]
                    }, {
                        name: '其他',
                        data: [19.51, 16.65, 12.84, 16.41, 15.10, 15.87, 18.89, 15.98, 16.50, 17.82, 19.21, 19.04]
                    }
                ]
            };

            $scope.chartOptions2 = {
                options: {
                    chart: {
                        type: 'area'
                    },
                    title: null,
                    xAxis: {
                        categories: [
                            '1', '2', '3', '4', '5', '6',
                            '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18',
                            '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30'
                        ]
                    },
                    yAxis: {
                        title: {
                            text: '占总能耗%'
                        },
                        plotLines: [
                            {
                                value: 0,
                                width: 1,
                                color: '#808080'
                            }
                        ],
                        min: 0,
                        max: 100
                    },
                    tooltip: {
                        valueSuffix: '%'
                    },
                    legend: {
                        align: 'center',
                        verticalAlign: 'bottom',
                        borderWidth: 0
                    },
                    plotOptions: {
                        area: {
                            stacking: 'percent',
                            lineWidth: 0,
                            marker: {
                                enabled: false
                            }
                        }
                    },
                    credits: {
                        enabled: false
                    }
                },
                series: [
                    {
                        name: '照明',
                        data: [19.20, 17.02, 17.41, 19.64, 17.90, 16.01, 15.64, 16.89, 18.87, 16.90, 16.55, 14.95, 17.48, 14.91, 16.56, 16.83, 16.86, 15.17, 17.83, 16.58, 20.16, 17.34, 18.63, 15.38, 19.69, 18.42, 20.49, 11.95, 13.06, 13.91, 12.29]
                    }, {
                        name: '取暖',
                        data: [17.20, 19.00, 19.92, 18.27, 16.02, 13.57, 16.62, 16.49, 14.51, 18.17, 18.50, 17.63, 17.91, 15.18, 16.43, 19.72, 19.48, 16.59, 15.60, 21.59, 17.64, 19.35, 21.31, 21.31, 18.77, 18.42, 17.05, 17.78, 15.07, 17.39, 17.20]
                    }, {
                        name: '制冷',
                        data: [14.90, 14.44, 16.57, 16.76, 14.80, 18.31, 17.46, 19.32, 17.55, 15.50, 16.55, 14.95, 17.05, 16.53, 14.72, 17.24, 18.33, 19.75, 19.92, 14.16, 15.28, 14.71, 14.75, 13.14, 14.92, 15.63, 17.05, 18.22, 19.25, 18.50, 18.28]
                    }, {
                        name: '设备',
                        data: [16.28, 18.09, 16.99, 15.11, 16.02, 19.46, 17.46, 15.14, 16.49, 18.17, 18.50, 17.21, 15.76, 17.07, 16.03, 14.21, 15.71, 20.22, 19.92, 14.16, 15.28, 14.71, 14.75, 15.87, 12.62, 15.95, 13.61, 17.35, 16.82, 19.89, 20.43]
                    }, {
                        name: '动力',
                        data: [17.20, 19.00, 15.60, 17.17, 19.25, 17.03, 17.46, 15.14, 16.49, 18.17, 16.55, 17.21, 15.76, 19.38, 17.48, 13.66, 13.42, 15.32, 13.23, 17.10, 12.91, 15.02, 14.16, 19.07, 18.77, 18.09, 17.91, 20.85, 17.90, 16.55, 12.60]
                    }, {
                        name: '其他',
                        data: [15.21, 12.46, 13.51, 13.05, 16.02, 15.62, 15.36, 17.03, 16.09, 13.09, 13.35, 18.05, 16.05, 16.94, 18.79, 18.34, 16.20, 12.95, 13.51, 16.41, 18.74, 18.89, 16.39, 15.22, 15.23, 13.49, 13.90, 13.85, 17.90, 13.77, 19.20]
                    }
                ]
            };

            $scope.export = function(){
                html2pdf.export($("#export-container"), 'Report.Consumption.Trends');
            }
        }
    ])
},{}],31:[function(require,module,exports){
angular.module('app.controllers.reports.daily', ['ui.bootstrap'])
    .controller('reportsDailyCtrl', [
        '$scope', '$rootScope', '$http', 'AllMetersService', 'WeatherFactory', 'EnergyUnitFactory', 'LanguageFactory', 'html2pdf', '$timeout', 'platform',
        function($scope, $rootScope, $http, AllMetersService, WeatherFactory, EnergyUnitFactory, LanguageFactory, html2pdf, $timeout, platform) {

            $scope.colorPeak = 'rgba(255, 0, 0, .1)';
            $scope.colorShoulder = 'rgba(0, 255, 0, .1)';
            $scope.colorValley = 'rgba(0, 0, 255, .1)';

            $scope.colorElectric = ['rgba(125, 0, 255, 1)', 'rgba(255, 0, 255, 1)', 'rgba(255, 0, 0, 1)', 'rgba(255, 128, 0, 1)', 'rgba(0, 255, 0, 1)', 'rgba(0, 0, 255, 1)', 'rgba(0, 128, 128, 1)'];
            $scope.colorWeather = 'rgba(125, 125, 255, 1)';
            $scope.colorHumidity = 'rgba(50, 200, 152, 1)';
            
            // Indicators binding variable
            $scope.stats = {};
            // $scope.dt = Date.now();
            var today = new Date();
            var dd = today.getDate();
            var mm = today.getMonth(); //January is 0!
            var yyyy = today.getFullYear();
            $scope.dt = new Date(yyyy, mm, dd, 0, 0, 0, 0);
            // Series: Hourly = 0, Daily = 1, Monthly = 2
            $scope.serieType = 1;
            $scope.totalUsageToday = 55.23;
            $scope.percentFromYesterday = 3.0;
            $scope.upDownImage = "up";

            $scope.setupConfigBasedOnMonths = function (month)
            {
                if(month >=6 && month < 9)
                {// If Summer, July to Sep
                    $scope.hoursPeak = [8, 9, 10, 13, 14, 18, 19, 20];
                    $scope.hoursShoulder = [6, 7, 11, 12, 15, 16, 17, 21];
                    $scope.hoursValley = [0, 1, 2, 3, 4, 5, 22, 23];
                    $scope.dollarRatioPeak = 1.231;
                    $scope.dollarRatioShoulder = 0.769;
                    $scope.dollarRatioValley = 0.292;

                    $scope.backgroundColorsForChart1 = [{ from: -0.5, to: 5.5, color: $scope.colorValley },
                                { from: 5.5, to: 7.5, color: $scope.colorShoulder },
                                { from: 7.5, to: 10.5, color: $scope.colorPeak },
                                { from: 10.5, to: 12.5, color: $scope.colorShoulder},
                                { from: 12.5, to: 14.5, color: $scope.colorPeak },
                                { from: 14.5, to: 17.5, color: $scope.colorShoulder},
                                { from: 17.5, to: 20.5, color: $scope.colorPeak},
                                { from: 20.5, to: 21.5, color: $scope.colorShoulder},
                                { from: 21.5, to: 23.5, color: $scope.colorValley}];
                }
                else
                {
                    $scope.hoursPeak = [8, 9, 10, 18, 19, 20];
                    $scope.hoursShoulder = [6, 7, 11, 12, 13, 14, 15, 16, 17, 21];
                    $scope.hoursValley = [0, 1, 2, 3, 4, 5, 22, 23];

                    $scope.dollarRatioPeak = 1.196;
                    $scope.dollarRatioShoulder = 0.734;
                    $scope.dollarRatioValley = 0.357;

                    $scope.backgroundColorsForChart1 = [{ from: -0.5, to: 5.5, color: $scope.colorValley },
                                { from: 5.5, to: 7.5, color: $scope.colorShoulder },
                                { from: 7.5, to: 10.5, color: $scope.colorPeak },
                                { from: 10.5, to: 17.5, color: $scope.colorShoulder},
                                { from: 17.5, to: 20.5, color: $scope.colorPeak},
                                { from: 20.5, to: 21.5, color: $scope.colorShoulder},
                                { from: 21.5, to: 23.5, color: $scope.colorValley}];

                }
            };

            $scope.setupConfigBasedOnMonths(mm);

            //


            // Mockup data for properties panel
            $scope.properties = [
            { name: '日内最低小时能耗(Hourly Min)：', alias: '日内最低小时能耗(Hourly Min)', value: "" },
            { name: '日内最高小时能耗(Hourly Max):', alias: '日内最高小时能耗(Hourly Max)', value: "" },
            { name: '显示时段日平均能耗(Daily Average)', alias: '显示时段日平均能耗(Daily Average)', value: "" },
            { name: '系统负载因数 (Load Factor):', alias: '系统负载因数 (Load Factor)', value: "" },
            { name: '高峰用电百分比(Peak Energy %):', alias: '高峰用电百分比(Peak Energy %)', value: "" },
            ];

            $scope.dateChanged = function()
            {
                console.log($scope.dt);
                $scope.switchSerie($scope.dt);
            };



            $scope.seriesData = [];
            $scope.seriesElectric = [];
            $scope.seriesWeather = {
                        name: 'Temperature',
                        type: 'spline',
                        tooltip: {
                            valueSuffix: '°C'
                        },
                        color:$scope.colorWeather,
                        yAxis: 1,
                        data: [83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3, 83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3]

                    };
            $scope.seriesHumidity = {
                        name: 'Humidity',
                        type: 'spline',
                        tooltip: {
                            valueSuffix: ' %'
                        },
                        color:$scope.colorHumidity,
                        yAxis: 2,
                        data: [106.6, 92.3, 83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3, 83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5]
                    };

            // Switch between hourly / daily / monthly series
            $scope.switchSerie = function(date) {
                var params = { hour: false, month: false };

                var todayTime = date.getTime();
                var startTime = todayTime - 3600 * 24 * 1000;// / 1000;
                var endTime = todayTime + 3600 * 24 * 1000;

                var mmm = date.getMonth();

                // if(mmm >=6 && mmm < 9)
                // {// If Summer, July to Sep
                //     $scope.hoursPeak = [8, 9, 10, 13, 14, 18, 19, 20];
                //     $scope.hoursShoulder = [6, 7, 11, 12, 15, 16, 17, 21];
                //     $scope.hoursValley = [0, 1, 2, 3, 4, 5, 22, 23];
                //     $scope.dollarRatioPeak = 1.231;
                //     $scope.dollarRatioShoulder = 0.769;
                //     $scope.dollarRatioValley = 0.292;
                //
                //     $scope.backgroundColorsForChart1 = [{ from: -0.5, to: 5.5, color: $scope.colorValley },
                //                 { from: 5.5, to: 7.5, color: $scope.colorShoulder },
                //                 { from: 7.5, to: 10.5, color: $scope.colorPeak },
                //                 { from: 10.5, to: 12.5, color: $scope.colorShoulder},
                //                 { from: 12.5, to: 14.5, color: $scope.colorPeak },
                //                 { from: 14.5, to: 17.5, color: $scope.colorShoulder},
                //                 { from: 17.5, to: 20.5, color: $scope.colorPeak},
                //                 { from: 20.5, to: 21.5, color: $scope.colorShoulder},
                //                 { from: 21.5, to: 23.5, color: $scope.colorValley}];
                // }
                // else
                // {
                //     $scope.hoursPeak = [8, 9, 10, 18, 19, 20];
                //     $scope.hoursShoulder = [6, 7, 11, 12, 13, 14, 15, 16, 17, 21];
                //     $scope.hoursValley = [0, 1, 2, 3, 4, 5, 22, 23];
                //
                //     $scope.dollarRatioPeak = 1.196;
                //     $scope.dollarRatioShoulder = 0.734;
                //     $scope.dollarRatioValley = 0.357;
                //
                //     $scope.backgroundColorsForChart1 = [{ from: -0.5, to: 5.5, color: $scope.colorValley },
                //                 { from: 5.5, to: 7.5, color: $scope.colorShoulder },
                //                 { from: 7.5, to: 10.5, color: $scope.colorPeak },
                //                 { from: 10.5, to: 17.5, color: $scope.colorShoulder},
                //                 { from: 17.5, to: 20.5, color: $scope.colorPeak},
                //                 { from: 20.5, to: 21.5, color: $scope.colorShoulder},
                //                 { from: 21.5, to: 23.5, color: $scope.colorValley}];
                //
                // }
                $scope.setupConfigBasedOnMonths(mmm);

                $timeout(function(){

                    AllMetersService.load($rootScope.$stateParams.id,todayTime,endTime,{interval:"60m","disagg":"all"}).then(function(data) {

                        if(data && data.length > 0)
                        {
                            var seriesData = [];

                            var todayEnergy = 0;
                            var peakDemandOfDay = 0;

                            var energyPeak = 0;
                            var energyShoulder = 0;
                            var energyValley = 0;

                            var energyPeakDollar = 0;
                            var energyShoulderDollar = 0;
                            var energyValleyDollar = 0;

                            var k = 0;
                            $scope.seriesElectric = [];
                            $scope.seriesDollar = [];

                            var chart3SeriesData = [];

                            var totalSeries = [];
                            var minEnergy = 1000000;
                            var maxEnergy = 0;
                            var avgEnergy = 0;

                            for(var i = 0; i < data.length; i++)
                            {
                                var points = data[i].points;
                                var tm = 0;
                                var singleData = [];
                                var singleDataDollar = [];

                                var subTotal = 0;

                                for(k = points.length - 1; k >= 0; k--)
                                {
                                    tm = points[k][0];
                                    var curIndex = singleData.length;

                                    if($scope.hoursPeak.includes(curIndex))
                                    {
                                        energyPeak += points[k][1];
                                        energyPeakDollar += points[k][1] * $scope.dollarRatioPeak;
                                        singleDataDollar.push(points[k][1] * $scope.dollarRatioPeak);
                                    }
                                    if($scope.hoursShoulder.includes(curIndex))
                                    {
                                        energyShoulder += points[k][1];
                                        energyShoulderDollar += points[k][1] * $scope.dollarRatioShoulder;
                                        singleDataDollar.push(points[k][1] * $scope.dollarRatioShoulder);
                                    }
                                    if($scope.hoursValley.includes(curIndex))
                                    {
                                        energyValley += points[k][1];
                                        energyValleyDollar += points[k][1] * $scope.dollarRatioValley;
                                        singleDataDollar.push(points[k][1] * $scope.dollarRatioValley);
                                    }

                                    singleData.push(points[k][1]);
                                    todayEnergy += points[k][1];
                                    subTotal += points[k][1];



                                    if(i == 0)
                                    {
                                        totalSeries.push(points[k][1]);
                                    }
                                    else
                                    {
                                        if(totalSeries.length > k)
                                        {
                                            totalSeries[curIndex] = totalSeries[curIndex] + points[k][1];
                                        }

                                    }

                                    if(i == (data.length - 1))
                                    {
                                        if(maxEnergy < totalSeries[curIndex])
                                        {
                                            maxEnergy = totalSeries[curIndex];
                                        }
                                        if(minEnergy > totalSeries[curIndex])
                                        {
                                            minEnergy = totalSeries[curIndex];
                                        }
                                        avgEnergy += totalSeries[curIndex];
                                    }
                                }
                                avgEnergy = avgEnergy / data[0].points.length;

                                chart3SeriesData.push({name: data[i].usage, color: $scope.colorElectric[seriesData.length], y: subTotal});

                                var singleSerie = {name: data[i].usage, color: $scope.colorElectric[seriesData.length], tooltip: { valueSuffix: 'KW'}, type: 'column', yAxis: 0, data: singleData};
                                var dollarSerie = {name: data[i].usage, color: $scope.colorElectric[seriesData.length], tooltip: { valueSuffix: '$$'}, type: 'column', yAxis: 0, data: singleDataDollar};

                                seriesData.push(singleSerie);
                                $scope.seriesElectric.push(singleSerie);
                                $scope.seriesDollar.push(dollarSerie);
                            }

                            $scope.properties = [
                            { name: '日内最低小时能耗(Hourly Min)：', alias: '日内最低小时能耗(Hourly Min)', value: minEnergy.toFixed(2) },
                            { name: '日内最高小时能耗(Hourly Max):', alias: '日内最高小时能耗(Hourly Max)', value: maxEnergy.toFixed(2) },
                            { name: '显示时段日平均能耗(Daily Average)', alias: '显示时段日平均能耗(Daily Average)', value: avgEnergy.toFixed(2) },
                            { name: '系统负载因数 (Load Factor):', alias: '系统负载因数 (Load Factor)', value: (avgEnergy / maxEnergy).toFixed(2) },
                            { name: '高峰用电百分比(Peak Energy %):', alias: '高峰用电百分比(Peak Energy %)', value: (energyPeak / todayEnergy).toFixed(2) },
                            ];
                            $scope.totalUsageToday = todayEnergy;

                            $scope.seriesData = seriesData;
                            $scope.seriesData.push($scope.seriesWeather);
                            $scope.seriesData.push($scope.seriesHumidity);

                            $scope.chartOptions1.series = $scope.seriesData;
                            $scope.chartOptions1.options.xAxis.plotBands = $scope.backgroundColorsForChart1;

                            $scope.chartOptions2.series[0].data = [energyShoulder, 0];
                            $scope.chartOptions2.series[1].data = [0, energyShoulderDollar];// using 0.89 as fixed conversion rate for now
                            $scope.chartOptions2.series[2].data = [energyPeak, 0];
                            $scope.chartOptions2.series[3].data = [0, energyPeakDollar];// using 0.89 as fixed conversion rate for now
                            $scope.chartOptions2.series[4].data = [energyValley, 0 ];
                            $scope.chartOptions2.series[5].data = [0, energyValleyDollar];// using 0.89 as fixed conversion rate for now


                            $scope.chartOptions3.series[0].data = chart3SeriesData;// using 0.89 as fixed conversion rate for now
                        }
                        
                    });

                    WeatherFactory.get($rootScope.$stateParams.id,todayTime,endTime).then(function(data) {
                        // return;
                        // var series1Data = [];
                        if(data && data.length > 0)
                        {
                            var series1Data = [];
                            var series2Data = [];
                            var points = data;
                            for (var k = 0; k < points.length; k++) {
                                series1Data.push(points[k][1]);
                                series2Data.push(points[k][2]);
                            }

                            $scope.seriesWeather.data = series1Data;
                            $scope.seriesHumidity.data = series2Data;

                            $scope.seriesData = [];
                            for(var j=0; j < $scope.seriesElectric.length; j++)
                            {
                                $scope.seriesData.push($scope.seriesElectric[j]);
                            }

                            $scope.seriesData.push($scope.seriesWeather);
                            $scope.seriesData.push($scope.seriesHumidity);
                            $scope.chartOptions1.series = $scope.seriesData;
                        }
                    });

                }, 0);

            }


            $scope.chartOptions1 = {
                options: {
                    chart: {
                        zoomType: 'xy'
                        // type: 'column', panning: true, margin: [55, 0, 0, 0]
                    },
                    title: null,
                    xAxis: {
                        categories: ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12',
                            '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'
                        ],
                        crosshair: true,
                        gridLineWidth: 0,
                        plotBands: $scope.backgroundColorsForChart1
                    },
                    yAxis: [{
                        lineColor: '#00ffff',
                        labels: { format: '{value} KW', style: { color: Highcharts.getOptions().colors[1]} },//x: 10, y: -5,
                        title: { text: 'Electricity', style: { color: Highcharts.getOptions().colors[1] } },//{ text: '能源效率' },
                        opposite: false,
                    },
                        {
                        // lineWidth: 0,
                        lineColor: '#fff',
                        labels: { format: '{value}°C',  style: { color: Highcharts.getOptions().colors[1]} },//x: 10, y: -5,
                        title: { text: 'Temperature', style: { color: Highcharts.getOptions().colors[1] } },//{ text: '能源效率' },
                        opposite: true,visible:false
                    },{
                        // lineWidth: 0,
                        lineColor: '#fff',
                        labels: { format: '{value} %',  style: { color: Highcharts.getOptions().colors[1]} },//x: 10, y: -5,
                        title: { text: 'Humidity', style: { color: Highcharts.getOptions().colors[1] } },//{ text: '能源效率' },
                        opposite: true, visible: false
                    }
                    ],

                    legend: {
                        layout: 'vertical',
                        align: 'left',
                        x: 120,
                        verticalAlign: 'top',
                        y: 20,
                        floating: true,
                        backgroundColor: (Highcharts.theme && Highcharts.theme.legendBackgroundColor) || '#FFFFFF'
                    },
                    tooltip: {
                        // headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
                        // pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' +
                        //     '<td style="padding:0"><b>{point.y:.1f} </b></td></tr>',
                        // footerFormat: '</table>',
                        shared: true,
                        // useHTML: true
                    },
                    plotOptions: {
                        column: {
                            pointPadding: 0.2,
                            borderWidth: 0,
                            stacking: 'normal',
                        }
                    }
                },
                series: [
                    {
                        name: 'A',
                        tooltip: {
                            valueSuffix: 'KW'
                        },
                        type: 'column',
                        yAxis: 0,
                        data: [144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2]

                    },
                    {
                        name: 'B',
                        tooltip: {
                            valueSuffix: 'KW'
                        },
                        type: 'column',
                        yAxis: 0,
                        data: [135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2, 144.0, 176.0]

                    },
                    {
                        name: 'C',
                        tooltip: {
                            valueSuffix: 'KW'
                        },
                        type: 'column',
                        yAxis: 0,
                        data: [129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4]

                    },
                    {
                        name: 'Electricity',
                        tooltip: {
                            valueSuffix: 'KW'
                        },
                        type: 'column',
                        yAxis: 0,
                        data: [216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4, 49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5]
                    },
                    {
                        name: 'Temperature',
                        type: 'spline',
                        tooltip: {
                            valueSuffix: '°C'
                        },
                        // showInLegend: false,
                        yAxis: 1,
                        data: [83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3, 83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3]

                    }, {
                        name: 'Humidity',
                        type: 'spline',
                        tooltip: {
                            valueSuffix: ' %'
                        },
                        // showInLegend: false,
                        yAxis: 2,
                        data: [106.6, 92.3, 83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3, 83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5]

                    }
                ]
            };

            $scope.chartOptions2 = {

                chart: {
                    type: 'column',
                },


                title: {
                    text: 'Electricity Usage in Peak, Shoulder, Valley'
                },

                xAxis: {
                        categories: ['KWH', '$$'],crosshair: true
                },
                yAxis: [{
                    lineColor: '#00ffff',
                    labels: { format: '{value} KW',  style: { color: Highcharts.getOptions().colors[1]} },x: 10, y: -5,
                    title: { text: 'Electricity', style: { color: Highcharts.getOptions().colors[1] } },//{ text: '能源效率' },
                    opposite: false,
                    // showLastLabel: false,
                    // maxPadding:10.0
                },{
                    lineColor: '#fff',
                    labels: { format: '{value} $', style: { color: Highcharts.getOptions().colors[1]} },//x: 10, y: -5,
                    title: { text: 'Dollar', style: { color: Highcharts.getOptions().colors[1] } },//{ text: '能源效率' },
                    opposite: true,
                    // showLastLabel: false,
                    // maxPadding:10.0
                }
                ],

                tooltip: {
                    formatter: function () {
                        return '<b>' + this.series.xAxis.categories[this.point.x] + '</b> sold <br><b>' +
                            this.point.value + '</b> items on <br><b>' + this.series.yAxis.categories[this.point.y] + '</b>';
                    }
                },
                legend: {
                    // floating: true,
                    enabled: false
                },
                series: [
                    {
                    name: 'Shoulder',
                    type: 'column',
                    data: [149.9, 0],
                        yAxis: 0,
                        showInLegend: false,
                        pointWidth: 30
                },
                    {
                    name: 'Shoulder',
                    type: 'column',
                    data: [0, 53.0],
                        yAxis: 1,
                        showInLegend: false,
                        pointWidth: 30
                },
                    {
                    name: 'Peak',
                    type: 'column',
                    data: [183.6, 0],
                        yAxis: 0,
                        showInLegend: false,
                        pointWidth: 30

                },
                    {
                    name: 'Peak',
                    type: 'column',
                    data: [0, 78.8],
                        yAxis: 1,
                        showInLegend: false,
                        pointWidth: 30

                },
                    {
                    name: 'Valley',
                    type: 'column',
                    data: [148.9,0],
                        yAxis: 0,
                        showInLegend: false,
                        pointWidth: 30

                },
                    {
                    name: 'Valley',
                    type: 'column',
                    data: [0, 78.8],
                        yAxis: 1,
                        showInLegend: false,
                        pointWidth: 30
                },
                ]

            };


            $scope.chartOptions3 = {
                chart: {
                    plotBackgroundColor: null,
                    plotBorderWidth: null,
                    plotShadow: false,
                    type: 'pie'
                },
                title: {
                    text: 'Energy usage for the day'
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'
                },
                plotOptions: {
                    pie: {
                        allowPointSelect: true,
                        cursor: 'pointer',
                        dataLabels: {
                            enabled: true,
                            format: '<b>{point.name}</b>: {point.percentage:.1f} %',
                            style: {
                                color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black'
                            }
                        }
                    }
                },
                dataLabels: {
                            enabled: true,
                            format: '<b>{point.name}</b>: {point.percentage:.1f} %',
                            style: {
                                color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black'
                            }
                        },
                series: [{
                    name: 'Electricity Usage(%)',
                    type: 'pie',
                    colorByPoint: true,
                    data: [{
                        name: 'Computer',
                        y: 56.33
                    }, {
                        name: 'Air Conditioner',
                        y: 24.03,
                        sliced: true,
                        selected: true
                    }, {
                        name: 'Freezer',
                        y: 10.38
                    }, {
                        name: 'Water boiler',
                        y: 4.77
                    }, {
                        name: 'Light',
                        y: 0.91
                    }, {
                        name: 'Other',
                        y: 0.2
                    }]
                }]
            };
        }
    ])

},{}],32:[function(require,module,exports){
angular.module('app.controllers.reports.disagg', [])
    .controller('reportsDisaggCtrl', [
        '$scope', '$rootScope', '$http', 'EnergyUnitFactory', '$window', '$timeout', 'html2pdf','seriesService','UtilityService', function($scope, $rootScope, $http, EnergyUnitFactory, $window, $timeout, html2pdf,seriesService,UtilityService) {
            
            $scope.indicators = {}

	    var month_indicators= { "lighting":{max:100,min:0,value:50, label:"照明用电"}, "plug": {max:100,min:0,value:50, label:"设备与插座"}, "heating": {max:120,min:0,value:50, label:"取暖用电"}, "motor": {max:100,min:0,value:50, label:"动力用电"}, "cooling": {max:241,min:0,value:50, label:"空调制冷"}, "misc": {max:60,min:0,value:50, label:"特殊用电"}};

	    var year_indicators = { "lighting":{max:300,min:200,value:50, label:"照明用电"}, "plug": {max:300,min:200,value:50, label:"设备与插座"}, "heating": {max:300,min:100,value:50, label:"取暖用电"}, "motor": {max:100,min:0,value:50, label:"动力用电"}, "cooling": {max:241,min:0,value:50, label:"空调制冷"}, "misc": {max:600,min:0,value:300, label:"特殊用电"}};

            $scope.year= "0";
	    $scope.items = [[], [], []]

            var ready;
	    var temp_hash = {
		"mechanics": "motor",
		"hvac": "heating",
		"misc": "misc",
		"lighting_plug": "lighting",
		"plug": "plug",
		"cooling": "cooling"
	    }
            var hash={ '照明用电': 'lighting',
                       '设备与插座': 'plug',
                       '取暖用电': 'heating',
                       '动力用电': 'motor',
                       '空调制冷': 'cooling',
                       '特殊用电': 'misc'}
            
            if ($rootScope.$stateParams.id > 0) {
                ready=EnergyUnitFactory.getDetail($rootScope.$stateParams.id).then(function(buildingDetail) {
                    $scope.energysystemintro = (buildingDetail.objects[0] || {}).energysystemintro;
                    $scope.buildingDetail = buildingDetail.objects[0]||{};
                    //highcharts-redraw directive doesn't trigger for some reason, re-sizing this way for now
                    $timeout(function() { $scope.highchartsNG.getHighcharts().reflow(); });
                })
            }

            $scope.updateChart=function(){
		var startDate;
		var endDate = moment();
		
		$scope.indicators = year_indicators
		if($scope.year == "0"){ 	// past 30 days
		    var startDate = moment(moment()).subtract(1, 'month').valueOf();
		    $scope.indicators = month_indicators
		}else if($scope.year == "1"){	// year to date
		    var date = new Date(endDate);
		    var startDate = Math.round(new Date(date.getFullYear() + "/01/01 00:00:00").getTime())
		    console.log(date.getFullYear() + "/01/01 00:00:00")
		}else if($scope.year == "2"){	// past 12 months
		    var startDate = moment(moment()).subtract(1, 'year').valueOf();
		}else{				// past 12~24 months
		    var startDate = moment(moment()).subtract(2, 'year').valueOf();
		    var endDate = moment(moment()).subtract(1, 'year').valueOf();
		}

                $scope.items = [[], [], []]
                ready.then(function(){
                    seriesService.load($rootScope.$stateParams.id,startDate,endDate,{interval:"auto",disagg:"all"}).then(function(result){
                        var series=result;
                        topLevelData=[];

			$scope.item_index = 1

                        if(result.length==1){
                            topLevelData=[];
                            $scope.indicators={
                               'lighting': {value:0},
                               'plug': {value:0},
                               'heating':{value:0},
                               'motor': {value:0},
                               'cooling': {value:0},
                               'misc': {value:0}
                            }

                        }else{
			    angular.forEach($scope.indicators, function(v, k) {
				$scope.indicators[k]["value"] = 0
			    })

                            for(var i=0;i<series.length;i++){

                                var sdata=series[i];
                                if(sdata['name']=='总能耗')continue;
                                var data=(sdata.points||[]).reverse();
                                var energy= UtilityService.getAreaUnderCurve(data);
                                var progress=temp_hash[sdata.usage||""];
                                if(progress){
                                    var area=parseInt($scope.buildingDetail.buildingarea);
                                    if(area&&$scope.indicators[progress]){
                                        $scope.indicators[progress]['value']=(energy/area-$scope.indicators[progress]['min'])/($scope.indicators[progress]['max']-$scope.indicators[progress]['min'])*100;
                                    }

                                }
                                topLevelData.push({
                                name: sdata.usage||"",
                                y: energy,
                                //id: i,
                                //color: data[i].color
                                });
                            }

			    var index = 0
			    angular.forEach($scope.indicators, function(v, k) {
				if($scope.indicators[k]["value"] != 0){
				    console.log($scope.items[Math.floor(index/2)])
				    $scope.items[Math.floor(index/2)].push($scope.indicators[k])
				    index += 1
				}
			    })

			    console.log(JSON.stringify($scope.items))
                        }


                        $timeout(function(){
                            //angular.element($window).triggerHandler('resize');
                            $scope.highchartsNG.series[0].data=topLevelData;
                            $rootScope.resize();
                        },1000);

                    })
                });

            }


            $scope.highchartsNG = {
                options: {
                    chart: {
                        type: 'pie',
                        margin: 0,
                        spacing: 0,
                        padding: 0,
                        options3d: {
                            enabled: true,
                            alpha: 45,
                            beta: 0
                        },
                    },
                    title: { text: '' },
                    tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
                    legend: { enabled: false }, 
                    dataLabels: { enabled: false },
                    plotOptions: {
                        labels: { enabled: false },
                        pie: { size: '100%', innerSize: '50%', depth: 45, allowPointSelect: true, cursor: 'pointer', showInLegend: false, dataLabels: { enabled: false } },
                        series: {
                            point: {
                                events: {
                                    click: function(){
                                        var that = this;
                                        var data = $scope.highchartsNG.series[0].data;
                                            $.each(data, function(i, point) {
                                                $scope.$apply(function(){

                                                    point.selected = false;
                                                    if(point.name == that.name){
                                                        point.selected = true;
                                                        point.selectedColor = that.color;
                                                    }
                                                    

                                                });

                                            });

                                    },
                                    // legendItemClick: function() {
                                    //     var id = this.id;
                                    //     var data = this.series.chart.series[1].data;
                                    //     $.each(data, function(i, point) {

                                    //         if (point.parentId == id) {
                                    //             if (point.visible)
                                    //                 point.setVisible(false);
                                    //             else
                                    //                 point.setVisible(true);
                                    //         }

                                    //     });
                                    // }
                                }
                            }

                        }
                    },

                    credits: {
                        enabled: false
                    }
                },
                series: [
                    {
                        type: 'pie',
                        name: "Source",
                        colorByPoint: true,
                        size: '100%',
                        data: [],
                        dataLabels: { enabled: false, style: { width: '150px' }, color: '#6e6e6e', distance: 10, style: { "fontSize": "14px" }, format: '<b>{point.name}</b>: {point.percentage:.1f} %' }
                    }
                    //, {
                    //    type: 'pie',
                    //    name: "Sub-source",
                    //    colorByPoint: true,
                    //    size: '80%',
                    //    innerSize: '60%',
                    //    data: subLevelData,
                    //    showInLegend: false
                    //}
                ],
                loading: false
            };

            $scope.updateChart();

        }
    ])

},{}],33:[function(require,module,exports){
angular.module('app.controllers.reports.heatmap', [])

    .controller('reportsHeatmapCtrl', [
        '$scope', '$rootScope', 'AllMetersService', 'UtilityService', 'WeatherFactory', '$q', 'html2pdf', '$timeout', function($scope, $rootScope, AllMetersService, UtilityService, WeatherFactory, $q, html2pdf, $timeout) {


            $scope.highchartsNG = {
                options: {
                    chart: { animation: true, panning: true,  plotBorderWidth: 0,  margin: [55, 0, 0, 0], backgroundColor: '#fff',
                                events: { 
                                    redraw: function(){
                                        console.log('redraw');
                                    }
                                } 
                    },
                    title: { text: '' },
                    xAxis: {
                        animation: true,
                        type: 'datetime',
                        // min: Date.UTC(2013, 0, 1),
                        // max: Date.UTC(2016, 0, 1),

                        minorTickWidth: 1,
                        minorTickLength: 5,
                        minorTickColor: '#ccc',
                        minorGridLineWidth: 0,
                        
                        tickWidth: 1,
                        tickLength: 10,
                        tickColor: '#ccc',
                        gridLineWidth: 0,

                        lineWidth:0,
                        lineColor: "#ccc",

                        opposite: true,


                        labels: {
                            rotation: 0, 
                            align: 'center', 
                            y: -25, 
                            autoRotation: false,                            
                            //format: '{value:%B}', // long month
                            formatter: function(args)
                            {
                                var min = this.axis.min;
                                var max = this.axis.max;

                                var diffHours = moment(max).diff(moment(min), 'hours');

                                if(diffHours < 24 * 90)
                                {
                                    this.value = moment(this.value).format('MMM<br /><br />D');
                                }
                                else
                                {
                                    this.value = moment(this.value).format('MMM');
                                }

                                return this.value; 
                            },
                        },

                        showFirstLabel:true,
                        showLastLabel: true,
                        //tickLength: 16,
                        //tickInterval: 30 * 24 * 3600 * 1000
                    },

                    yAxis: [
                        {
                            minorGridLineWidth: 0,

                            showLastLabel: false,
                            labels: {
                                align: 'left', x: 10, y: -5,
                            },
                            title: null,
                            height: '35%',
                            //offset: 0,
                            title: "HDD/CDD",
                            startOnTick: true,
                            endOnTick: true,
                            align: 'right', x: 0, y: -3                            
                        }, {

                            minorGridLineWidth: 0,
                            animation: true,
                            minorGridLineWidth: 0,
                            opposite: false,
                            showFirstLabel: false,
                            height: '65%',
                            top: '35%',
                            title: {
                                text: "Time"
                            },
                            labels: {
                                align: 'left', x: 10, y: -5,
                                format: '{value}:00'
                            },
                            // tooltip: {
                            //     headerFormat: 'Energy Usage<br/>',
                            //     formatter: function() {
                            //         return '{point.x:%e %b, %Y} {point.y}:00: <b>' +
                            //             this.y == null ? 'null' : '{point.value:.2f} kWh' +
                            //             '</b>';
                            //     }
                            // },
                            minPadding: 0,
                            maxPadding: 0,
                            startOnTick: false,
                            endOnTick: false,
                            tickPositions: [0, 6, 12, 18, 23], // <-- heat max serie data value 23:00, 24 creates whitespace
                            tickWidth: 1,
                            min: 0,
                            max: 23, // <-- see comment above
                            reversed: true
                        }
                    ],

                    legend: { symbolWidth: 300 },
                    
                    colorAxis: {
                        stops: [
                            [0, '#0077FF'],
                            [0.5, '#F3FF00'],
                            //[0.9, '#c4463a'],
                            [1, '#FF0000']
                        ],
                        min: 0,
                        max: 25,
                        startOnTick: false,
                        endOnTick: false,
                        labels: {
                            format: '{value} kWh'
                        }
                    },
                    
                    plotOptions: {
                        areaspline: {
                            marker: { enabled : false }
                        }
                    },

                    // Individual series tooltip formatter doesn't work for some reason, here is workaround
                    tooltip: {
                        crosshairs: [true,true],
                        headerFormat: 'Energy Usage<br/>',
                        formatter: function() {
                            if (this.series.name == 'heatmap') {
                                var val = this.point.value == null ? '0' : Highcharts.numberFormat(this.point.value, '.2f');

                                return 'Energy Usage<br/>' + Highcharts.dateFormat('%e %b, %Y', this.point.x) + ' ' + this.point.y + ':00 <b>' + val + ' kWh</b>';
                            }
                            else
                                return this.series.name + '<br/><span style="color:' + this.point.series.color + '">\u25CF</span>: value: ' + this.point.y;
                        }
                    },
                    credits: false
                },
                series: [
                    {
                        type: 'heatmap',
                        name: 'heatmap',
                        yAxis: 1,
                        borderWidth: 0,
                        // tooltip: {
                        //     headerFormat: 'Temperature<br/>',
                        //     pointFormat: '{point.x:%e %b, %Y} {point.y}:00: <b>{point.value} ℃</b>'
                        // },
                        nullColor: '#EFEFEF',
                        colsize: 24 * 36e5, // one day
                        data: [],
                        turboThreshold: Number.MAX_VALUE // #3404, remove after 4.0.5 release
                    }, {
                        type: 'areaspline',
                         name: 'CDD',
                         yAxis: 0,
                         showInLegend: false,
                         color: 'blue',
                        data: []
                        //data:[[new Date('2015-01-01').getTime(),1],[new Date('2015-01-02').getTime(),9],[new Date('2015-02-01').getTime(),2],[new Date('2015-03-01').getTime(),15],[new Date('2015-011-01').getTime(),20]]
                    }, {
                        type: 'areaspline',
                         name: 'HDD',
                         yAxis: 0,
                         showInLegend: false,
                         color: 'red',
                        // showInLegend: false,
                        data: []
                        //data:[[new Date('2015-01-01').getTime(),1],[new Date('2015-01-02').getTime(),9],[new Date('2015-02-01').getTime(),2],[new Date('2015-03-01').getTime(),15],[new Date('2015-011-01').getTime(),20]]
                    }
                ]
            }
            $scope.year="1";

            var ticking = false;


            function update(data, summary){
                $scope.$apply(function(){
                    $scope.highchartsNG.series[0].data = data;
                    $scope.highchartsNG.series[1].data = summary.cdd;
                    $scope.highchartsNG.series[2].data = summary.hdd;
                    ticking = false;
                })

            };

            $scope.render = function (data, summary) {
                if(!ticking) {
                    requestAnimationFrame(function(){
                        return update(data, summary);
                    });
                    ticking = true;
                }
            }

            $scope.updateChart=function(){
                var year=parseInt($scope.year)||1;
                var startDate = moment().subtract(year, 'y').startOf('day').valueOf(); // year ago
                var endDate = moment().subtract(year-1, 'y').add(1, 'd').startOf('day').valueOf(); // end of today

                $q.all(
                    [
                        AllMetersService.load($rootScope.$stateParams.id, startDate, endDate,{interval:'30m'}),
                        WeatherFactory.get($rootScope.$stateParams.id,startDate, endDate)
                    ]
                ).then(function (result) {

                    var summary = WeatherFactory.hdd(20, result[1]);

                    result = result[0][0] || {};
                    var points = result.points || [];
                    points = points.reverse();

                    var monthlyEnergy = UtilityService.groupDataByTime(points, { hour: true }),
                        data = [],
                        min,
                        max;

                    var lastDate, totalMissing = 0;

                    monthlyEnergy.forEach(function(d) {
                        var token = d['time'].split(":");
                        var date = new Date(token[0]).getTime();
                        var time = parseInt(token[1]);

                        // Support for irregular interval
                        // Add null values for missing hours
                        if (!lastDate){
                            lastDate = moment(date).add(time, 'hours');
                        } else {
                            var current = moment(date).add(time, 'hours');
                            var diff = current.diff(lastDate, 'hours');
                            if (diff > 1) {
                                for (var i = 0; i < diff; i++) {
                                    lastDate.add({hours: 1});
                                    data.push([lastDate.clone().startOf('day').valueOf(), lastDate.hours(), null]);
                                }
                            }
                            lastDate = current;
                        }


                        data.push([date, time, d['total']]);

                        // Upper and lower extremes
                        if (!min || d['total'] < min) min = d['total'];
                        if (!max || d['total'] > max) max = d['total'];

                    })

                    var zoomStartDate = moment(endDate).subtract(3, 'month');
                    var canZoom = moment(zoomStartDate).isAfter(startDate);

                    $scope.highchartsNG.options.xAxis.min = canZoom ? zoomStartDate.valueOf() : startDate;
                    $scope.highchartsNG.options.xAxis.max = endDate;

                    //heatmap extremes
                    min = min || 0;
                    max = max || 25;

                    //Heatmap
                    $scope.highchartsNG.options.yAxis[1].min = 0;
                    $scope.highchartsNG.options.yAxis[1].max = 23;
                    $scope.highchartsNG.options.colorAxis.min = min;
                    $scope.highchartsNG.options.colorAxis.max = max;


                    $timeout(function(){

                        $scope.render(data, summary);
                    
                        
                    });

                })
            }
            if ($rootScope.$stateParams.id > 0) {
                $scope.updateChart();
            }

        }
    ]);



},{}],34:[function(require,module,exports){
require('./reports.nav.js');
require('./reports.summary.js');
require('./reports.daily.js');
require('./reports.consumption.js');
require('./reports.disagg.js');
require('./reports.monthly.js');
require('./reports.regular.js');
require('./reports.heatmap.js');
require('./reports.sankey.js');
require('./reports.alerts.js');

angular.module('app.controllers.reports', [
			'app.controllers.reports.nav',
			'app.controllers.reports.summary',
			'app.controllers.reports.daily',
			'app.controllers.reports.consumption',
			'app.controllers.reports.disagg',
			'app.controllers.reports.monthly',
			'app.controllers.reports.regular',
			'app.controllers.reports.heatmap',
			'app.controllers.reports.sankey',
			'app.controllers.reports.alerts'
		])

},{"./reports.alerts.js":29,"./reports.consumption.js":30,"./reports.daily.js":31,"./reports.disagg.js":32,"./reports.heatmap.js":33,"./reports.monthly.js":35,"./reports.nav.js":36,"./reports.regular.js":37,"./reports.sankey.js":38,"./reports.summary.js":39}],35:[function(require,module,exports){
angular.module('app.controllers.reports.monthly', [])
    .controller('reportsMonthlyCtrl', [
        '$scope', '$rootScope', '$http', 'AllMetersService', 'WeatherFactory', 'HelperService', '$filter', '$q', 'html2pdf', function($scope, $rootScope, $http, AllMetersService, WeatherFactory, HelperService, $filter, $q, html2pdf) {
            $scope.stats = {};

            if ($rootScope.$stateParams.id > 0) {
                //var p1 = AllMetersService.partitionedEnergyUse($rootScope.$stateParams.id, { month: true });
                var p2 = WeatherFactory.get($rootScope.$stateParams.id);
                $q.all([p2]).then(
                    function(result) {
			//to bind in html
                        //$scope.stats = result;
                        //set chart extreemes
                        var seriesData = result[0];
			
                        // var seriesData = result[0]['points'][0];
                        //$scope.chartOptions1.options.xAxis.categories = _.pluck(seriesData, "time");
                        var dataserie = _.find($scope.chartOptions1.series, function(d) {
                            return d.id == 'realdata'
                        });


                        //TODO: OPTIMIZE TEMP AND HUMIDITY MONTHLY GROUPING
                        //var monthly = $filter('groupBy')(result, function (record) { return new Date(record.date).getMonth(); });
                        // underscore groupby method for some reason works much faster
                        var condition = result[1] || [];
                        var monthly = _.groupBy(condition, function(d) {
                            var date = new Date(d[0]);
                            var month ="00"+ (date.getMonth() + 1);
                            var year = date.getFullYear();
                            return year + "/" + month.slice(-2); // ex: 2015/11

                        });
                        var weather = { temp: [], hum: [] };
                        angular.forEach(monthly, function(v, k) {
                            var tempSum = 0.0;
                            var tempHum = 0;

                            for (var j = 0; j < monthly[k].length; j++) {
                                tempSum += parseFloat(monthly[k][j][1]);
                                tempHum += parseFloat(monthly[k][j].hum);
                            }
                            weather.temp.push([new Date(k).getTime(),Math.round(tempSum / monthly[k].length)]);
                            weather.hum.push([new Date(k).getTime(),Math.round(tempHum / monthly[k].length)]);
                        });

                        var tempSerie = _.find($scope.chartOptions1.series, function(d) {
                            return d.id == 'temperature'
                        });

                        var humSerie = _.find($scope.chartOptions1.series, function(d) {
                            return d.id == 'humidity'
                        });

                        // Temperature series data
                        tempSerie.data = weather.temp;

                        // Humidity series data
                        humSerie.data = weather.hum;
			
   			
	
                    },
                    function(error) {
                        console.log(error);
                    }
                );

		var start = HelperService.toPyTime(moment().subtract(1, 'year').valueOf());
        	var end = HelperService.toPyTime(moment().valueOf());
		var data = { "isExternalRequest": "False", "time_format": "ms", "interval": "auto", "operation": "mean(value)", "building_id": $rootScope.$stateParams.id, "start_utc": start, "end_utc": end}

		$http.post("api/reports/monthly/"+$rootScope.$stateParams.id+"/", data).then(function (result) {
		    seriesData = result.data[0].points;

		    var dataserie = _.find($scope.chartOptions1.series, function(d) {
		            return d.id == 'realdata'
		        });
		
		    // Energy series data
                        var maxVal = 0;
                        dataserie.data = _.map(seriesData, function(d) {
                            var time = new Date(d[0]).getTime();
                            var value = d[1];
                            maxVal = maxVal > Math.ceil(value) ? maxVal : Math.ceil(value)
                            return [time, value];
                        });

			console.log(maxVal);
                        // Energy series friendly extremes
                        var nextN0 = Math.pow(10, maxVal.toString().length - 1);
                        var extreme = Math.ceil(maxVal / nextN0) * nextN0;

                        $scope.chartOptions1.options.yAxis[1].tickInterval = Math.ceil(extreme / 10); // limit to 10 gridlines
                        $scope.chartOptions1.options.yAxis[1].max = extreme;

			$scope.totalKWh = result.data[0].total_energy[0]
			$scope.totalCost = result.data[0].total_energy[1]
			$scope.totalKWh_m2 = result.data[0].energy_unit[0]
			$scope.totalCost_m2 = result.data[0].energy_unit[1]

			$scope.promote = result.data[0].promot[1]
			$scope.last_30_days = result.data[0].promot[0]
			if($scope.promote < 0)
				$scope.promote_icon = "down"

		},function(err){
		    console.log(err);
		});
                // WeatherFactory.get().then(
                //     function (result) {

                //         //TODO: OPTIMIZE TEMP AND HUMIDITY MONTHLY GROUPING
                //         //var monthly = $filter('groupBy')(result, function (record) { return new Date(record.date).getMonth(); });
                //         // underscore groupby method for some reason works much faster
                //         var monthly=_.groupBy(result,function(d){
                //             var date=new Date(d.date);
                //             var day=date.getDate();
                //             var month=(date.getMonth()+1);
                //             var year = date.getFullYear();
                //             return year + "/" + month; // ex: 2015/11

                //         });


                //         var weather = { temp: [], hum: [] };

                //         angular.forEach(monthly, function (v, k) {
                //             var tempSum = 0.0;
                //             var tempHum = 0;

                //             for (var j = 0; j < monthly[k].length; j++) {
                //                 tempSum += parseFloat(monthly[k][j].tempm);
                //                 tempHum += parseFloat(monthly[k][j].hum);
                //             }
                //             weather.temp.push(Math.round(tempSum / monthly[k].length));
                //             weather.hum.push(Math.round(tempHum / monthly[k].length));
                //         });

                //         var tempSerie = _.find($scope.chartOptions1.series, function (d) {
                //             return d.id == 'temperature'
                //         });

                //         var humSerie = _.find($scope.chartOptions1.series, function (d) {
                //             return d.id == 'humidity'
                //         });

                //         tempSerie.data = weather.temp;
                //         humSerie.data = weather.hum;
                //     },
                //     function(error) {
                //         console.log(error);
                //     }
                // );

            } else {
		
		$scope.chartOptions1 = $scope.chartDetailBar
		$scope.chartOptions2 = $scope.chartDetailPie

            }

	    // get Total KWh and Total cost
	    $scope.totalKWh = 0	
	    $scope.totalCost = 0		

	    // get Total KWh/m2 and Total cost/m2
	    $scope.totalKWh_m2 = 0	
	    $scope.totalCost_m2 = 0

	    $scope.promote = 0
	    $scope.last_30_days = 0
	    $scope.promote_icon = "up"

	    $scope.chartOptions1 = {
                options: {
                    chart: { alignTicks: false, panning: true, margin: [55, 0, 0, 0] },
                    title: null, //{ text: '_', style: { 'color': 'white' } },
                        
                    xAxis: { 
                        type: 'datetime', 
                        opposite: true,
                        minorTickWidth: 1,
                        minorTickLength: 5,
                        minorTickColor: '#eee',
                        minorGridLineWidth: 0,
                        
                        tickWidth: 1,
                        tickLength: 10,
                        tickColor: '#ccc',
                        gridLineColor: "#eee",

                        lineWidth:0,
                        lineColor: "#ccc", 
                        labels: { 
                            align: 'center', y: -25,
                            //format: '{value:%B}',
                            formatter: function(args)
                            {
                                var min = this.axis.min;
                                var max = this.axis.max;

                                var diffHours = moment(max).diff(moment(min), 'hours');

                                if(diffHours < 24 * 90)
                                {
                                    this.value = moment(this.value).format('MMM<br /><br />D');
                                }
                                else
                                {
                                    this.value = moment(this.value).format('MMM');
                                }

                                return this.value; 
                            }
                        } 
                    }, // long month
                    yAxis: [
                        {
                            // Temperature
                            gridLineWidth: 0, minorGridLineWidth: 0,
                            title: null, // { text: '平均温度', style: { color: '#2C5384' } },
                            labels: { align: 'right', x: -10, y: -5, format: '{value}°C', style: { color: '#2C5384' } },
                            opposite: true,
                            showLastLabel: false,
                            min: -20, max: 40, tickInterval: 5

                        }, {
                            // Energy
                            showLastLabel: false,
                            gridLineWidth: 1, minorGridLineWidth: 0,
                            title: null,//{ text: '总用电量', style: { color: '#5AA5E9' } },
                            labels: { align: 'left', x: 10, y: -5, format: '{value} KWh', style: { color: '#2C5384' } }
                        }, {
                            // Humidity
                            showLastLabel: false,
                            gridLineWidth: 0, minorGridLineWidth: 0,
                            title: null, //{ text: '空气湿度', style: { color: '#C0504D' } },
                            labels: { align: 'right', x: -10, y: -5, format: '{value} ％', style: { color: '#2C5384' } },
                            opposite: true,
                            min: 20, tickInterval: 10
                        }
                    ],
                    tooltip: {
                        crosshairs: [true,true],
                        pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b> ({point.percentage:.0f}%)<br/>',
                        shared: true
                    },
                    plotOptions: {
                        column: {
                            stacking: 'normal'
                        }
                    },
                    credits: { enabled: false }
                },
                series: [
                    {
                        type: 'column', name: '能耗', id: 'realdata', yAxis: 1, color: '#5AA5E9',
                        tooltip: { pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b><br/>' },
                        data: [],
                        showInLegend: false
                    },
                    {
                        type: 'spline', name: '空气湿度', id: 'humidity', yAxis: 2, color: '#C0504D', gridLineWidth: 0, dashStyle: 'shortdot', showInLegend: false,
                        marker: { enabled: false },
                        tooltip: { valueSuffix: ' mb' },
                        data: [],
                    },
                    {
                        type: 'spline', name: '室外温度', gridLineWidth: 0, id: 'temperature', showInLegend: false,
                        tooltip: { valueSuffix: ' °C' },
                        data: []
                    }
                ]
            }

	    $scope.chartOptions2 = {
                options: {
                    chart: {
			    type: 'pie'
			},
                    title: null, //{ text: '_', style: { 'color': 'white' } },
                    tooltip: {
			    headerFormat: '<span style="font-size:11px">{series.name}</span><br>',
			    pointFormat: '<span style="color:{point.color}">{point.name}</span>: 占总能耗的<b>{point.y:.2f}%</b><br/>'
			},
                    plotOptions: {
			    pie: {
				    allowPointSelect: true,
				    cursor: 'pointer',
				    dataLabels: {
				        enabled: false
				    },
				    showInLegend: true
				}
			}
                },
                series: [{
			    name: '1号总表',
			    colorByPoint: true,
			    data: [{
				name: '1号总表',
				y: 100
			    }]
			}]
            }

	    $scope.chartDetailBar = {
                options: {
                    chart: {
			    type: 'column',
			},
                    title: null, //{ text: '_', style: { 'color': 'white' } },
                        
                    xAxis: {
			    categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'July', 'Aug', 'Sep', 'Oct', 'Dec', 'Nov'],
			    title: {
				text: 'Month'
			    },
			}, // long month
                    yAxis: {
			    allowDecimals: false,
			    min: 0,
			    title: {
				text: 'Number of fruits'
			    }
			},
                    tooltip: {
                        headerFormat: '<b>{point.key}</b><br>',
            		pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: {point.y} / {point.stackTotal}'
                    },
                    plotOptions: {
                        column: {
				stacking: 'normal',
				depth: 40
			    }
                    },
		    legend: {
			    layout: 'vertical',
			    align: 'right',
			    verticalAlign: 'middle',
			    borderWidth: 0
			},
                    credits: { enabled: false }
                },
                series: [{
			    name: 'Type1',
			    data: [5, 3, 4, 7, 2, 3, 4, 4, 2, 5, 2, 5],
			    stack: 'type1'
			},
			{
			    name: 'Type2',
			    data: [5, 3, 4, 7, 2, 3, 4, 4, 2, 5, 2, 5],
			    stack: 'type1'
			}, {
			    name: 'Type3',
			    data: [3, 4, 4, 2, 5, 5, 3, 4, 7, 2, 3, 4],
			    stack: 'type1'
			}, {
			    name: 'Type4',
			    data: [2, 5, 6, 2, 1, 3, 4, 4, 2, 5, 5, 3],
			    stack: 'type1'
			}, {
			    name: 'Type5',
			    data: [3, 0, 4, 4, 3, 6, 2, 1, 3, 4, 4, 2],
			    stack: 'type1'
			}]
            }

            $scope.chartDetailPie = {
                options: {
                    chart: {
			    type: 'pie'
			},
                    title: null, //{ text: '_', style: { 'color': 'white' } },
                        
                    tooltip: {
			    headerFormat: '<span style="font-size:11px">{series.name}</span><br>',
			    pointFormat: '<span style="color:{point.color}">{point.name}</span>: <b>{point.y:.2f}%</b> of total<br/>'
			},
                    plotOptions: {
			    pie: {
				    allowPointSelect: true,
				    cursor: 'pointer',
				    dataLabels: {
				        enabled: false
				    },
				    showInLegend: true
				}
			}
                },
                series: [{
			    name: 'Brands',
			    colorByPoint: true,
			    data: [{
				name: 'Type1',
				y: 56.33
			    }, {
				name: 'Type2',
				y: 24.03
			    }, {
				name: 'Type3',
				y: 10.38
			    }, {
				name: 'Type4',
				y: 4.77
			    }, {
				name: 'Type5',
				y: 0.91
			    }]
			}]
            }

            $scope.export = function(){
                html2pdf.export($("#export-container"), 'Report.Monthly');
            }
        }
    ])

},{}],36:[function(require,module,exports){
angular.module('app.controllers.reports.nav', [])

    .controller('reportsNavCtrl', [
        '$scope', '$rootScope', '$http', '$filter', '$timeout', 'EnergyUnitFactory', '$state', '$ionicActionSheet', '$ionicHistory',
         function($scope, $rootScope, $http, $filter, $timeout, EnergyUnitFactory, $state, $ionicActionSheet, $ionicHistory) {

            $scope.reportUrl = null;

                
            EnergyUnitFactory.getByType(1).then(function(result) {

                //Redirect to first applicable Building if received 0 for ID
                if ($rootScope.$stateParams.id == 0) {

                    $rootScope.$state.go($rootScope.$state.current.name, { id: result[0].id }, {location:'replace', reload:true});
                    $rootScope.building = result[0];
                }
                else{

                    // Get report link PDF
                    var current = _.find(result,function(d){
                        return $rootScope.$stateParams.id == d.id;
                    });
                    if(current.buildingparam > 0){
                        console.log('current.buildingparam ' , current.buildingparam);
                        EnergyUnitFactory.getDetail(current.id).then(function(res){
                            console.log('res ' , res.objects[0]);

                            $scope.reportUrl = res.objects[0].report;
                        });
                    }

                }

                $scope.items = result;

            });


            /********************************************************************
             *
             *
             *  Mobile related
             *
             *
            *********************************************************************/

            $scope.linkSelected = { name: 'Select Report' };

            $scope.links = [
                { text: '综述指标', href: 'root.reports.summary' },
                /*{ text: '最新动态', href: 'root.reports.trend' },*/
                { text: '能耗构成', href: 'root.reports.disagg' },
                { text: '能耗透视', href: 'root.reports.heatmap' },
                { text: '历史比较', href: 'root.reports.monthly' },
                { text: '能耗对比', href: 'root.reports.regular' }
            ];

            $scope.toggleLinks = function() {
                $scope.linksShown = !$scope.linksShown;
            };

            $scope.areLinksShown = function() {
                return $scope.linksShown;
            };

            $scope.onLinkClicked = function(link){
                $scope.linkSelected = link;
                $scope.linksShown = false;
                $state.go(link.href);
            }


            $scope.showLinks = function() {

                // Show the action sheet
                var hideSheet = $ionicActionSheet.show({
                    buttons: $scope.links,
                    titleText: 'Select Report',
                    cancelText: 'Cancel',
                    cancel: function() {},
                    buttonClicked: function(index) {
                        $state.go($scope.links[index].href);
                        return true;
                    }
                });

            };


        }
    ]);

},{}],37:[function(require,module,exports){
angular.module('app.controllers.reports.regular', [])
    .controller('reportsRegularCtrl', [
        '$scope', '$rootScope', '$timeout', '$window', 'html2pdf', function($scope, $rootScope, $timeout, $window, html2pdf) {
            // Set extremes with friendly label value and 10 gridlines
            //var values = _.pluck(result, "total");
            //var maxVal = Math.ceil(_.max(values));
            //var nextN0 = Math.pow(10, maxVal.toString().length - 1);
            //var extreme = Math.ceil(maxVal / nextN0) * nextN0;

            //$scope.chartOptions1.options.yAxis.tickInterval = Math.ceil(extreme / 10); // limit to 10 gridlines
            //$scope.chartOptions1.options.yAxis.max = extreme;

            $scope.chartOptions1 = {
                options: {
                    /*chart: {
                        type: 'column', panning: true, margin: [55, 0, 0, 0] 
                    },*/
                    title: null,
                    xAxis: {
                        categories: [
                            '1月',
                            '2月',
                            '3月',
                            '4月',
                            '5月',
                            '6月',
                            '7月',
                            '8月',
                            '9月',
                            '10月',
                            '11月',
                            '12月'
                        ],
                        crosshair: true,
                        // opposite: true,
                        gridLineWidth: 0
                    },
                    yAxis: {
                        lineWidth: 0,
                        lineColor: '#fff',
                        gridLineWidth: 0,
                        minorGridLineWidth: 0, 
                        min: 0,
                        //labels: { align: 'left', x: 10, y: -5 },
                        title: null,//{ text: '能源效率' },
                        tickInterval: 25, // TODO: WARNING: HARDCODED use principle commented above once live
                        max: 250,
                        showLastLabel: false
                    },
                    tooltip: {
                        headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
                        pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' +
                            '<td style="padding:0"><b>{point.y:.1f} mm</b></td></tr>',
                        footerFormat: '</table>',
                        shared: true,
                        useHTML: true
                    },
                    plotOptions: {
                        column: {
                            pointPadding: 0.2,
                            borderWidth: 0
                        },
			spline: {
				
				marker: {
				    enabled: false
				}
			    }
                    }
                },
                series: [
                    {
			type: "column",
                        name: '当前楼宇',
                        showInLegend: false,
                        data: [49.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]

                    }, {
			type: "column",
                        name: '行业平均',
                        showInLegend: false,
                        data: [83.6, 78.8, 98.5, 93.4, 106.0, 84.5, 105.0, 104.3, 91.2, 83.5, 106.6, 92.3]

                    }, {
			type: "column",
                        name: '优质楼宇',
                        showInLegend: false,
                        data: [48.9, 38.8, 39.3, 41.4, 47.0, 48.3, 59.0, 59.6, 52.4, 65.2, 59.3, 51.2]

                    }, {
		        type: 'spline',
		        name: '目标值',
		        data: [38.9, 40.8, 42.3, 41.4, 57.0, 68.3, 79.0, 69.6, 52.4, 55.2, 49.3, 31.2],
		        marker: {
			    lineWidth: 2,
			    lineColor: Highcharts.getOptions().colors[5],
			    fillColor: 'white'
		        }
		    }, {
		        type: 'spline',
		        name: '基准值',
		        data: [28.9, 32.8, 35.3, 31.4, 47.0, 55.3, 69.0, 59.6, 42.4, 35.2, 39.3, 21.2],
		        marker: {
			    lineWidth: 2,
			    lineColor: Highcharts.getOptions().colors[6],
			    fillColor: 'white'
		        }
		    }
                ]
            };

            $timeout(function(){
                $rootScope.resize();
            });

        }
    ])

},{}],38:[function(require,module,exports){
angular.module('app.controllers.reports.sankey', [])
    .controller('reportsSankeyCtrl', [
        '$scope', '$rootScope', '$sce', '$timeout', '$window', 'html2pdf', 'AllMetersService', 'WeatherFactory', function($scope, $rootScope, $sce, $timeout, $window, html2pdf, AllMetersService, WeatherFactory) {
            $scope.year="1";
            $scope.bldg_id = $rootScope.$stateParams.id;

            var occupancy_config = {
                occupied_slots: [
                    {
                        dow: [1,2,3,4,5],
                        hod: [8,9,10,11,12,13,14,15,16,17]
                    }
                ]
            }

            var occupied = function (dow,hod){
                var occupied_slots_test = _.map(occupancy_config.occupied_slots,function(slot){
                    return slot.dow.indexOf(dow)>=0 & slot.hod.indexOf(hod)>=0;
                });
                return _.reduce(occupied_slots_test,function(a,b){
                    return a & b;
                },true);
            }

            //a sankey chart shows flow from first level meters to last level meters to (maybe subsegmentations) to following segmentation:
            //lighting': '照明用电',
            //'plug': '设备与插座',
            //'heating': '取暖用电',
            //'motor': '动力用电',
            //'cooling': '空调制冷',
            //'misc':特殊用电'
            $scope.updateChart = function(){
                var interval = "60m";
                var year=parseInt($scope.year)||1;
                var startDate = moment().subtract(year, 'y').startOf('day').valueOf(); // year ago
                var endDate = moment().subtract(year-1, 'y').add(1, 'd').startOf('day').valueOf(); // end of today
                AllMetersService.load($rootScope.$stateParams.id,startDate,endDate,{
                    interval:interval,
                    disagg: "all"
                }).then(function(data){
                    var consump_data = data[0].points;
                    WeatherFactory.get($rootScope.$stateParams.id,startDate,endDate,{
                        interval:interval,
                    }).then(function(data){
                        var temp_data = data;
                        //merging consumption data and temperature data together
                        var dayTemps = _.groupBy(temp_data,function(temp){
                            var d = new Date(temp[0]);
                            var dow = d.getDay();
                            var hod = d.getHours();
                            var day = "00" + d.getDate();
                            var month ="00"+ (d.getMonth() + 1);
                            var year = d.getFullYear();
                            return JSON.stringify({
                                d: year + "/" + month.slice(-2) + "/" + day.slice(-2),
                                o: occupied(dow,hod)
                            })
                        })
                        var dayConsumps = _.groupBy(consump_data,function(consump){
                            var d = new Date(consump[0]);
                            var dow = d.getDay();
                            var hod = d.getHours();
                            var day = "00" + d.getDate();
                            var month ="00"+ (d.getMonth() + 1);
                            var year = d.getFullYear();
                            return JSON.stringify({
                                d: year + "/" + month.slice(-2) + "/" + day.slice(-2),
                                o: occupied(dow,hod)
                            })
                        })
                        //calculate the [temperature,consumption] of each day and stired in a map
                        var dayTempConsumpMap = {}; //{{d:'2016/05/21',o:1}: [26, 4567], {d:'2016/05/22',o:1}: [27, 5676]}
                        _.forEach(dayTemps, function(v, k) {
                            var temp_avg = Math.round(_.reduce(v,function(sum,x){
                                return sum + x[1];
                            },0) / v.length);
                            dayTempConsumpMap[k] = [temp_avg,null];
                        });
                        _.forEach(dayConsumps, function(v, k) {
                            var consump_avg = Math.round(_.reduce(v,function(sum,x){
                                return sum + x[1];
                            },0) / v.length);
                            if(dayTempConsumpMap[k] != undefined){
                                //only update consump where temperature is available
                                dayTempConsumpMap[k][1] = consump_avg;
                            }
                        });
                        //plot dayTempConsump
                        //var x = dayTempConsumpMap;
                        $scope.highchartsNG.series[0].data=_.values(_.pick(dayTempConsumpMap,function(v,k){
                            var ko = JSON.parse(k);
                            return ko.o == 0;
                        }));
                        $scope.highchartsNG.series[1].data=_.values(_.pick(dayTempConsumpMap,function(v,k){
                            var ko = JSON.parse(k);
                            return ko.o == 1;
                        }));
                    })
                });
            }

/*$scope.highchartsNG = {
        options: {
            chart: {
                type: 'bar'
            }
        },
        series: [{
            data: [10, 15, 12, 8, 7]
        }],
        title: {
            text: 'Hello'
        },
        loading: false
    }*/

            $scope.highchartsNG = {
                options: {
                    chart: { 
                        type: 'scatter',
                    },
                    title: null, //{ text: '_', style: { 'color': 'white' } },
                        
                    xAxis: { 
                        opposite: false,
                        minorTickColor: '#eee',
                        //minorGridLineWidth: 0,
                        
                        //tickWidth: 1,
                        //tickLength: 10,
                        tickColor: '#ccc',
                        gridLineColor: "#eee",

                        lineWidth:0,
                        lineColor: "#ccc", 
                        plotBands: [
                            {color: 'lightblue', from: -100, to: 8},
                            {color: 'lightgray', from: 8, to: 20},
                            {color: 'pink', from: 20, to: 100}
                        ],
                        labels: { align: 'center', x: -10, y: -25, format: '{value}°C', style: { color: '#2C5384' } },
                        min: -10, max: 40, tickInterval: 5
                    },
                    yAxis: //[
                        {
                            // Consumption
                            //gridLineWidth: 0, minorGridLineWidth: 0,
                            title: null, // { text: '平均温度', style: { color: '#2C5384' } },
                            labels: { align: 'right', x: -10, y: -5, format: '{value}MWh', style: { color: '#2C5384' } },
                            opposite: true,
                            showLastLabel: false,
                            tickInterval: 100,
                        },
                    //],
                    tooltip: {
                        crosshairs: [true,true],
                        //pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b> ({point.percentage:.0f}%)<br/>',
                        shared: true
                    },
                    plotOptions: {
                        scatter: {
                            marker: {
                                radius: 5,
                                states: {
                                    hover: {
                                        enabled: true,
                                        lineColor: 'rgb(100,100,100)'
                                    }
                                }
                            },
                            states: {
                                hover: {
                                    marker: {
                                        enabled: false
                                    }
                                }
                            },
                            tooltip: {
                                headerFormat: '<b>{series.name}</b><br>',
                                pointFormat: '{point.x} c, {point.y} kw'
                            }
                        }
                    },
                    credits: { enabled: false }
                },
                /*series: [{
                    data: [],
                }],*/
                series: [
                    {
                        name: '能耗-Unoccupied', id: 'nonoccupied_data', color: '#5AA5E9',
                        //tooltip: { pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b><br/>' },
                        data: [],
                        showInLegend: true
                    },
                    {
                        name: '能耗-Occupied', id: 'occupied_data', color: 'red',
                        //tooltip: { pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y:.2f}</b><br/>' },
                        data: [],
                        showInLegend: true
                    },
                ]
            }

            if ($rootScope.$stateParams.id > 0) {
                //$scope.updateChart();
            }

            $scope.export = function(){
                html2pdf.export($("#export-container"), 'Report.Sankey');
            }
        }
    ])
},{}],39:[function(require,module,exports){
angular.module('app.controllers.reports.summary', [])
    .controller('reportsSummaryCtrl', [
        '$scope', '$rootScope', '$http', 'AllMetersService', 'WeatherFactory', '$filter', 'EnergyUnitFactory', 'LanguageFactory', 'UtilityService', '$q', 'html2pdf', '$timeout', 'platform', '$window',
        function($scope, $rootScope, $http, AllMetersService, WeatherFactory, $filter, EnergyUnitFactory, LanguageFactory, UtilityService, $q, html2pdf, $timeout, platform, $window) {


            // Indicators binding variable
            $scope.stats = {};

            // Series: Hourly = 0, Daily = 1, Monthly = 2
            $scope.serieType = "1";
	    

            // Mockup data for properties panel
            // $scope.properties = [
            // { name: '地址', value: '121029' },
            // { name: '建筑类型', value: '酒店旅馆' },
            // { name: '建筑年限', value: '2005' },
            // { name: '建筑总面积', value: '20000平米' },
            // { name: '总房间数', value: '123间' },
            // { name: '会议厅间数',   value: '3' },
            // { name: '雇员人数', value: '533'},
            // { name: '制冷设备数', value: '3' },
            // { name: '厨房数量', value: '1' },
            // ];
            $scope.properties = {
                address: "121029",
                buildingType: "酒店旅馆",
                buildingYear: "2005"
            }

            // Switch between hourly / daily / monthly series
            $scope.switchSerie = function(data) {
		if ($rootScope.$stateParams.id > 0) {
			var now_moment=moment();
			var start_time;

			if($scope.serieType == "0"){
			     start_time = moment(now_moment).subtract(7, 'day').valueOf();
			}else if($scope.serieType == "1"){
			     start_time = moment(now_moment).subtract(1, 'month').valueOf();
			}else{
			     start_time = moment(now_moment).subtract(1, 'year').valueOf();
			}

		        
		        var p2 = WeatherFactory.get($rootScope.$stateParams.id);

		        $q.all([p2]).then(function(result) {

		            var seriesData = result[0] || [];
		            var weather = { temp: [], hum: [], date:[] };
		            
		            var weatherData = _.filter(seriesData || [], function(d) {
		                return new Date(d[0]) >= start_time;
		            });

		            var daily = _.groupBy(weatherData, function(d) {
				
				var date=moment(new Date(d[0]));
				date.utcOffset(480);
				var day="0"+date.date();
				var month="0"+(date.month()+1);
				var year = date.year();

				/*if($scope.serieType == 2){
					return year + "/" + month.slice(-2); // ex: 2015/11    
				}else{*/
					return year + "/" + month.slice(-2) + "/" + day.slice(-2); // ex: 2015/11/11
				//}

		            });
			    

		            angular.forEach(daily, function(v, k) {
		                var tempSum = 0.0;
		                var tempHum = 0;


		                for (var j = 0; j < daily[k].length; j++) {
				    if(daily[k][j][1] != null) 
		                    	tempSum += parseFloat(daily[k][j][1]);
				    if(daily[k][j][2] != null) 
		                    	tempHum += parseFloat(daily[k][j][2]);
		                }

				temp = Math.round(tempSum / daily[k].length);
				
				if(isNaN(temp) || temp == 0)
					weather.temp.push(null)
				else{
		                	weather.temp.push(temp);
				}
				
				temp = Math.round(tempHum / daily[k].length);
				if(isNaN(temp) || temp == 0)
					weather.hum.push(null)
				else
		                	weather.hum.push(temp);

				weather.date.push(k)
		            });
			    
			    $scope.chartOptions1.options.xAxis.categories = weather.date;
		            $scope.chartOptions1.series[1].data = weather.temp;
		            $scope.chartOptions1.series[2].data = weather.hum;

		        });

			var param = { "isExternalRequest": "False", "time_format": "ms", "interval": "auto", "operation": "mean(value)", "start_utc": Math.round(start_time/1000), "end_utc": Math.round(now_moment.valueOf()/1000)};

			$http.post("api/getseries/"+$rootScope.$stateParams.id+"/", param).then(function (result) {


			    if(result.data.length > 0){
				options = {}
				/*if($scope.serieType == 2){
					options = {"month": true}   
				}*/
				seriesData = result.data[0].points.reverse();
				seriesData = UtilityService.groupDataByTime(seriesData, options);	

				$scope.chartOptions1.options.xAxis.categories = _.pluck(seriesData, "time");

				$scope.chartOptions1.series[0].data = _.pluck(seriesData, "total")
			    }
			    else{
				$scope.chartOptions1.series[0].data = []
			    }
			},function(err){
			    console.log(err);
			});
            } else {
            }

	    /*$timeout(function(){
                    
                    $timeout(function(){
                        AllMetersService.calculate($rootScope.building || $rootScope.$stateParams, {}, data).then(function (result) {
                            $scope.stats = result;
                        });
                    }, 0);

                }, 0);*/

	}

	    var rect = null;
	    var rectH = null;
	    function drawRect(chart){

		
		$timeout(function(){
		    if (rect){
		        rect.element.remove();   
		    }
		    if (rectH){
		        rectH.element.remove();   
		    }

		    if(chart.chartHeight && chart.chartHeight){
		        

		        var chartWidth = $(chart.renderTo).width();
		        var chartHeight = $(chart.renderTo).height();

		        rect = chart.renderer.rect(chartWidth - 100, chart.margin[0], 100, chartHeight, 0)
		            .attr({
		                'stroke-width': 0,
		                fill: 'rgba(250, 250, 250, 0.5)',
		                zIndex: 2
		            })
		            .add();

		        rectH = chart.renderer.rect(0, 0, chartWidth, chart.margin[0] - 1, 0)
		            .attr({
		                'stroke-width': 0,
		                fill: 'rgba(250, 250, 250, 0.5)',
		                zIndex: 2
		            })
		            .add();
		    }
		})
            }

            if ($rootScope.$stateParams.id > 0) {

                $scope.switchSerie();
                
                $timeout(function(){
                    
                    $timeout(function(){
                        EnergyUnitFactory.getDetail($rootScope.$stateParams.id,{populate:true}).then(function(buildingDetail) {
                            var buildingParam = LanguageFactory.filterFields(buildingDetail.objects[0]);
                            var building = LanguageFactory.filterFields(buildingDetail.objects[0].super);
                            $scope.properties = buildingParam.concat(building);
                            $scope.stats.desc = (buildingDetail.objects[0] || {}).description;
                        })
                    }, 0);
                    
                }, 0);

            }

            $scope.getPropertyIcon = function(name) {
                switch(name) {
                    case 'GPSlocation':
                        return 'icon-satellite';
                    case 'category':
                        return 'icon-buildings';
                    case 'name':
                        return 'icon-briefcase';
                    case 'type':
                        return 'icon-building-5';
                    case 'value':
                        return 'icon-info';
                    default:
                        return 'icon-building';
                }
            }

            $scope.chartOptions1 = {
                options: {
                    chart: {
                        zoomType: 'xy',
                        
                    },
                    title: null,
                    xAxis: {
                        
                        gridLineWidth: 0,
                    },
                    yAxis: [{
                            // Energy usage
                            gridLineColor: "#eee",
                            title: null,
                            labels: {
                                format: '{value} kWh',
                                style: {
                                    color: Highcharts.getOptions().colors[0]
                                }
                            },
                        },{
                            // Temperature C
                            labels: {
                                format: '{value}°C',
                                style: {
                                    color: Highcharts.getOptions().colors[2]
                                }
                            },
                            title: null,
                            opposite: true,

                        },{
                            // Humidity
                            title: null,
                            labels: {
                                format: '{value} ％',
                                useHtml: true,
                                style: {
                                    color: Highcharts.getOptions().colors[1]
                                }
                            },
                            opposite: true,
                        }
                    ],
                    tooltip: {
                        // headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
                        // pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' +
                        //     '<td style="padding:0"><b>{point.y:.1f} </b></td></tr>',
                        // footerFormat: '</table>',
                        shared: true,
                        // useHTML: true
                    },
                },
                    exporting: {
                        buttons: {
                            customButton: {
                                x: -62,
                                onclick: function () {
                                   alert('Clicked');
                                },
                                symbol: 'circle'
                            }
                        }
                    },
                series: [
                    {
                        name: '能耗',
                        tooltip: {
                            valueSuffix: 'KWh'
                        },
                        type: 'column',
                        // showInLegend: false,
                        yAxis: 0,
                        data: []

                    }, {
                        name: '室外温度',
                        type: 'spline',
                        tooltip: {
                            valueSuffix: '°C'
                        },
                        // showInLegend: false,
                        yAxis: 1,
			color: Highcharts.getOptions().colors[2],
                        data: [],

                    }, {
                        name: '空气湿度',
                        type: 'spline',
                        tooltip: {
                            valueSuffix: ' %'
                        },
                        // showInLegend: false,
                        yAxis: 2,
			color: Highcharts.getOptions().colors[1],
                        data: []

                    }
                ],
		func: function(chart1){
                    $timeout(function(){
                    })

                }
            };

	    if(platform.isMobile()){

		// $scope.chartOptions1.options.chart.marginTop = 15;
                // $scope.chartOptions1.options.chart.marginTop = 15;
                // $scope.chartOptions1.options.xAxis.showFirstLabel = false;
                // $scope.chartOptions1.options.yAxis.showFirstLabel = false;
                // $scope.chartOptions1.options.backgroundColor = '#91c46b';

                // $scope.chartOptions1.options.xAxis.gridLineWidth = 0;
                // $scope.chartOptions1.options.yAxis.gridLineWidth = 1;
                // $scope.chartOptions1.options.yAxis[0].title = null;//labels = { align: 'left', x: 0, y: -2 };
                // $scope.chartOptions1.options.yAxis[0].labels = { align: 'left', x: -75, y: -2 };
                //$scope.chartOptions1.options.yAxis[0].labels.x = -35;//labels = { align: 'left', x: 0, y: -2 };

                // $scope.chartOptions1.options.yAxis[1].title = null;//labels = { align: 'left', x: 0, y: -2 };
                // $scope.chartOptions1.options.yAxis[1].labels = { align: 'left', x: 0, y: -2 };
                // $scope.chartOptions1.options.yAxis[1].labels.x = 0;//labels = { align: 'left', x: 0, y: -2 };
                
                // $scope.chartOptions1.options.yAxis[2].title = null;//labels = { align: 'left', x: 0, y: -2 };
                // $scope.chartOptions1.options.yAxis[2].labels = { align: 'left', x: -25, y: -2 };
                //$scope.chartOptions1.options.yAxis[2].labels.x = 40;//labels = { align: 'left', x: 0, y: -2 };

                // $scope.chartOptions1.series[0].showInLegend = false;
            }

            if ($rootScope.$stateParams.id > 0) {
                AllMetersService.calculate($rootScope.building || $rootScope.$stateParams).then(
                    function(result) {

                        //to bind in html
                        $scope.stats = result;
                        EnergyUnitFactory.getDetail($rootScope.$stateParams.id).then(function(buildingDetail) {
                            $scope.stats.desc = (buildingDetail.objects[0] || {}).description;
                        })

                        //set chart extreemes
                        //$scope.chartGaugeOptions1.options.yAxis.max = $scope.stats.dailyAverage * 1.5 || 8000;
                        //$scope.chartGaugeOptions2.options.yAxis.max = $scope.stats.peakAverage * 1.5 || 8000;
			console.log(JSON.stringify(result.data));

                        //update chart series
                        $scope.chartGaugeOptions1alt.series[0].data = [Math.floor($scope.stats.todayEnergy) || 0];
                        $scope.chartGaugeOptions2alt.series[0].data = [Math.floor($scope.stats.todayPeak) || 0];
                        //$scope.chartGaugeOptions1.series[0].data = [$scope.stats.todayEnergy || 0];
                        //$scope.chartGaugeOptions2.series[0].data = [$scope.stats.todayPeak || 0];

                        $rootScope.resize();

                    },
                    function(error) {

                    }
                );
            } else {
            }


           // middle big gauge
            $scope.chartGaugeOptions1alt = {
                options: {
                    chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15, spacingLeft: 0, spacingRight: 0 },
                    title: null,
                    exporting: { enabled: false },
                    pane: { center: ['50px', '30px'], size: '50%', startAngle: 115, endAngle: -115, background: null },
                    plotOptions: {
                        gauge: {
                            dataLabels: { enabled: true, style: { 'fontSize': '20px' }, y: 60, borderWidth: 0 },
                            dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '70%', baseLength: '0%' }, // dial arrow
                            pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
                        }
                    },
                    yAxis: {
                        pane: 0,
                        min: 0,
                        max: 3000,
                        lineColor: null,
                        reversed: true,
                        //minorTickInterval: 1,
                        //tickPixelInterval: 10,
                        //minorTickPosition: 'outside',
                        //tickPosition: 'outside',
                        //tickWidth: 1,
                        //tickPositions: [0, 1000, 2000, 3000],
                        labels: { enabled:false, step: 1, distance: 15, rotation: 'auto' },
                        title: { text: 'kWh', align: 'middle', style: { 'fontSize': '12px' }, y: 7 }, // Y Title
                        plotBands: [
                            { innerRadius: '140%', outerRadius: '180%', from: 0, to: 1000, color: '#55BF3B' }, // green
                            { innerRadius: '140%', outerRadius: '180%', from: 1000, to: 2000, color: '#ffcc00' }, // yellow
                            { innerRadius: '140%', outerRadius: '180%', from: 2000, to: 3000, color: '#DF5353' } // red
                        ],
                        dataLabels: {
                            formatter: function () {
                                 var kmh = this.y,
                                 mph = Math.round(kmh * 0.621);
                            }
                        },
                    },
                    credits: false
                },
                series: [
                    {
                        name: 'kWh',
                        data: [0]
                    }
                ],

		func: function(chart1){
                    
                }

            };

            $scope.chartGaugeOptions2alt = {
                options: {
                    chart: { type: 'gauge', plotBackgroundColor: null, plotBackgroundImage: null, plotBorderWidth: 0, plotShadow: false, spacingTop: 15, spacingBottom: 15, spacingLeft: 0, spacingRight: 0 },
                    title: null,
                    exporting: { enabled: false },
                    pane: { center: ['50px', '30px'], size: '50%', startAngle: 115, endAngle: -115, background: null },
                    plotOptions: {
                        gauge: {
                            dataLabels: { enabled: true, style: { 'fontSize': '20px' }, y: 60, borderWidth: 0 },
                            dial: { backgroundColor: '#c72424', borderColor: '#c72424', radius: '90%', baseLength: '0%' }, // dial arrow
                            pivot: { backgroundColor: '#c72424', radius: '4', } // dial arrow dot
                        }
                    },
                    yAxis: {
                        pane: 0,
                        min: 0,
                        max: 3000,
                        lineColor: null,
                        reversed: true,
                        //minorTickInterval: 1,
                        //tickPixelInterval: 10,
                        //minorTickPosition: 'outside',
                        //tickPosition: 'outside',
                        //tickWidth: 1,
                        //tickPositions: [0, 1000, 2000, 3000],
                        labels: { enabled: false, step: 1, distance: 15, rotation: 'auto' },
                        title: { text: 'kWh', align: 'middle', style: { 'fontSize': '12px' }, y: 7 }, // Y Title
                        plotBands: [
                            { innerRadius: '140%', outerRadius: '180%', from: 0, to: 1000, color: '#55BF3B' }, // green
                            { innerRadius: '140%', outerRadius: '180%', from: 1000, to: 2000, color: '#ffcc00' }, // yellow
                            { innerRadius: '140%', outerRadius: '180%', from: 2000, to: 3000, color: '#DF5353' } // red
                        ],
                        dataLabels: {
                             formatter: function () {
                             var kmh = this.y,
                             mph = Math.round(kmh * 0.621);
                        }
                    },
                    },
                    credits: false
                },
                series: [
                    {
                        name: 'kWh',
                        data: [0]
                    }
                ],

		func: function(chart1){
                    
                }

            };

            $scope.chartGaugeOptions1 = {
                options: {
                    chart: {
                        type: 'solidgauge',
                        height: 250
                    },

                    title: { text: '当日总能耗指示' },

                    pane: {
                        center: ['50%', '50%'],
                        size: '100%', // over 100 makes gauge Gauges cut off on lower resolution
                        startAngle: -90,
                        endAngle: 90,
                        background: {
                            backgroundColor: (Highcharts.theme && Highcharts.theme.background2) || '#EEE',
                            innerRadius: '60%',
                            outerRadius: '100%',
                            shape: 'arc'
                        }
                    },

                    tooltip: {
                        enabled: false
                    },

                    plotOptions: {
                        solidgauge: {
                            dataLabels: {
                                y: 5,
                                borderWidth: 0,
                                useHTML: true
                            }
                        }
                    },

                    yAxis: {
                        min: 0,
                        max: 8000,
                        stops: [
                            [0.1, '#55BF3B'], // green
                            [0.5, '#DDDF0D'], // yellow
                            [0.9, '#DF5353'] // red
                        ],
                        labels: {
                            y: 16
                        }
                    },

                    credits: {
                        enabled: false
                    },
                },
                series: [
                    {
                        name: 'Consumption',
                        data: [0],
                        dataLabels: {
                            format: '<div style="text-align:center"><span style="font-size:25px;color:' +
                                ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>' +
                                '<span style="font-size:20px;color:orange">kwh</span></div>'
                        }
                    }
                ],

		exporting: {
		    buttons: {
		        customButton: {
		            x: -62,
		            onclick: function () {
		                alert('Clicked');
		            },
		            symbol: 'circle'
		        }
		    }
		},

		func: function(chart1){
                    
                }
            };

            $scope.chartGaugeOptions2 = {
                options: {
                    chart: {
                        type: 'solidgauge',
                        height: 250
                    },
                    title: { text: '当日高峰能耗指示' },
                    pane: {
                        center: ['50%', '50%'],
                        size: '100%', // over 100 makes gauge Gauges cut off on lower resolution
                        startAngle: -90,
                        endAngle: 90,
                        background: {
                            backgroundColor: (Highcharts.theme && Highcharts.theme.background2) || '#EEE',
                            innerRadius: '60%',
                            outerRadius: '100%',
                            shape: 'arc'
                        }
                    },

                    tooltip: {
                        enabled: false
                    },

                    plotOptions: {
                        solidgauge: {
                            dataLabels: {
                                y: 5,
                                borderWidth: 0,
                                useHTML: true
                            }
                        }
                    },

                    yAxis: {
                        min: 0,
                        max: 8000,
                        stops: [
                            [0.1, '#55BF3B'], // green
                            [0.5, '#DDDF0D'], // yellow
                            [0.9, '#DF5353'] // red
                        ],
                        labels: {
                            y: 16
                        }
                    },

                    credits: {
                        enabled: false
                    }
                },
                series: [
                    {
                        name: 'Consumption',
                        data: [0],
                        dataLabels: {
                            format: '<div style="text-align:center"><span style="font-size:25px;color:' +
                                ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>' +
                                '<span style="font-size:20px;color:orange">kwh</span></div>'
                        }
                    }
                ],

		func: function(chart1){
                    
                }
            }
            
        }
    ])

},{}],40:[function(require,module,exports){
angular.module('busy', [])
    .directive('busy', function () {
        return {
            scope: { busy: '=', onCancel: '=' },
            replace: true,
            template: '<div class="busy" ng-show="busy">' +
                      '     <div class="centered text-center">' +
                      '          <div class="centered-item">' +
                      '              <div>Loading... Please wait</div><br/>' +
                      '              <img src="/static/image/busy.gif"/><br/><br/><br/>' +
                      '              <button ng-show="onCancel" class="btn btn-default btn-flat btn-light-green" style="width: auto" ng-click="cancel()">Cancel</button>' +
                      '          </div>' +
                      '      </div>' +
                      '</div>',
            link: function ($scope, element, attrs) {
                $scope.cancel = function() {
                    if ($scope.onCancel) {
                        $scope.onCancel();
                    }
                }
            },
            controller: ['$scope', '$rootScope', '$timeout', function ($scope, $rootScope, $timeout) {
                
            }]
        }
    });
},{}],41:[function(require,module,exports){
angular.module('daterange', [])
    .directive('daterange', ['$parse', '$timeout', '$window', function ($parse, $timeout, $window) {
        return {
            template: '<uib-datepicker template-url="template/daterange-datepicker.html" ng-model="config.selected" min-date="config.minDate" max-date="config.maxDate" starting-day="config.startingDay" show-weeks="config.showWeeks" class="datepicker" custom-class="getDayClass(date, mode)"></uib-datepicker>',
            replace: false,
            scope: { config: "=daterange" },
            link: function ($scope, element, attrs) {
                $scope.events = [];
                $scope.config.showWeeks = $scope.config.showWeeks || true; 
                $scope.config.startingDay = $scope.config.startingDay || 1; 


                $scope.config.getDateRange = function () {
                    if ($scope.events && $scope.events.length > 0)
                        return moment($scope.events[0].date).format('MMM DD, YYYY') + ' - ' + moment($scope.events[$scope.events.length - 1].date).format('MMM DD, YYYY');
                    else
                        return '---';
                }

                $scope.config.setRange = function(start, end){
                    $scope.start = start;
                    $scope.config.selected = end;
                    $scope.processRangeSelection(true);

                    $timeout(function(){
                        $scope.$broadcast('refreshDatepickers');
                    });
                }

                $scope.config.getStart = function(){
                    return moment($scope.events[0].date);
                }

                $scope.config.getEnd = function(){
                    return moment($scope.events[$scope.events.length - 1].date);
                }

                $scope.getDayClass = function (date, mode) {
                    if (!$scope.events) return '';

                    if (mode === 'day') {
                        for (var i = 0; i < $scope.events.length; i++) {
                            if (moment(date).startOf('day').valueOf() === moment($scope.events[i].date).startOf('day').valueOf()) {
                                return $scope.events[i].status;
                            }
                        }
                    }
                    return '';
                };

                $scope.processRangeSelection = function(reset){
                    if (!$scope.config.selected) return;
                    $scope.events = [];

                    if(reset)
                       $scope.end = null; 

                    if (!$scope.start || $scope.start > $scope.config.selected || $scope.end) {
                       $scope.start = $scope.config.selected;
                       $scope.end = null;
                    } else {
                       $scope.end = $scope.config.selected;
                    }


                    if ($scope.start) 
                        $scope.events.push({ date: $scope.start, status: 'full', label: 'start' })
                    
                    if ($scope.end) {
                        $scope.events.push({ date: $scope.end, status: 'full', label: 'end' })

                        var start = moment($scope.start);
                        var end = moment($scope.end);
                        var diff = moment($scope.end).diff($scope.start, 'days');
                        var nexDate = start.clone();
                        for (var i = 1; i <= diff; i++) {
                            nexDate = start.add(1, 'days');
                            $scope.events.push({ date: nexDate.clone(), status: 'partially' })
                        }

                    }
                    $scope.config.selected = null;
                }

                $scope.$watch('config.selected', function () {
                    $scope.processRangeSelection();
                });

            }
        }
    }]);
},{}],42:[function(require,module,exports){
angular.module('fileHandler', [])
.directive('fileHandler', ['$parse', function ($parse) {
	return {
		restrict: 'A',
		scope: false,
		link: function(scope, element, attrs) {
            var fn = $parse(attrs.onSelected);
            
			element.on('change', function(onChangeEvent) {
				var reader = new FileReader();
                
				reader.onload = function(onLoadEvent) {
					scope.$apply(function() {
						fn(scope, {$fileContent:onLoadEvent.target.result});
					});
				};


				reader.readAsText((onChangeEvent.srcElement || onChangeEvent.target).files[0]);

				scope.$apply(function(){
					$(element).val('');
				})
			});
		}
	};
}]);
},{}],43:[function(require,module,exports){
/**
 * Directive that handles file-type input ngmodel
 * NOTE: does not work with IE9 and below
 */
angular.module('fileInput', [])
.directive('fileInput', [function () {
    return {
        require: "ngModel",
        restrict: 'A',
        link: function ($scope, elem, attrs, ngModel) {
            elem.bind('change', function (event) {
                ngModel.$setViewValue(event.target.files[0]);
                $scope.$apply();
            });

            $scope.$watch(function () {
                return ngModel.$viewValue;
            }, function (value) {
                if (!value) {
                    elem.val('');
                }
            });
        }
    };
}]);

},{}],44:[function(require,module,exports){
angular.module('highcharts.redraw', [])
    .directive('highchartsRedraw', ['$parse', '$timeout', '$window', '$rootScope', '$ionicScrollDelegate', function ($parse, $timeout, $window, $rootScope, $ionicScrollDelegate) {
        return {
            transclude: true,
            replace: false,
            link: function ($scope, element, attrs) {
                $timeout(function(){

                    var config = $parse(attrs.config)($scope);
                    var chart = config.getHighcharts();

                    config.func = function (chart1) {
                        $timeout(function(){
                            $ionicScrollDelegate.resize();
                            $timeout(function(){
                                chart1.redraw();
                                chart1.reflow();
                            })
                        })
                    }

                    $scope.$watchCollection(chart.series, function (newValue, oldValue) {
                        // $timeout(function(){
                        //     if(chart){
                        //         console.log('changed');
                        //         chart.redraw();
                        //         chart.reflow();
                        //     }
                        // },5000)
                    });

                    var onResizeEvent = $rootScope.$on('window:resize', function(){

                        //$ionicScrollDelegate.resize(); 
                        // chart.redraw();
                        // chart.reflow();
                    });

                    $(window).resize(function() {
                        $rootScope.$broadcast('window:resize');
                    });

                    $scope.$on('$destroy', function(){
                        onResizeEvent();
                    });
                })
            }
        }
    }])

    .directive('highchartsPanning', ['$timeout', '$parse', function($timeout, $parse){
        // Runs during compile
        return {
            replace: false,
            link: function($scope, iElm, iAttrs, controller) {

                var chart;

                function Handler() {
                    
                    var ticking = false;
                    var lastDeltaX = 0;


                    function requestTick(args, extremes) {
                        if(!ticking) {
                            requestAnimationFrame(function(){
                                return update(args, extremes);
                            });
                        }
                        ticking = true;
                    }


                    function update(args, extremes) {
                        var newMinX;
                        var NewMaxX;
                        var xExtremes = extremes;
                        var range = extremes.max - extremes.min;
                        var step = Math.floor(range * .05);

                        // left and right 

                        if (args.direction == 4) {

                            // RIGHT
                            // limit to START of data
                            newMinX = xExtremes.dataMin < xExtremes.min - step ? xExtremes.min - step : xExtremes.dataMin;
                            newMaxX = xExtremes.dataMin < xExtremes.min - step ? xExtremes.max - step : xExtremes.max;
                            chart.xAxis[0].setExtremes(newMinX, newMaxX);
                        }
                        else if (args.direction == 2) {

                            // LEFT
                            // limit to END of data
                            newMinX = xExtremes.dataMax > xExtremes.max + step ? xExtremes.min + step : xExtremes.min;
                            newMaxX = xExtremes.dataMax > xExtremes.max + step ? xExtremes.max + step : xExtremes.dataMax;
                            chart.xAxis[0].setExtremes(newMinX, newMaxX);
                        }

                        //TODO: up and down

                        ticking = false;
                    }

                    this.move = function move(deltaX, deltaY, velocityX, velocityY, evt){

                        if(!chart) return;

                        requestTick(evt, chart.xAxis[0].getExtremes());

                    }
                    this.zoom = function(delta){

                        if(!chart) return;

                        busy = true;

                        var xMin = chart.xAxis[0].getExtremes().min;
                        var xMax = chart.xAxis[0].getExtremes().max;
                        var xdMin = chart.xAxis[0].getExtremes().dataMin;
                        var xdMax = chart.xAxis[0].getExtremes().dataMax;
                        var yMin = chart.yAxis[0].getExtremes().dataMin;
                        var yMax = chart.yAxis[0].getExtremes().dataMax;
                       
                        newMin = xMin;
                        newMax = xMax;

                        var diff = xMax - xMin;
                        var diffData = xdMax - xdMin;

                        if(delta > 0)
                        {
                            //zoomin
                            if(diff > diffData * .05)
                            {
                                newMin = xMin + diff * .05; //moment(xMin).add(1, 'month').valueOf();
                                newMax = xMax - diff * .05; //moment(xMax).subtract(1, 'month').valueOf();
                            }
                        }
                        else
                        {
                            //zoomout
                            if(diff < diffData)
                            {

                                newMin = xMin - diff * .05 < xdMin ? xdMin : xMin - diff * .05; //moment(xMin).add(1, 'month').valueOf();
                                newMax = xMax + diff * .05 > xdMax ? xdMax : xMax + diff * .05; //moment(xMax).subtract(1, 'month').valueOf();
                            }
                        }

                        // horizontal panning


                        chart.xAxis[0].setExtremes(newMin, newMax);

                        // vertical panning
                        //chart.yAxis[0].setExtremes(yMin + (1 - zoomRatio) * yMax, yMax * zoomRatio);
                    }
                };

                var handler = new Handler();

                $scope.onPanning = function(args){
                    var deltaX = 0;
                    if(args.direction == 4) //right
                        deltaX = 1;

                    if(args.direction == 2) // left
                        deltaX = -1;

                    if(deltaX != 0)
                        handler.move(deltaX, args.deltaY, args.velocityX, args.velocityY, args);
                }

                $scope.onTap = function(args){
                    console.log('onTap', args);
                }

                $scope.onPinching = function(args){
                    handler.zoom(args.scale >= 1 ? 1 : -1);
                }

                $scope.onDoubletap = function(args){
                    handler.zoom(1);
                }

                $timeout(function() {
                    var config = $parse(iAttrs.config)($scope);

                    config.func = function (chart1) {
                        chart = chart1;
                    }

                    iElm.on('mousewheel', function(e) {
                        handler.zoom(e.deltaY);
                    });
                    

                    // OLD: Zoom In/Out
                    //
                    // var setZoom = function(delta) {
                    //     if(!chart) return;

                    //     var xMin = chart.xAxis[0].getExtremes().min;
                    //     var xMax = chart.xAxis[0].getExtremes().max;
                    //     var xdMin = chart.xAxis[0].getExtremes().dataMin;
                    //     var xdMax = chart.xAxis[0].getExtremes().dataMax;
                    //     var yMin = chart.yAxis[0].getExtremes().dataMin;
                    //     var yMax = chart.yAxis[0].getExtremes().dataMax;
                       
                    //     newMin = xMin;
                    //     newMax = xMax;

                    //     var diff = xMax - xMin;
                    //     var diffData = xdMax - xdMin;

                    //     if(delta > 0)
                    //     {
                    //         //zoomin
                    //         if(diff > diffData * .1)
                    //         {
                    //             newMin = xMin + diff * .1; //moment(xMin).add(1, 'month').valueOf();
                    //             newMax = xMax - diff * .1; //moment(xMax).subtract(1, 'month').valueOf();
                    //         }
                    //     }
                    //     else
                    //     {
                    //         //zoomout
                    //         if(diff < diffData)
                    //         {
                    //             newMin = xMin - diff * .1; //moment(xMin).add(1, 'month').valueOf();
                    //             newMax = xMax + diff * .1; //moment(xMax).subtract(1, 'month').valueOf();
                    //         }
                    //     }

                    //     // horizontal panning
                    //     chart.xAxis[0].setExtremes(newMin, newMax);
                        
                    //     // vertical panning
                    //     //chart.yAxis[0].setExtremes(yMin + (1 - zoomRatio) * yMax, yMax * zoomRatio);
                    // };




                    //
                    // OLD: Old panning implementation version
                    //      using hammerjs now to support touch gestures
                    // 
                    // 
                    //  var newMin = 0;
                    //  var newMax = 0;
                    //
                    // iElm.bind('mousedown', function(e) {
                    //     mouseDown = 1;
                    // });

                    // iElm.bind('mouseup', function(e) {
                    //     mouseDown = 0;
                    // });
                    //
                    // iElm.bind('mousemove', function(e) {
                    //     if(!chart) return;
                    //     return;
                    //     if (mouseDown == 1) {

                    //         var xExtremes = chart.xAxis[0].getExtremes();
                    //         var range = xExtremes.max - xExtremes.min;
                    //         var step = range * .05;

                    //         // left and right 

                    //         if (e.pageX > lastX) {

                    //             // tap slide right

                    //             // limit to START of data

                    //             var newMin = xExtremes.dataMin < xExtremes.min - step ? xExtremes.min - step : xExtremes.dataMin;
                    //             var newMax = xExtremes.dataMin < xExtremes.min - step ? xExtremes.max - step : xExtremes.dataMin + range;

                    //             $scope.$apply(function(){
                    //                 chart.xAxis[0].setExtremes(newMin, newMax);
                    //             })
                    //         }
                    //         else if (e.pageX < lastX) {

                    //             // tap slide left

                    //             // limit to END of data

                    //             var newMin = xExtremes.dataMax > xExtremes.max + step ? xExtremes.min + step : xExtremes.dataMax - range;
                    //             var newMax = xExtremes.dataMax > xExtremes.max + step ? xExtremes.max + step : xExtremes.dataMax;

                    //             $scope.$apply(function(){
                    //                 chart.xAxis[0].setExtremes(newMin, newMax);
                    //             });

                    //         }

                    //         // up and down 

                    //         if (e.pageY > lastY) {
                    //             var ydiff = 1 * (e.pageY - lastY);
                    //             var yExtremes = chart.yAxis[0].getExtremes();
                    //             $scope.$apply(function(){
                    //                 chart.yAxis[0].setExtremes(yExtremes.min + ydiff, yExtremes.max + ydiff);
                    //             });
                    //         }
                    //         else if (e.pageY < lastY) {
                    //             var ydiff = 1 * (lastY - e.pageY);
                    //             var yExtremes = chart.yAxis[0].getExtremes();
                    //             $scope.$apply(function(){
                    //                 chart.yAxis[0].setExtremes(yExtremes.min - ydiff, yExtremes.max - ydiff);
                    //             });
                    //         }
                    //     }
                    //     lastX = e.pageX;
                    //     lastY = e.pageY;
                    // }); // -- mousemove

                }); // -- timeout

            }
        };
    }]);

    // (function(H) {
    //     H.wrap(H.Chart.prototype.initReflow = function () {
    //         var chart = this;
            
    //         var redraw = function (e) {
    //             if(chart && chart.options) {
    //                 setTimeout(function(){
    //                     chart.reflow(e);
    //                     chart.redraw(e);
    //                 });
    //             }
    //         };


    //         H.addEvent(window, 'resize', redraw);
    //         H.addEvent(chart, 'destroy', function () {
    //             H.removeEvent(window, 'resize', redraw);
    //         });
    //     });
    // })(Highcharts)
},{}],45:[function(require,module,exports){
(function (window, angular, undefined) {

    'use strict';

    angular.module('ksSwiper', [])
        .directive('ksSwiperContainer', SwiperContainer)
        .directive('ksSwiperSlide', SwiperSlide);

    function createUUID() {
        // http://www.ietf.org/rfc/rfc4122.txt
        var s = [];
        var hexDigits = "0123456789abcdef";
        for (var i = 0; i < 36; i++) {
            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
        }
        s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
        s[8] = s[13] = s[18] = s[23] = "-";

        var uuid = s.join("");
        return uuid;
    }

    /* @ngInject */
    function SwiperContainer() {
        return {
            restrict: 'E',
            transclude: true,
            scope: {
                onReady: '=',
                slidesPerView: '=',
                slidesPerColumn: '=',
                spaceBetween: '=',
                parallax: '=',
                parallaxTransition: '@',
                paginationIsActive: '=',
                paginationClickable: '=',
                showNavButtons: '=',
                showScrollbar:"=",
                loop: '=',
                autoplay: '=',
                initialSlide: '=',
                containerCls: '@',
                paginationCls: '@',
                slideCls: '@',
                direction: '@',
                swiper: '=',
                overrideParameters: '=',
                swiperHeight: '=',
                freeMode: '=',
                allowSwipeToNext: '=',
                noSwipingClass: '=',
                noSwiping: '=',
                mousewheelControl: '='
            },
            controller: ['$scope', '$element', '$timeout', function ($scope, $element, $timeout) {
                var self = this;
                var uuid = createUUID();

                $scope.swiper_uuid = uuid;
                // directive defaults
                var params = {
                    slidesPerView: $scope.slidesPerView || 1,
                    slidesPerColumn: $scope.slidesPerColumn || 1,
                    spaceBetween: $scope.spaceBetween || 0,
                    direction: $scope.direction || 'horizontal',
                    loop: $scope.loop || false,
                    initialSlide: $scope.initialSlide || 0,
                    showNavButtons: false,
                    scrollbarHide: false,
                    freeMode: $scope.freeMode || false,
                    roundLengths: true,
                    scrollbarDraggable: true,
                    height: $scope.swiperHeight || 'auto',
                    allowSwipeToPrev: $scope.allowSwipeToPrev || true,
                    allowSwipeToNext: $scope.allowSwipeToNext || true,
                    noSwipingClass: $scope.noSwipingClass || 'swiper-no-swiping',
                    noSwiping: $scope.noSwiping || false,
                    setWrapperSize: true,
                    mousewheelControl: $scope.mousewheelControl || false
                };

                
                if (!angular.isUndefined($scope.autoplay) && typeof $scope.autoplay === 'number') {
                    params = angular.extend({}, params, {
                        autoplay: $scope.autoplay
                    });
                }

                if ($scope.paginationIsActive === true) {
                    params = angular.extend({}, params, {
                        paginationClickable: $scope.paginationClickable || true,
                        pagination: '#paginator-' + $scope.swiper_uuid
                    });
                }

                if ($scope.showNavButtons === true) {
                    params.nextButton = '#nextButton-' + $scope.swiper_uuid;
                    params.prevButton = '#prevButton-' + $scope.swiper_uuid;
                }

                if ($scope.showScrollbar === true) {
                    params.scrollbar = '.swiper-scrollbar';
                }

                if ($scope.overrideParameters) {
                    params = angular.extend({}, params, $scope.overrideParameters);
                }

                var containerCls = $scope.containerCls || '';

                $timeout(function () {
                    var swiper = null;

                    if (angular.isObject($scope.swiper)) {
                        $scope.swiper = new Swiper($element[0].firstChild, params);
                        swiper = $scope.swiper;
                    } else {
                        swiper = new Swiper($element[0].firstChild, params);
                    }


                    // Keep instance to destroy
                    $scope.swiper = swiper;

                    //If specified, calls this function when the swiper object is available
                    if (!angular.isUndefined($scope.onReady)) {
                        $scope.$apply(function() {
                            $scope.onReady({
                                swiper: swiper
                            });
                        });

                    }

                });

                $scope.$on('$destroy', function () {
                    if($scope.swiper)
                        $scope.swiper.destroy();
                });
            }],

            link: function (scope, element, attrs) {

                var uuid = scope.swiper_uuid;

                var paginatorId = "paginator-" + uuid;
                var prevButtonId = "prevButton-" + uuid;
                var nextButtonId = "nextButton-" + uuid;

                var containerElement = element[0];

                angular.element(containerElement.querySelector('.swiper-pagination'))
                    .attr('id', paginatorId);

                angular.element(containerElement.querySelector('.swiper-button-next'))
                    .attr('id', nextButtonId);

                angular.element(containerElement.querySelector('.swiper-button-prev'))
                    .attr('id', prevButtonId);
            },

            template: '<div class="swiper-container {{containerCls}}">' +
                '<div class="parallax-bg" data-swiper-parallax="{{parallaxTransition}}" ng-show="parallax"></div>' +
                '<div class="swiper-wrapper" ng-transclude></div>' +
                '<div class="swiper-pagination {{paginationCls}}"></div>' +
                '<div class="swiper-button-next" ng-show="showNavButtons"></div>' +
                '<div class="swiper-button-prev" ng-show="showNavButtons"></div>' +
                '<div class="swiper-scrollbar" ng-show="showScrollbar"></div>' +
                '</div>'
        };
    }

    /* @ngInject */
    function SwiperSlide() {
        return {
            restrict: 'E',
            require: '^ksSwiperContainer',
            transclude: true,
            template: '<div class="swiper-slide" ng-transclude></div>',
            replace: true
        };
    }

})(window, angular, undefined);
},{}],46:[function(require,module,exports){
angular.module('partial', [])
.directive('partial', ['$rootScope', '$injector', '$compile', '$injector', function ($rootScope, dialogService, $compile, $injector) {
    return {
        restrict: "EA",
        scope: { config: '=partial' },
        link: function ($scope, $element, $attrs) {
            //watch for config changes
            $scope.$watch('config', function (value) {
                if (!$scope.config || !$scope.config.view) {
                    console.log('empty');
                    $element.empty();
                    return;
                }

                var template = '<div ng-include="\'' + $scope.config.view + '\'" ' + ($scope.config.ctrl ? ' ng-controller="' + $scope.config.ctrl + '" ' : ' ') + '></div>';
                var cTemplate = $compile(template)($scope);
                $element.append(cTemplate);
            });

        }
    };
}]);
},{}],47:[function(require,module,exports){
angular.module('ui.grid.custom', ['ui.grid.custom.pager']);




/* ionic-scroll never receives drag event. Unbind mouse event from grid  */
angular.module('ui.grid.custom.unbindEvents', [])
.directive('unbindEvents', ['$parse', '$timeout', '$window', function ($parse, $timeout, $window) {}])
.config(['$provide', function ($provide) {
	$provide.decorator('Grid', function ($delegate,$timeout) {
		$delegate.prototype.renderingComplete = function(){
			if (angular.isFunction(this.options.onRegisterApi)) {
				this.options.onRegisterApi(this.api);
			}
			this.api.core.raise.renderingComplete( this.api );
			$timeout(function () {
				var $viewport =  $('#'+this.id+'-grid-container');
				['touchstart', 'touchmove', 'touchend','keydown', 'wheel', 'mousewheel', 'DomMouseScroll', 'MozMousePixelScroll']
					.forEach(function (eventName) {
						$viewport.unbind(eventName);
					});
			}.bind(this));
		};
		return $delegate;
	});
}]);





angular.module('ui.grid.custom.pager', [])
    .directive('uiGridDynamicPager', ['$parse', '$timeout', '$window', function ($parse, $timeout, $window) {
        return {
            replace: false,
            link: function ($scope, element, attrs) {

                var rePage = function () {
                    var headerHeight = $(element).find('.ui-grid-header').height();
                    //var rowHeight = $scope.gridOptions1.rowHeight;
                    var rowHeight = $(element).find('.ui-grid-row').height();
                    var footerHeight = $(element).find('.table-footer').height();

                    rowHeight = rowHeight > 0 ? rowHeight : 55; 

                    var config = $parse(attrs.uiGrid)($scope);
                    var height = $(element).height();
                    var count = config.data ? config.data.length : 0;
                    var minHeight = headerHeight + rowHeight + footerHeight;

                    if (height < minHeight) {
                        height = minHeight;
                        //$(element).parent().css('min-height', minHeight);
                    }


                    var rows = Math.floor((height - headerHeight - footerHeight) / rowHeight);
                    config.paginationPageSize = rows;
                }

                // on window resize 
                angular.element($window).on('resize', function () {
                    $timeout(function() {
                        rePage();
                    }, 1000);
                });

                // on $digest
                $scope.$watch(function () {
                    rePage();
                });

                // on Init
                $timeout(function() {
                    rePage();
                });
            }
        }
    }])
},{}],48:[function(require,module,exports){
angular.module('ui.tree.directives', [])
    .directive('uiTreeWrapper', function () {
      return {
            controller: ['$scope', '$rootScope', '$timeout', '$window', function($scope, $rootScope, $timeout, $window) {
                $scope.initialWidth = 250;
                $scope.wrapperWidth = 250; 
                $scope.wrapperStyle = {'min-width': '250px'};

                // child directive reporting
                this.reportWidest = function(childWidth)    {
                    //$scope.wrapperWidth = childWidth + 40 > $scope.wrapperWidth ? childWidth + 40 : $scope.wrapperWidth;
                    //$scope.wrapperStyle['min-width'] = $scope.wrapperWidth + 'px';

                    $timeout(function(){
                        var widest = $scope.initialWidth;
                        $('[ui-tree-wrapper]').find('[data-collapsed] span:visible').each(function(){
                            var minWidth = $(this).offset().left + $(this).width();
                            widest = widest > minWidth ? widest : minWidth;  
                        });
                        $scope.wrapperStyle['min-width'] = (widest + 40) + 'px';
                        $scope.resize();
                    });

                };

                $scope.resize = function(){
                    $timeout(function () {
                        $rootScope.$broadcast('layout-resize');
                    });
                }

                // expand on hover 
                $scope.onMouseOver = function(){
                    //$scope.wrapperStyle = {'min-width': $scope.wrapperWidth + 'px'};
                    $scope.resize();
                }

                // collapse on blur 
                $scope.onMouseLeave = function(){
                    //$scope.wrapperStyle = {'min-width': $scope.wrapperWidth + 'px'};
                    // TODO: Find intuitive way to shrink panel, likely with pin button
                    // $scope.wrapperStyle = {'min-width': $scope.initialWidth + 'px'};
                    $scope.resize();
                }
            }],
        }
    })
    .directive('uiTreeSize', ['$parse', '$timeout', '$window', function ($parse, $timeout, $window) {
        return {
            replace: false,
            require: '^uiTreeWrapper',
            link: function ($scope, element, attrs, ctrl) {

                $scope.$watch(function() {return element.attr('data-collapsed'); }, function(newValue){
                    //await expand/collapse completes
                    $timeout(function(){

                        // Version 1: grow/shrink
                        // var widest = 0;
                        // //find and report widest to parent
                        // $(element).find('span:visible').each(function(){
                        //     var minWidth = $(this).offset().left + $(this).width();
                        //     var widest = widest > minWidth ? widest : minWidth;  
                        //     ctrl.reportWidest(minWidth);
                        // });

                        // Version 2: grow/shrink on expand/collapse
                        ctrl.reportWidest();

                    })
                });

            }
        }
    }])

    .directive('uiGridDatetimeEdit', ['uiGridConstants', 'uiGridEditConstants', '$compile', function (uiGridConstants, uiGridEditConstants, $compile) {
            return {
                scope: true,
                compile: function () {
                    return {
                        pre: function ($scope, $elm, $attrs) {
                            console.log('pre');
                        },
                        post: function ($scope, $elm, $attrs) {

                            //set focus at start of edit
                            $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function () {
                                console.log('Custom Directive: Begun the cell event');

                                if($('#uiGridDateEditCtrl').length){
                                    console.log('element exists');
                                }else{
                                    var offset = $($elm).offset();
                                    console.log(offset);
                                    var ctrl = $(
                                        '<div id="uiGridDateEditCtrl" class="ui-grid-datetime-ctrl" style="position: fixed;">' +
                                        '   <uib-datepicker template-url="template/daterange-datepicker.html" ng-model="row.entity[\'date\']" starting-day="1" show-weeks="false" class="datepicker"></uib-datepicker>' +
                                        '</div>');
                                    ctrl.css({ 
                                        top:offset.top + $($elm).outerHeight(), 
                                        left: offset.left, 
                                        width: $($elm).width(), 
                                        height: '200px',
                                        'z-index': 10
                                    });
                                    ctrlTemplate = angular.element($compile(ctrl)($scope));
                                    $('body').append(ctrlTemplate);
                                }
                                

                                // $elm[0].focus();
                                // $elm[0].style.width = ($elm[0].parentElement.offsetWidth - 1) + 'px';


                                // //for bootstrap dropdown
                                // $elm.on('change', function (evt) {
                                //     console.log('Custom Directive: blur() :  the dropdown just blurred');
                                //     $scope.stopEdit(evt);
                                // });


                                // //for boostrap datepicker 
                                // $elm.on('blur', function (evt) {
                                //     console.log('Custom Directive: blur() :  the calender blurred using onblur()');
                                //     $scope.stopEdit(evt);
                                // });
                            });


                            $scope.stopEdit = function (evt) {
                                // no need to validate a dropdown - invalid values shouldn't be
                                // available in the list
                                console.log('Custom Directive: stopEdit() :  Now stopping the edit functionality');
                                //$scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                            };

                            $elm.on('keydown', function (evt) {
                                // switch (evt.keyCode) {
                                //     case uiGridConstants.keymap.ESC:
                                //         evt.stopPropagation();
                                //         $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                                //         break;
                                //     case uiGridConstants.keymap.ENTER: // Enter (Leave Field)
                                //         $scope.stopEdit(evt);
                                //         break;
                                //     case uiGridConstants.keymap.LEFT:
                                //         $scope.stopEdit(evt);
                                //         break;
                                //     case uiGridConstants.keymap.RIGHT:
                                //         $scope.stopEdit(evt);
                                //         break;
                                //     case uiGridConstants.keymap.UP:
                                //         evt.stopPropagation();
                                //         break;
                                //     case uiGridConstants.keymap.DOWN:
                                //         evt.stopPropagation();
                                //         break;
                                //     case uiGridConstants.keymap.TAB:
                                //         $scope.stopEdit(evt);
                                //         break;
                                // }
                                return true;
                            });
                        }
                    }
                },
                link: function($scope, $elm, $attrs){
                    console.log('link');
                }
        };
    }]);  
},{}],49:[function(require,module,exports){
angular.module('walkthrough', [])
.directive('walkthrough', ['$rootScope', '$document', '$compile', function ($rootScope, $document, $compile) {
    return {
    	scope: { config: '=walkthrough' },
        controller: ['$scope', '$element', '$window', '$timeout', function ($scope, $element, $window, $timeout) {

			var wndWidth = $(window).outerWidth(),
				wndHeight = $(window).outerHeight();

			var actionsTemplate, overlayTemplate;

            $scope.selected = null;

            $scope.visible = false;
            $scope.isvisible = function () {
                return $scope.visible;
            };

            function Overlay(width, height, left, top) {
                
                //this.width = this.height = this.left = this.top = 0;

                // outer parent
                var outer = $('<div class="outer fadein fadeout" ng-show="isvisible()" />');
                
                // backdrop
                var topbox = $("<div />").css({ top:0, left: 0, width: wndWidth, height: 0 }).appendTo(outer);
                var bottombox = $("<div />").css({ top:wndHeight, left: 0, width: wndWidth, height: 0 }).appendTo(outer);
                var leftbox = $("<div />").css({ top:0, left: 0, width: 0, height: wndHeight }).appendTo(outer);
                var rightbox = $("<div />").css({top:0, left: wndWidth, width: 0, height: wndHeight}).appendTo(outer);
                
                overlayTemplate = angular.element($compile(outer)($scope));
                var body = angular.element(document).find('body');
                body.append(overlayTemplate);


                this.resize = function resize(width, height, left, top) {
                    if (width != null)
                        this.width = width;
                    if (height != null)
                        this.height = height;
                    if (left != null)
                        this.left = left;
                    if (top != null)
                        this.top = top;

                    wndWidth = $(window).outerWidth(),
                	wndHeight = $(window).outerHeight();
                };
                
                this.show = function show() {
                    $scope.visible = true;
                };
                
                this.hide = function hide() {
                    //outer.hide();
                    $scope.visible = false;
                };
                
                this.render = function render(width, height, left, top) {
                    
                    this.resize(width, height, left, top);
                    this.show();
                    
                    topbox.css({
                        top: 0,//this.top - 2,
                        left: 0,//this.left - 2,
                        width: $(window).outerWidth(),
                        height: this.top
                    });
                    bottombox.css({
                        top: this.top + this.height,
                        left: 0,//this.left - 2,
                        width: $(window).outerWidth(),//this.width + 5,
                        height: $(window).outerHeight() - (this.top + this.height)
                    });
                    leftbox.css({
                        top: this.top,
                        left: 0, //this.left - 3,
                        height: this.height,
                        width: this.left
                    });
                    rightbox.css({
                        top: this.top,
                        left: this.left + this.width + 1,
                        height: this.height,
                        width: $(window).width() - (this.left + this.width),
                    });
                    
                };

                this.remove = function(){
                    $(overlayTemplate).remove();
                }

            }
            
            function Dialog() {

	            var actions = $(
	            	'<div class="walkthrough-dialog fadein fadeout ng-hide" ng-show="isvisible()">' +
	            	'	<div class="panel panel-default flex flex-resize flex-column flex-absolute" ng-class="{\'panel-title-less\': !steps[activeStep].title }">' +
	            	'		<div class="panel-heading flex-noresize" ng-show="steps[activeStep].title"></div>' + 
	            	'		<div class="panel-body flex-resize" ng-bind-html="getStepContent() | to_trusted"></div>' +
	            	'		<div class="panel-footer flex-noresize">' + 
	            	'			<button class="btn btn-default fl" ng-click="prev()" ng-show="activeStep > 0">上一项</botton>' + 
	            	'			<button class="btn btn-default fr" ng-click="next()" ng-hide="activeStep == steps.length - 1">下一项</botton>' + 
	            	'			<button class="btn btn-default fr" ng-click="finish()" ng-show="activeStep == steps.length - 1">关闭</botton>' + 
	            	'			<button class="btn btn-link fr" ng-click="finish()" >结束</botton>' + 
	            	'		</div>' + 
	            	'	</div>' + 
	            	'</div>');

	            actionsTemplate = angular.element($compile(actions)($scope));
	            var body = angular.element(document).find('body');
	            body.append(actionsTemplate);

            	this.render = function render(position, width, height, left, top){
                    //this.resize(width, height, left, top);
                    //this.show();
                    var pTop, pLeft;
						pWidth = $(actionsTemplate).outerWidth(),
						pHeight = $(actionsTemplate).outerHeight(),
						pSpace = 15;

                    position = position || 'left';
                	switch(position){
                		case 'top':
                			pTop = top - pHeight;
            				pLeft = left + (width / 2) - (pWidth / 2);

                            pTop = pTop > pSpace ? pTop : pSpace;

                			break;
                		case 'right':
							pTop = top + (height / 2) - (pHeight / 2);
            				pLeft = left + width + pSpace;

							pTop = pTop < top ? top : pTop; //prevent above target position
							pTop = pTop + pHeight > wndHeight ? wndHeight - pHeight - pSpace : pTop; //prevent window overflow position 
                			break;
                		case 'bottom':
                			pTop = top + height + pSpace;
                			pLeft = left + (width / 2) - (pWidth / 2); 
                            
                            if(pLeft + pWidth > wndWidth) // prevent window overflow horizontaly
                                pLeft = wndWidth - pWidth - pSpace;

                			break;
                		case 'left':
							pTop = top + (height / 2) - (pHeight / 2);
							pLeft = left - pWidth - pSpace;

							pTop = pTop < top ? top : pTop; //prevent above target position
							pTop = pTop + pHeight > wndHeight ? wndHeight - pHeight - pSpace : pTop; //prevent window overflow position 
                			break;
                        case 'inside':
                            pTop = top + (height / 2) - (pHeight / 2);
                            pLeft = left + (width / 2) - (pWidth / 2);
                            break;
                	}
                    actionsTemplate.css({
                    	top: pTop + 'px',
                    	left: pLeft + 'px'
                    });
            	}

                this.remove = function(){
                    $(actionsTemplate).remove();
                }
            }


            // Init overlay
            var overlay = new Overlay($(window).outerWidth(), $(window).outerHeight(), 0, $(window).scrollTop());
            var dialog = new Dialog();
            

            $(window).bind('resize', function(){
            	wndWidth = $(window).outerWidth();
				wndHeight = $(window).outerHeight();

        		if($scope.visible)
        			$scope.select($scope.steps[$scope.activeStep]);
            });

            /**********************************************
            * 
            * Dialog actions
            * 
            *********************************************/
            
            // Handler for outside event to highlight element
            $scope.select = function(step) {      
                $timeout(function () {
                    $scope.selected = $(step.target);

                    if($($scope.selected).is(":visible")){
                        var offset = $scope.selected.offset();
                        overlay.render($scope.selected.outerWidth(), $scope.selected.outerHeight(), offset.left, offset.top);
                        dialog.render(step.position, $scope.selected.outerWidth(), $scope.selected.outerHeight(), offset.left, offset.top);
                    }
                    else{
                        $scope.next();
                    }

                });
            }    


			var onShowWalkthrough = $rootScope.$on('walkthrough:show', function (opts) {
            	$scope.start();
        	});
            
			var onHideWalkthrough = $rootScope.$on('walkthrough:hide', function () {
				if(overlay){
	            	overlay.render($(window).outerWidth(), $(window).outerHeight(), 0, $(window).scrollTop());
	            	overlay.hide();
				}
				$scope.activeStep = 0;
        	});

            $scope.steps = [];
            $scope.activeStep = 0;

            $scope.getStepTemplate = function(){
            	if($scope.visible)
            		return $scope.steps[$scope.activeStep].templateUrl;
            }

            $scope.getStepContent = function(){
                if($scope.visible){
                    var templateElement = $('#' + $scope.steps[$scope.activeStep].templateId);
                    console.log(templateElement);
                    if(templateElement)
                        return templateElement.html();
                    else
                        return 'Walkthrough step is not configured.';
                }
            }

            this.addStep = function(step){
                //prevent duplicates and steps defined in repeater
                var exists = _.filter($scope.steps, function(item){
                    if(item.templateId == step.templateId || (step.groupId && item.groupId == step.groupId)){
                        return item;
                    }
                });

                if(exists.length == 0){

                    //set step order according to element position inside 'walkthrough-content' element 
                    var index = 0;

                    _.each($('#walkthrough-content').children(), function(item){
                        if(item.id == step.templateId){
                            step.order = index;
                            step.position = $(item).attr('position') || step.position;
                        }
                        index++; 
                    });

                    $scope.steps.push(step);
                }
            }

            $scope.start = function(){                           
            	$scope.steps = _.sortBy($scope.steps, function(step) { return step.order; })
        		$scope.select($scope.steps[0]);
            }

			$scope.next = function(){
				$scope.activeStep++;
                if($scope.activeStep > $scope.steps.length - 1){
                    console.log($scope.activeStep);
                    $scope.finish();
                }
                else{
        		    $scope.select($scope.steps[$scope.activeStep]);
                }
            }

			$scope.prev = function(){
				$scope.activeStep--;
        		$scope.select($scope.steps[$scope.activeStep]);
            }

			$scope.finish = function(){
            	overlay.render($(window).outerWidth(), $(window).outerHeight(), 0, $(window).scrollTop());
				overlay.hide();
				$scope.activeStep = 0;
            }            
            
            $scope.$on('$destroy', function () {
            	
                // unbind broadcast event
                onShowWalkthrough(); 
                
                if (overlay)
                    overlay.remove();
                
                if(dialog)
            		dialog.remove();

                $(window).unbind('resize', function() {});

                $scope.steps= [];

                overlay = null;
				dialog = null;
            });
        }]
    }
}])
.directive('walkthroughStep', ['$rootScope', '$parse', function ($rootScope, $parse) {
    return {
        require: '^walkthrough',
        //scope: { config: '=walkthroughStep' },
        link: function link($scope, $elem, $attrs, parentController) {

            // target
            // templateId
            // templateUrl
            // position
            // order
            
            $scope.config = $parse($attrs.walkthroughStep)($scope);

        	var stepConfig = angular.extend({ target: $elem[0] }, $scope.config);
            parentController.addStep(stepConfig);
        }
    };
}])
.run(['$rootScope', function($rootScope){
    
    $rootScope.showWalkthrough = function(evt){
        $rootScope.$broadcast('walkthrough:show', true);
    }
    
}])
},{}],50:[function(require,module,exports){
/********************************************************************
 *
 *
 *  App Directives
 *
 *  - At a high level, directives are markers on a DOM element
 *    (such as an attribute, element name, comment or CSS class)
 *    that tell AngularJS's HTML compiler ($compile) to attach
 *    a specified behavior to that DOM element (e.g. via event listeners),
 *    or even to transform the DOM element and its children.
 *
*********************************************************************/
require('./baidumap.js');
require('./angular.idangero.us.js');
require('./angular.busy.js');
require('./angular.highcharts.redraw.js');
require('./angular.partial.js');
require('./angular.ui-grid.custom.js');
require('./angular.daterange.js');
require('./angular.filehandler.js');
require('./angular.fileinput.js');
require('./angular.ui-tree.directives.js');
require('./angular.walkthrough.js');
require('./app.ui.js');
require('./app.validation.js');
require('./app.shinyapp.js');

angular.module('app.directives', [ 'app.ui', 'app.validation', 'baiduMap', 'ksSwiper', 'daterange', 'busy', 'highcharts.redraw', 'ui.grid.custom', 'ui.tree.directives', 'partial', 'fileHandler', 'fileInput', 'walkthrough', 'app.shinyapp'])


function css(a) {
    var sheets = document.styleSheets, o = {};
    for (var i in sheets) {
        var rules = sheets[i].rules || sheets[i].cssRules;
        for (var r in rules) {
            if (a.is(rules[r].selectorText)) {
                o = $.extend(o, css2json(rules[r].style), css2json(a.attr('style')));
            }
        }
    }
    return o;
}

function css2json(css) {
    var s = {};
    if (!css) return s;
    if (css instanceof CSSStyleDeclaration) {
        for (var i in css) {
            if ((css[i]).toLowerCase) {
                s[(css[i]).toLowerCase()] = (css[css[i]]);
            }
        }
    } else if (typeof css == "string") {
        css = css.split("; ");
        for (var i in css) {
            var l = css[i].split(": ");
            s[l[0].toLowerCase()] = (l[1]);
        }
    }
    return s;
}

},{"./angular.busy.js":40,"./angular.daterange.js":41,"./angular.filehandler.js":42,"./angular.fileinput.js":43,"./angular.highcharts.redraw.js":44,"./angular.idangero.us.js":45,"./angular.partial.js":46,"./angular.ui-grid.custom.js":47,"./angular.ui-tree.directives.js":48,"./angular.walkthrough.js":49,"./app.shinyapp.js":51,"./app.ui.js":52,"./app.validation.js":53,"./baidumap.js":54}],51:[function(require,module,exports){
//shinyapp directive
angular.module('app.shinyapp', [])
.directive('shinyapp',['configService', function (configService) {
	return {
	    restrict: 'E',
	    replace: true,
	    template: '<div class="shinyapp flex rel"><iframe id="shinyapp_frame" height="2600" ng-src="{{embedUrl}}" /></div>',    
	    link: function(scope, el, attr){
	    	scope.bldg_id = attr['bldgId'];
	    	el.find("iframe")[0].onload = function(){
        		scope["onIframeLoaded"]();
      		};
	    },
	    controller: function($scope, $sce){
	       
	       $scope["onIframeLoaded"] = function(){
	         	// after the iframe has loaded, send bldg_id to the iframe
	         	var frame = document.getElementById('shinyapp_frame');
                console.log("send bldg_id " + $scope.bldg_id + " to iframe");
                frame.contentWindow.postMessage($scope.bldg_id, '*');
	       };
	       var p=configService.settings;

	       p.then(function(data){
	       	console.log(data);
	       	$scope["embedUrl"] = $sce.trustAsResourceUrl(data.API_IP+'/energyinsight/summary/');
	       },
	       function(err){
	       	console.log(err);
	       })

	       }
  	};
}])
},{}],52:[function(require,module,exports){
angular.module('app.ui', [])
.directive('dialogPrompt', ['$rootScope', '$parse', '$compile', '$injector', function ($rootScope, $parse, $compile, $injector) {
    return {
        restrict: "EA",
        scope: { config: '=dialogPrompt'},
        link: function ($scope, $element, $attrs) {

            var cTemplate;
            //$scope.config = $parse($attrs.dialogPrompt)($scope);

            var initPrompt = function(){
                $scope.config = $parse($attrs.dialogPrompt)($scope);
                if(!$scope.config) return;
                
                $scope.config.show = function(){ $scope.open();}
                $scope.config.hide = function(){ $scope.close();}
            }
            initPrompt();

            if(!$scope.config) return;

            $scope.open = function(){

                var container = $scope.config.containerID ? $('#' + $scope.config.containerID) : $($element);
                //var childScope = angular.element(container).scope();

                var template =
                    '<div class="flex flex-row flex-center flex-absolute" style="flex-self-center" ng-show="config.isVisible">' +
                    '   <form name="myForm" class="flex flex-resize">' + 
                    '       <div class="dialog-prompt-backdrop" ng-click="config.onCancel()"></div>' + 
                    '       <div class="panel panel-embedded panel-light panel-holo dialog-prompt ma flex flex-column flex-self-center">'+
                    '           <div class="heading"><h3 ng-bind="config.title"></h3></div>' +
                    '           <div class="body p15" ng-include="\'' + $scope.config.view + '\'" ' + ($scope.config.ctrl ? ' ng-controller="' + $scope.config.ctrl + '" ' : ' ') + '></div>' +
                    '           <div class="footer p15" ng-hide="config.hideFooter">' +
                    '               <button class="btn btn-default fr" ng-click="config.onOk()" ng-disabled="myForm.$invalid ' + ($scope.config.isClean ? ' || config.isClean()' : '') + '">OK</button>' +
                    '               <button class="btn btn-link fr" ng-click="config.onCancel()">CANCEL</button>' +
                    '           </div>' +
                    '       </div>' +
                    '   </form>' +
                    '</div>';

                cTemplate = $compile(template)($scope);
                angular.element(container).append(cTemplate);
                $scope.config.isVisible = true;
            }

            $scope.close = function(){
                $scope.config.isVisible = false; 
                if(cTemplate)
                    cTemplate.remove();
            }

            $scope.$on('$destroy', function(){
                if(cTemplate)
                    cTemplate.remove();
            });
        }
    };
}])
.directive('dialogPromptContainer', ['$rootScope', '$parse', '$compile', '$injector', function ($rootScope, $parse, $compile, $injector) {
    return {
        require: '^dialogPrompt',
        link: function($scope, $element, $attrs, parentCtrl){


        }
    }
}])
.directive('nanoscroll', ['$timeout', function ($timeout) {
    return {
        link: function (scope, elem, attrs, ctrl) {
            $timeout(function () {
                $(elem).nanoScroller({preventPageScrolling: true})    
            }, 5000);
        }
    }
}])
.directive('postRender',['$timeout', function (timer) {
    return {
        link: function (scope, elem, attrs, ctrl) {
            timer(function () {
                $('.nano').nanoScroller({preventPageScrolling: true})    
             }, 2000);
        }
    }
}])
.directive('confirmOnExit', ['$parse', '$rootScope', function($parse, $rootScope) {
    return {
        link: function($scope, elem, attrs) {

            // window.onbeforeunload = function(){
            //     $scope.formName = $parse(attrs.name)($scope);
            //     if ($scope.formName.$dirty) {
            //         return "Would you like to discard changes?";
            //     }
            // }
            $rootScope.$on('$stateChangeStart', function(event, next, current) {
                $scope.formName = $parse(attrs.name)($scope);
                if ($scope.formName && $scope.formName.$dirty) {
                    if(!confirm("Would you like to discard changes?")) {
                        event.preventDefault();
                    }
                }
            });
        }
    };
}])
.directive('expandableList', ['$rootScope', '$window', '$timeout', '$animateCss', function($rootScope, $window, $timeout, $animateCss){
    // Runs during compile
    return {
        // name: '',
        // priority: 1,
        // terminal: true,
        scope: { items: '=' }, // {} = isolate, true = child, false/undefined = no change
        // controller: function($scope, $element, $attrs, $transclude) {},
        // require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
        // restrict: 'A', // E = Element, A = Attribute, C = Class, M = Comment
        template: 
            '<div>' +
            '   <ul class="expandableList">' +
            '       <li ng-show="items.length == 0" style="text-align=center">---</li>' +
            '       <li ng-repeat="item in items" ng-bind="item.text" ng-click="onClick(item, $index, $event)"></li>' +
            '   <ul>' +
            '</div>',
        // templateUrl: '',
        replace: true,
        // transclude: true,
        // compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
        link: function($scope, iElm, iAttrs, controller) {
            
            $scope.collapsed = true;
            
            var listTop = $(iElm).offset().top;
            $(iElm).find('ul').css({transition: 'all 1s ease'});

            var itemHeight = 0;

            // Init
            $(iElm[0]).css({ overflow: 'hidden', height: '0px', transition: 'all 1s ease'});
            // item.find("li").each(function () {
                
            // });

            angular.element($window).bind('resize', function() {
                if(!$scope.collapsed)
                {
                    $timeout(function(){
                        listTop = $(iElm).offset().top;

                        var listHeight = itemHeight * $scope.items.length;
                        var listHeightMax = $(window).height() - listTop;
                        var listHeightVisible = listHeight  > listHeightMax ? listHeightMax : listHeight;

                        // Adjust list to visible height 
                        $(iElm).css({ height: listHeightVisible });
                    }, 0);
                }
            })

            $scope.onClick = function(item, index, $event){

                itemHeight = $($event.target).outerHeight();

                var listHeight = itemHeight * $scope.items.length;

                // TODO: Enable page scroll calculation 
                // $(window).scroll(function() { //when window is scrolled
                // log(eTop - $(window).scrollTop());
                // });

                //var eTop =  //get the offset top of the element
                //eTop - $(window).scrollTop()); //position of the ele w.r.t window


                if($scope.collapsed)
                {
                    $scope.collapsed = false;   

                    var listHeight = itemHeight * $scope.items.length;
                    var listHeightMax = $(window).height() - listTop;
                    var listHeightVisible = listHeight  > listHeightMax ? listHeightMax : listHeight;
                    
                    //expand

                    var foldOuter = $animateCss(iElm,
                        {
                            to: { height: listHeightVisible + 'px' },
                            duration: 1,
                            easing: 'cubic-bezier(0.19, 1, 0.22, 1)'
                        }
                    )

                    var inner = iElm[0].querySelector('ul');

                    var foldInner = $animateCss(angular.element(inner),
                        {
                          // BUG - If I set `from` I expect it to assign those values immediately and 
                          //       then animate to the `to` values. This does NOT happen!
                          //from    : {transform: 'translateY('+listHeightVisible+'px)'},
                          to      : {transform: 'translateY(0px)'},
                          duration: 1,
                          easing: 'cubic-bezier(0.77, 0, 0.175, 1)'
                        }
                    );

                    foldInner.start().then(function(){
                        console.log('expanding inner done');
                    });

                    foldOuter.start().then(function(){
                        console.log('expanding outer done');
                    }); 
                }
                else
                {
                    $scope.collapsed = true;   

                    var transformY = itemHeight * index * -1;

                    //collapse
                    
                    var itemTop = index * itemHeight;

                    var outer = $animateCss(iElm,
                        {
                            to: { height: itemHeight + 'px' },
                            duration: 1,
                            easing: 'cubic-bezier(0.77, 0, 0.175, 1)'
                        }
                    );

                    var inner = iElm[0].querySelector('ul');
                    var inner = $animateCss(angular.element(inner),
                        {
                          to      : { transform: 'translateY(' + transformY + 'px)' },
                          duration: 1,
                          easing: 'cubic-bezier(0.19, 1, 0.22, 1)'
                        }
                    );

                    inner.start().then(function(){
                        $timeout(function(){
                            console.log('folding inner done');
                        })
                    }); 

                    outer.start().then(function(){
                        $timeout(function(){
                            console.log('folding outer done');
                            $rootScope.$state.go(item.href, $rootScope.$stateParams);
                        })
                    });    
                     
                }

            }

            $scope.$watch('items', function(){
                if(!$scope.items || $scope.items.length == 0)
                    return;

                $timeout(function(){
                    var item = _.max($(iElm).find('li'), function(item){ return $(item).outerHeight(); });
                    itemHeight = $(item).outerHeight();
                    $(iElm[0]).css({ height: itemHeight + 'px' });
                },0);    

            })

        }
    };
}])
.directive('buildingList', ['$rootScope', '$window', '$timeout', '$animateCss', '$templateCache', '$compile', '$http', '$ionicListDelegate', function($rootScope, $window, $timeout, $animateCss, $templateCache, $compile, $http, $ionicListDelegate){
    // Runs during compile
    return {
        scope: { config: '=' },
        replace: false,
        link: function($scope, iElm, iAttrs, controller) {

            var render = function (){
                $http.get($scope.config.template, { cache: $templateCache }).then(function(response) {
                    iElm.html(response.data);
                    $compile(iElm.contents())($scope);
                });
            }

            $scope.onSelect = function(e, item){
                e.preventDefault();
                e.stopPropagation();
                if($scope.config.onSelect)
                    $scope.config.onSelect(item);
            }

            $scope.onEdit = function(item){
                $ionicListDelegate.closeOptionButtons();

                if($scope.config.onEdit)
                    $scope.config.onEdit(item);
            }

            $scope.onClick = function(item, index, e){
                if($scope.config.onClick)
                    $scope.config.onClick(item, index, e);
                item.__selected = true;
            }

            $scope.$watchCollection('config', function(newValue, oldValue, scope) {
                render();                    
            });

            render();
        }
    };
}])
.directive('clickForOptions', ['$ionicGesture',  function($ionicGesture) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
             $ionicGesture.on('tap', function(e){

                // Grab the content
                var content = element[0].querySelector('.item-content');

                // Grab the buttons and their width
                var buttons = element[0].querySelector('.item-options');

                if (!buttons) {
                    console.log('There are no option buttons');
                    return;
                }
                var buttonsWidth = buttons.offsetWidth;

                ionic.requestAnimationFrame(function() {
                    content.style[ionic.CSS.TRANSITION] = 'all ease-out .25s';

                    if (!buttons.classList.contains('invisible')) {
                        content.style[ionic.CSS.TRANSFORM] = '';
                        setTimeout(function() {
                            buttons.classList.add('invisible');
                        }, 250);                
                    } else {
                        buttons.classList.remove('invisible');
                        content.style[ionic.CSS.TRANSFORM] = 'translate3d(-' + buttonsWidth + 'px, 0, 0)';
                    }
                });     

            }, element);
        }
    };
}])

.directive('lazyHighcharts', ['$compile', '$timeout', '$rootScope', function($compile, $timeout, $rootScope) {
    return {
        scope: { config: '=lazyHighcharts' },
        link: function ($scope, element, attrs) {
            var tmpl;

            $scope.$watch('config', function (newOptions, oldOptions, scope) {
                
                //if (newOptions === oldOptions) return;
                $scope.chartOptions1 = {};
                
                //console.log('lazy-highcharts config changed:', newOptions);

                $timeout(function(){
                    if(tmpl){
                        angular.element(tmpl).remove();    
                    }


                    $scope.chartOptions1 = newOptions;

                    var html = '<highchart config="chartOptions1" class="flex-absolute" style="top: 15px; right: 15px; bottom: 15px; left: 15px;" highcharts-panning></highchart>'
                    tmpl = $compile(html)($scope);
                    angular.element(element).append(tmpl);

                    $timeout(function(){
                        $rootScope.resize();
                    })                    
                })

            }, true);
        }
    };
}])
/***************************************************
 * 
 * Splitter
 * 
 **************************************************/ 

.directive('resizable',[ '$document', '$compile', '$parse', '$rootScope', function($document, $compile, $parse, $rootScope) {
    return {
        link: function ($scope, $element, $attrs) {

            $scope.lastWidth = 500;

            // Resizer

            var resizerTemplate = angular.element('<div id="sidebar-resizer"></div>');
            var resizer = angular.element($compile(resizerTemplate)($scope));
            $($element).append(resizer);

            // get config
            $scope.config = $parse($attrs.resizable)($scope);

            if ($scope.config.current > 0) {
                $($element).css({
                    'max-width': $scope.config.current + 'px',
                });
            }

            // Capture drag

            resizer.on('mousedown', function(event) {
                event.preventDefault();

                $document.on('mousemove', mousemove);
                $document.on('mouseup', mouseup);

                //TODO: upgrade to $broadcast if nessesary
                $rootScope.disableListSwipping = true;
            });



            $scope.show = function(newVal) {
                if(newVal){
                    $($element).css({'max-width': $scope.lastWidth + 'px'});
                } else{
                    $($element).css({'max-width': 0 + 'px'});
                }

            }


            // Resize element

            function mousemove(event) {
                //if ($attrs.resizer == 'vertical') {
                    // Handle vertical resizer
                    var x = event.pageX;
                    var offset = $($element).offset();

                    x = x-offset.left+15; // +15px negative margin
                    
                    //set limits
                    if ($scope.config.max && x > $scope.config.max) {
                       x = $scope.config.max;
                    }

                    if ($scope.config.min && x < $scope.config.min) {
                       x = $scope.config.min;
                    }

                    resizer.css({
                        'left': x + 'px'
                    });

                    $($element).addClass('resizing');

                    $($element).css({
                        'max-width': x + 'px'
                    });
                    $scope.lastWidth = x;

                // } else {
                //     // Handle horizontal resizer
                //     var y = window.innerHeight - event.pageY;

                //     resizer.css({
                //         bottom: y + 'px'
                //     });

                //     $($attrs.resizerTop).css({
                //         bottom: (y + parseInt($attrs.resizerHeight)) + 'px'
                //     });
                //     $($attrs.resizerBottom).css({
                //         height: y + 'px'
                //     });
                // }
            }

            // Unsubscribe from drag

            function mouseup() {
                $($element).removeClass('resizing');
                $document.unbind('mousemove', mousemove);
                $document.unbind('mouseup', mouseup);
                $rootScope.disableListSwipping = false;
            }

        }
    }
}])


/***************************************************
 * 
 * Sketch related
 * 
 **************************************************/ 
.filter('groupByFirstWord', [ '$parse', 'filterWatcher', function ( $parse, filterWatcher ) {
    return function (collection, property) {

        if(!collection || collection.length == 0) {
            return collection;
        }
        //var result = _groupBy(collection);

      return filterWatcher.isMemoized('groupByFirstWord', arguments) || filterWatcher.memoize('groupByFirstWord', arguments, this,
          _groupBy(collection, $parse(property)));


        function _groupBy(collection) {
                var result = {};
                var prop;

                _.forEach(collection, function( elm ) {
                    //prop = getter(elm);
                    
                    var r = /^([\w\-]+)/;
                    var m = r.exec(elm.url);
                    
                    //prop = m[1];
                    if(!m) return;

                    if(!result[m[0]]) {
                        result[m[0]] = [];
                    }
                  result[m[1]].push(elm);
            });
            return result;
        }

    }
}])
.directive('inspector', ['$rootScope', '$ionicGesture', '$timeout', '$compile', '$requestLog', '$ionicModal', function($rootScope, $ionicGesture, $timeout, $compile, $requestLog, $ionicModal) {
    return {
        link: function(scope, element, attrs){
            
            scope._isvisible = true;
            scope.data = $requestLog.list();

            scope.$watchCollection($requestLog.list, function(newValue){
                scope.data = newValue;
            });
            
            var inspectorTemplate = angular.element(
                '<div class="inspector" ng-show="_isvisible">' +
                '   <ion-list>' + 
                '       <ion-item ng-repeat="(key, value) in data | groupByFirstWord: \'url\'"" ng-click="browse(key)">' +
                '               <span ng-bind="key"></span>' +
                '               <span ng-bind="value.length"></span>'  +
                '        </ion-item>' + 
                '   </ion-list>' + 
                '</div>');
            var inspectorElement = angular.element($compile(inspectorTemplate)(scope));
            var body = angular.element(document).find('body');
            body.append(inspectorElement);


            $ionicModal.fromTemplateUrl('template/modal.html', {
                scope: scope,
                animation: 'slide-in-up'
            }).then(function(modal) {
                scope.modal = modal;
            });

            scope.gridData = [];
            scope.browse = function(key){

                scope.gridData = _.filter(scope.data, function(item){
                    console.log('item.url ' , item.url);
                    var m = /^([\w\-]+)/.exec(item.url);
                    return m && key == m[0];
                });

                scope.gridOptions.columnDefs = [
                    {headerName: "url", field: "url", width: 100},
                    {headerName: "data", field: "data", width: 100}
                ]; 
                scope.gridOptions.api.setColumnDefs(scope.gridOptions.columnDefs);
                scope.gridOptions.api.setRowData(scope.gridData);

                scope.modal.show();

                $timeout(function(){
                    scope.gridOptions.api.sizeColumnsToFit();
                });
            }

            var lastTarget;
            var processHover = function(e){
                if(e.target == lastTarget) return;

                var appElement = $(e.target);
                var appScope = angular.element(appElement).scope();

                scope.$apply(function(){
                    lastTarget = e.target;
                    scope.target = (e.target ? $(e.target)[0].tagName : '');
                })

            }

            $(document).bind("mousemove", _.throttle(processHover, 500)); 
            $(document).bind("mousemove", function(e){
                // $(inspectorElement).css('cssText', $(inspectorElement).attr('style') + 
                //          'position: fixed;' +
                //          'top: ' + (e.clientY + 10) + 'px!important;' + 
                //          'left: ' + (e.clientX + 10) + 'px!important;' + 
                //          'width: 300px!important;' + 
                //          'height: 200px!important;' + 
                //          ''
                // );
            });

            //document.oncontextmenu = function() {return false;};

            $(document).mousedown(function(e){ 
                if( e.button == 2 ) { 
                  console.log('scope: ', angular.element(lastTarget).scope()); 
                  return false; 
                } 
                return true; 
            }); 

            $rootScope.$on('$stateChangeStart', function (evt, toState, toParams, fromState, fromParams) {
                $requestLog.add({url: '--- $stateChangeStart ---'});
            });








            var columnDefs = [
                {headerName: "Date", field: "date", width: 100},
                {headerName: "Value", field: "value", width: 100},
            ];

            scope.gridOptions = {
                enableColResize: true,
                columnDefs: columnDefs,
                rowData: [],
            };



        }
    }

}])



.directive('adjustable', ['$rootScope', '$ionicGesture', '$timeout',  function($rootScope, $ionicGesture, $timeout) {
    return {
        link: function(scope, element, attrs){

            //if($rootScope.layoutAdjustable) {
                var offset = $(element).offset();
                var width = $(element).outerWidth();
                var height = $(element).outerHeight();

                //fix element on screen
                $(element[0]).css('cssText', $(element).attr('style') + 
                                         ';position: fixed;' +
                                         'top: ' + offset.top + 'px!important;' + 
                                         'right: ' + offset.right + 'px!important;' + 
                                         'width: ' + width + 'px!important;' + 
                                         'height: ' + height + 'px!important;' + 
                                         ''
                                );

            //}


        }
    }

}])

    
// To create a empty resizable and draggable box
.directive("ceBoxCreator", function ($document, $compile) {
        return {
            restrict: 'A',
            link: function ($scope, $element, $attrs) {
                $element.on("click", function ($event) {
                    
                    var newNode = $compile('<div class="contentEditorBox" ce-drag ce-resize></div>')($scope);
                    placeNode(newNode, $event.pageY - 25, $event.pageX - 25);
                    angular.element($document[0].body).append(newNode);
                });
            }
        }
    })
// To manage the drag
.directive("dragOuter", ['$rootScope', '$document', '$compile', function ($rootScope, $document, $compile) {
        return {
            scope: { element: '=dragOuter' },
            link: function ($scope, $element, $attr) {
                var target = null;
                $scope._isvisible = false;
                
                // create highligter
                var outer = angular.element('<div class="outer fadein fadeout" ng-show="_isvisible" />');
                var bottombox = angular.element("<div />").css("height", 1).appendTo(outer);
                var overlayTemplate = angular.element($compile(outer)($scope));
                var body = angular.element(document).find('body');
                body.append(overlayTemplate);
                
                $scope.isvisible = function () {
                    return $scope._isvisible;
                };
                
                $element.bind("mousedown", function ($event) {
                    $('html').addClass('drag-add');  // set waiting
                    $scope._isvisible = true;
                    $document.bind("mousemove", mousemove);
                    $document.bind("mouseup", mouseup);
                });
                
                function mousemove($event) {
                    
                    // prevent highlight elements            
                    if ($event.target == bottombox[0]) return;
                    
                    // keep destination element
                    target = $event.target;
                    
                    // position highlight
                    var offset = $($event.target).offset();
                    var height = $($event.target).outerHeight();
                    var width = $($event.target).outerWidth();
                    bottombox.css({
                        top: offset.top + height,
                        left: offset.left,
                        width: width
                    });
                }
                
                function mouseup($event) {
                    $scope.$apply(function () {
                        $scope._isvisible = false;

                        var eScope = angular.element($event.target).scope();
                        if (eScope.element == null) return;
                        
                        $rootScope.$broadcast('element:add', { source: $scope.element, destination: eScope.element });

                        eScope.element.properties.elements.push(
                            {
                                title: 'Test',
                                directive: $scope.element,
                                inspectable: true,
                                replace: true,
                                properties: {
                                    cssClass: '',
                                    elements: []
                                }
                            }
                        );

                        //var template = '<div ' + $scope.element + '></div>';
                        //var cTemplate = $compile(template)($scope);
                        //$(target).append(cTemplate);
                    });

                    $('html').removeClass('drag-add');
                    $document.unbind("mousemove", mousemove);
                    $document.unbind("mouseup", mouseup);
                }
            }
    }
}])
// To manage the drag
.directive("ceDrag", function ($document) {
        return function ($scope, $element, $attr) {
            var startX = 0,
                startY = 0,
                startWidth = 0,
                startHeight = 0;

            
            var newElement = angular.element('<div class="draggable"></div>');
        
            var parentWidth = $($element).parent().width();
                parentHeight = $($element).parent().height();
            
            $element.append(newElement);
            newElement.on("mousedown", function ($event) {
                event.preventDefault();
                
                // To keep the last selected box in front
                angular.element(document.querySelectorAll(".contentEditorBox")).css("z-index", "0");
                $element.css("z-index", "1");
                
                startX = $event.pageX - $element[0].offsetLeft;
                startY = $event.pageY - $element[0].offsetTop;
            
                startWidth = $element[0].offsetWidth;
                startHeight = $element[0].offsetHeight;

                $document.on("mousemove", mousemove);
                $document.on("mouseup", mouseup);
            });
            
            function mousemove($event) {
                var top = $event.pageY - startY > 0 ? $event.pageY - startY : 0;
                var left = $event.pageX - startX > 0 ? $event.pageX - startX : 0;
            
                //if(top + startHeight > parentHeight)
                //    top = parentHeight - startHeight;
            
                //if (left + startWidth > parentWidth)
                //    left = parentWidth - startWidth;

                placeNode($element , top, left);
            }
            
            function mouseup() {
                $document.off("mousemove", mousemove);
                $document.off("mouseup", mouseup);
            }
        };
    })
    
// To manage the resizers
.directive("ceResize", function ($document) {
        return function ($scope, $element, $attr) {
            //Reference to the original 
            var $mouseDown;
            
            // Function to manage resize up event
            var resizeUp = function ($event) {

                var lowest = $mouseDown.top + $mouseDown.height,
                    top = $event.pageY - $mouseDown.pageY + $mouseDown.top > lowest ? lowest : $event.pageY - $mouseDown.pageY + $mouseDown.top ,
                    height = $mouseDown.top - top + $mouseDown.height;
            
                    $element.css({
                        top: top + "px",
                        height: height + "px"
                    });
            };
            
            // Function to manage resize right event
            var resizeRight = function ($event) {
            
                var leftest = $element[0].offsetLeft,
                    width = $mouseDown.pageX > leftest ? $event.pageX - $mouseDown.pageX + $mouseDown.width : 0;
            
                    //width = width > $($element).parent().width() ? $($element).parent().width() : width;
                    width = width > $(window).width() ? $(window).width() : width;

                $element.css({
                    width: width + "px"
                });
            };
            
            // Function to manage resize down event
            var resizeDown = function ($event) {
                var uppest = $element[0].offsetTop,
                    height = $event.pageY > uppest ? $event.pageY - $mouseDown.pageY + $mouseDown.height : 0;
                
                $element.css({
                    height: height + "px"
                });
            };
            
            // Function to manage resize left event
            function resizeLeft($event) {
                var rightest = $mouseDown.left + $mouseDown.width,
                    left = $event.pageX - $mouseDown.pageX + $mouseDown.left > rightest ? rightest : $event.pageX - $mouseDown.pageX + $mouseDown.left,
                    width = $mouseDown.left - left + $mouseDown.width;
            
                if(left < 0) {
                    width += left;
                    left = 0;
                }

                $element.css({
                    left: left + "px",
                    width: width + "px"
                });
            };
            
            var createResizer = function createResizer(className , handlers) {
                
                newElement = angular.element('<div class="' + className + '"></div>');
                $element.append(newElement);
                newElement.on("mousedown", function ($event) {
                    
                    $document.on("mousemove", mousemove);
                    $document.on("mouseup", mouseup);
                    
                    //Keep the original event around for up / left resizing
                    $mouseDown = $event;
                    $mouseDown.top = $element[0].offsetTop;
                    $mouseDown.left = $element[0].offsetLeft
                    $mouseDown.width = $element[0].offsetWidth;
                    $mouseDown.height = $element[0].offsetHeight;
                
                    function mousemove($event) {
                        event.preventDefault();
                        for (var i = 0; i < handlers.length ; i++) {
                            handlers[i]($event);
                        }
                    }
                    
                    function mouseup() {
                        $document.off("mousemove", mousemove);
                        $document.off("mouseup", mouseup);
                    }
                });
            }
            
            createResizer('sw-resize' , [resizeDown , resizeLeft]);
            createResizer('ne-resize' , [resizeUp   , resizeRight]);
            createResizer('nw-resize' , [resizeUp   , resizeLeft]);
            createResizer('se-resize' , [resizeDown , resizeRight]);
            createResizer('w-resize' , [resizeLeft]);
            createResizer('e-resize' , [resizeRight]);
            createResizer('n-resize' , [resizeUp]);
            createResizer('s-resize' , [resizeDown]);
        };

    })
.config(['$provide', function($provide) {

    $provide.decorator('$controller', ['$delegate', function($delegate) {

        return function (constructor, locals) {

            // controller name
            var name = arguments[0];
            
            // controller
            var obj = arguments[1];
            
            if(typeof name === 'string'){
                if(arguments[1].$scope.controllerName)
                    arguments[1].$scope.controllerName += ' ' + name;
                else{
                    arguments[1].$scope.controllerName = name;
                }
            }
            var controller = $delegate.apply(null, arguments);

            return angular.extend(function () {
                // if(typeof name === 'string'){
                //     if(locals.$scope.controllerName)
                //         locals.$scope.controllerName += ', ' + name;
                //     else
                //         locals.$scope.controllerName = name;

                // }
                return controller();
            }, controller);
        }

    }]);
}])
.run(['$templateCache', function($templateCache){
    $templateCache.put("template/energy-unit-groupped-list.html",
            '<div class="flex flex-absolute">' +
            '<ion-list ng-repeat="(key, value) in config.datasource() | filter: {type : 1} |  groupBy: \'campus\'" show-delete="false" can-swipe="true">' +
            '   <ion-item class="item-divider">' +
            '       <i class="svg-buildings"></i>' +
            '       <h3 ng-bind="key"></h3>' +
            '   </ion-item>' +
            '   <ion-item ng-mouseenter="config.onMouseEnter(e, item)" ng-mouseleave="config.onMouseLeave(e, item)" ng-repeat="item in value" ng-click="onClick(item, $index, $event)" md-ink-ripple click-for-options ng-class="{ selected: item.__selected, highlighted: item.__highlighted }" ng-if="item.buildingparam"> ' +
            '       <i class="svg-building"></i>' +
            '       <h3 ng-bind="item.name"></h3>' +
            '       <uib-rating class="rating" ng-model="item.value" max="5" state-on="\'icon-star\'" state-off="\'icon-star o3\'" readonly="true">{{item.value}}</uib-rating>' +
            // '       <p ng-bind-html="item.content | to_trusted" style="padding-left: 100px">...</p>' +
            '   </ion-item>' +
            '</ion-list> ' +
            '</div>' +
    '');

    $templateCache.put("template/tree-list.html",
            '<div class="flex flex-absolute" style="top: 56px">' +
            '<ion-list class="energyUnitList">' + 
            '    <ion-item ng-repeat="item in config.data" ng-click="onClick(item)" md-ink-ripple>' + 
            '       <i ng-if="item.type == 1" class="icon-building fs19"></i>' +
            '       <i ng-if="item.type == 2" class="icon-building-6 fs19"></i>' +
            '       <i ng-if="item.type == 3" class="icon-gauge-4 lh24" ng-style="{ \'color\': item.color }"></i>' +
            '       <i ng-if="item.type == 4" class="icon-schedule-2 lh24"></i>' +
            '       <i ng-if="item.type == 7" class="icon-temperature lh24"></i>' +
            '       {{item.name}}' + 
            '       <span class="item-note">' + 
            
            '       </span>' + 
            '       <button ng-if="item.type == 3 && !item.hasNoChildren" class="bar-light button select" ng-click="onSelect($event, item)" style="position: absolute;z-index:5; right: 0; top: 0; height: 100%; align-items: center;display:inline-flex;text-align:center;">' + 
            '           <i class="icon-circle" ng-class="{active: item.color}" ng-style="{background: node.color }"></i>' +        
            '       </button> ' +
            '       <ion-option-button class="button-positive" ng-click="onEdit(item)">Edit</ion-option-button>' +
            '    </ion-item>' + 
            '</ion-list>' +
    '');

    $templateCache.put("template/sitemap.html",
        '<div class="flex flex-absolute list-group sitemap-content">' +
            '<ion-list ng-repeat="(key, value) in config.data" show-delete="false" can-swipe="true">' +
            '   <ion-item class="item-divider">' +
            //'       <i class="icon-minus-square-o"></i>' +
            '       <span ng-bind="key"></span>' +
            '   </ion-item>' +
            '   <ion-item ng-repeat="item in value" ng-click="onClick(item, $index, $event)" ng-class="{selected: item.__selected}" md-ink-ripple click-for-options>' +
            '       <i ng-class="item.icon"></i>' +
            '       <h3 ng-bind="item.name"></h3>' +
            '   </ion-item>' +
            '</ion-list> ' +
        '</div>' +
    '');

}])



function placeNode(node, top, left) {
    $(node).css({
        position: "fixed",
        top: top + "px",
        left: left + "px",
    });
}




},{}],53:[function(require,module,exports){
angular.module('app.validation', [])
.directive('compareTo', function () {
	return {
		require: 'ngModel',
		link: function ($scope, elm, attrs, ctl) {
			$scope.$watch(attrs['compareTo'], function (errorMsg) {
		    	elm[0].setCustomValidity(errorMsg);
		    	ctl.$setValidity('compareTo', errorMsg ? false : true);
			});
		}
	};
})
.directive('mandatory', function(){
	return {
    	restrict: 'A',
    	require: '?ngModel',
    	link: function(scope, elm, attr, ctrl) {
      		if (!ctrl) return;
      		attr.required = true; // force truthy in case we are on non input element

      		ctrl.$validators.required = function(modelValue, viewValue) {
        		return !attr.required || !ctrl.$isEmpty(viewValue);
  			};

	      	attr.$observe('required', function() {
	        	ctrl.$validate();
	      	});
		}
  	};
});
},{}],54:[function(require,module,exports){
/**
 *  A directive which helps you easily show a baidu-map on your page.
 *
 *
 *  Usages:
 *
 *      <baidu-map options='options'></baidu-map>
 *
 *      options: The configurations for the map
 *            .center.longitude[Number]{M}: The longitude of the center point
 *            .center.latitude[Number]{M}: The latitude of the center point
 *            .zoom[Number]{O}:         Map's zoom level. This must be a number between 3 and 19
 *            .navCtrl[Boolean]{O}:     Whether to add a NavigationControl to the map
 *            .scaleCtrl[Boolean]{O}:   Whether to add a ScaleControl to the map
 *            .overviewCtrl[Boolean]{O}: Whether to add a OverviewMapControl to the map
 *            .enableScrollWheelZoom[Boolean]{O}: Whether to enableScrollWheelZoom to the map
 *            .city[String]{M}:         The city name which you want to display on the map
 *            .markers[Array]{O}:       An array of marker which will be added on the map
 *                   .longitude{M}:                The longitude of the marker
 *                   .latitude{M}:                 The latitude of the marker
 *                   .icon[String]{O}:             The icon's url for the marker
 *                   .width[Number]{O}:            The icon's width for the icon
 *                   .height[Number]{O}:           The icon's height for the icon
 *                   .title[String]{O}:            The title on the infowindow displayed once you click the marker
 *                   .content[String]{O}:          The content on the infowindow displayed once you click the marker
 *                   .enableMessage[Boolean]{O}:   Whether to enable the SMS feature for this marker window. This option only available when title/content are defined.
 *
 *  @author      Howard.Zuo
 *  @copyright   Jun 9, 2015
 *  @version     1.2.0
 *
 *  @author fenglin han
 *  @copyright 6/9/2015
 *  @version 1.1.1
 * 
 *  Usages:
 *
 *  <baidu-map options='options' ></baidu-map>
 *  comments: An improvement that the map should update automatically while coordinates changes
 *
 *  @version 1.2.1
 *  comments: Accounding to 史魁杰's comments, markers' watcher should have set deep watch equal to true, and previous overlaies should be removed
 *
 */

'use strict';

var checkMandatory = function (prop, desc) {
    if (!prop) {
        throw new Error(desc);
    }
};

var defaults = function (dest, src) {
    for (var key in src) {
        if (typeof dest[key] === 'undefined') {
            dest[key] = src[key];
        }
    }
};

var baiduMapDir = function (baiduMapApi, $timeout) {

    // Return configured, directive instance

    return {
        restrict: 'E',
        scope: {
            'options': '='
        },
        template: '<div style="width: 100%; height: 100%;"></div>',
        link: function ($scope, element, attrs) {
            var map,
                hoverTimeout,
                previousMarkers = [],
                opts = $scope.options,
                defaultOpts = {
                    navCtrl: true,
                    scaleCtrl: true,
                    overviewCtrl: true,
                    enableScrollWheelZoom: true,
                    zoom: 10
                };

            //Methods
            var openInfoWindow,
                mark;

            // track global mouse position to workaround mouseout event 
            var currentMousePos = { x: -1, y: -1 };
            $(element).mousemove(function(event) {
                currentMousePos.x = event.pageX;
                currentMousePos.y = event.pageY;
            });


            defaults(opts, defaultOpts);
            checkMandatory(opts.center, 'options.center must be set');
            checkMandatory(opts.center.longitude, 'options.center.longitude must be set');
            checkMandatory(opts.center.latitude, 'options.center.latitude must be set');
            checkMandatory(opts.city, 'options.city must be set');

            $timeout(function() {
                baiduMapApi.load().then(function() {

                    // create map instance
                    map = new BMap.Map(element.find('div')[0]);
                    //$(map).height($(window).height());

                    //$(window).resize(function() {
                    //    //$('#map_canvas').height($(window).height());
                    //    console.log($(element).parent().width(), 'x', $(element).parent().height());
                    //    console.log($(element).width(), 'x', $(element).height());
                    //});

                    // init map, set central location and zoom level
                    map.centerAndZoom(new BMap.Point(opts.center.longitude, opts.center.latitude), opts.zoom);
                    if (opts.navCtrl) {
                        // add navigation control
                        map.addControl(new BMap.NavigationControl());
                    }
                    if (opts.scaleCtrl) {
                        // add scale control
                        map.addControl(new BMap.ScaleControl());
                    }
                    if (opts.overviewCtrl) {
                        //add overview map control
                        map.addControl(new BMap.OverviewMapControl());
                    }
                    if (opts.enableScrollWheelZoom) {
                        //enable scroll wheel zoom
                        map.enableScrollWheelZoom();
                    } else {
                        map.disableScrollWheelZoom();
                    }
                    // set the city name
                    map.setCurrentCity(opts.city);


                    if (!opts.markers) {
                        return;
                    }

                    $scope.$watch('options.zoom', function(newValue, oldValue) {

                        if(newValue > oldValue)
                            map.zoomIn();
                        else
                            map.zoomOut();

                        //opts = $scope.options;
                        //map.centerAndZoom(new BMap.Point(opts.center.longitude, opts.center.latitude), opts.zoom);
                        //mark();

                    }, true);

                    $scope.$watch('options.center', function(newValue, oldValue) {

                        opts = $scope.options;
                        map.centerAndZoom(new BMap.Point(opts.center.longitude, opts.center.latitude), opts.zoom);
                        mark();

                    }, true);

                    $scope.$watch('options.markers', function(newValue, oldValue) {

                        mark();

                    }, true);

                    mark();
                },function(err){
                    console.log(err);
                });
            });


            //create markers
            openInfoWindow = function(infoWin) {
                return function() {
                    this.openInfoWindow(infoWin);
                };
            };

            mark = function() {

                var i = 0;

                for (i = 0; i < previousMarkers.length; i++) {
                    if (opts.onMarkerClick) {
                        previousMarkers[i].removeEventListener('click', opts.onMarkerClick(marker));
                    }
                    else {
                        previousMarkers[i].removeEventListener('click', openInfoWindow(infoWindow2));
                    }
                    map.removeOverlay(previousMarkers[i]);
                }
                previousMarkers.length = 0;

                for (i = 0; i < opts.markers.length; i++) {
                    var marker = opts.markers[i];
                    var pt = new BMap.Point(marker.longitude, marker.latitude);
                    var marker2, icon, iconHover;

                    marker2 = new BMap.Marker(pt);

                    if (marker.icon) {
                        icon = new BMap.Icon(marker.icon, new BMap.Size(34, 48/*marker.width, marker.height*/));
                        marker2.setIcon(icon);
                    }
                    if (marker.iconHover) {
                        iconHover = new BMap.Icon(marker.iconHover, new BMap.Size(34, 48/*marker.width, marker.height*/));
                    }

                    // hack to make icon selected, directive shouldn't aware of private data source
                    if(marker.source.__selected)
                        marker2.setIcon(iconHover);

                    
                    // add marker to the map
                    map.addOverlay(marker2);
                    previousMarkers.push(marker2);

                    if (marker.name) {
                        //var label = new BMap.Label(marker.name, { offset: new BMap.Size(0, -20) });
                        //label.setStyle({ background: "#f00", width: "100px", display: "block", color: "#333", cursor: "pointer" });
                        marker2.setTitle (marker.name);
                    }

                    if (!marker.title && !marker.content) {
                        return;
                    }
                    var infoWindow2 = new BMap.InfoWindow('<p>' + (marker.title ? marker.title : '') + '</p><p>' + (marker.content ? marker.content : '') + '</p>', {
                        enableMessage: !!marker.enableMessage
                    });


                    marker2['customInfo'] = marker;

                    //TODO: improve this
                    marker2.addEventListener('mouseover', function (e) {
                        

                        if(hoverTimeout)
                            window.clearTimeout(hoverTimeout);

                        hoverTimeout = setTimeout(function(){
                            var markerPos = map.pointToPixel(e.point);
                            var distance = Math.sqrt( (markerPos.x-currentMousePos.x)*(markerPos.x-currentMousePos.x) + (markerPos.y-currentMousePos.y)*(markerPos.y-currentMousePos.y) );

                            //hack
                            if(distance > 20) return;        

                            if (iconHover)
                                e.target.setIcon(iconHover);

                            if(opts.onMarkerMouseOver)
                                opts.onMarkerMouseOver(e.target.customInfo);

                            e.target.setTop(true);

                        }, 1);


                    });

                    marker2.addEventListener('mouseout', function(e) {
                        var selected = e.target.customInfo.source.__selected;
                        if (icon && !selected){
                            console.log('not selected' , e.target.customInfo.source.__selected);
                            e.target.setIcon(icon);
                            e.target.setTop(false);
                        }
                        else if(e.target.customInfo.source.__selected) {
                            console.log('selected' , e.target.customInfo.source.__selected);
                            e.target.setTop(true);
                        }
                        
                        if(opts.onMarkerMouseOut)
                            opts.onMarkerMouseOut(e);

                    });

                    if(opts.onMarkerTap)
                    {
                        marker2.addEventListener('click', function(e) {
                            e.target.setTop(true);
                            return opts.onMarkerTap(e.target.customInfo);
                        });
                    }
                    // else
                    // {
                    //     marker2.addEventListener('click', openInfoWindow(infoWindow2));
                    // }

                    //keep this just in case if we choose to use direct navigation on click 
                    //if (opts.onMarkerClick) {
                    //    marker2.addEventListener('click', function (e) {
                    //        return opts.onMarkerClick(this.customInfo)
                    //    });
                    //} else {
                    //    marker2.addEventListener('click', openInfoWindow(infoWindow2));
                    //}
                }
            };




        }
    };
};

var baiduMap = angular.module('baiduMap', []);
baiduMap.directive('baiduMap', ['baiduMapApi', '$timeout', baiduMapDir]);
baiduMap.factory('baiduMapApi', ['$window', '$q', function lazyLoadApi($window, $q) {
    var deferred = $q.defer(),
        load;
    $window.initMap = function () {
        deferred.resolve();
    }
    load = function () {

        if (deferred.promise.$$state.status == 1) {
            deferred.resolve();
        } else {
            var script = document.createElement('script')
            script.src = 'http://api.map.baidu.com/api?v=2.0&ak=KRNQDv3desnEOULRaeOsmyvI&callback=initMap'
            document.body.appendChild(script)
        }
        return deferred.promise;

    }

    

    return {
        load: load
    }
}]);
},{}],55:[function(require,module,exports){
/** @preserve
 * jsPDF - PDF Document creation from JavaScript
 * Version ${versionID}
 *                           CommitID ${commitID}
 *
 * Copyright (c) 2010-2014 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, willow-systems.com
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */

/**
 * Creates new jsPDF document object instance.
 *
 * @class
 * @param orientation One of "portrait" or "landscape" (or shortcuts "p" (Default), "l")
 * @param unit        Measurement unit to be used when coordinates are specified.
 *                    One of "pt" (points), "mm" (Default), "cm", "in"
 * @param format      One of 'pageFormats' as shown below, default: a4
 * @returns {jsPDF}
 * @name jsPDF
 */
var jsPDF = (function(global) {
	'use strict';
	var pdfVersion = '1.3',
		pageFormats = { // Size in pt of various paper formats
			'a0'  : [2383.94, 3370.39], 'a1'  : [1683.78, 2383.94],
			'a2'  : [1190.55, 1683.78], 'a3'  : [ 841.89, 1190.55],
			'a4'  : [ 595.28,  841.89], 'a5'  : [ 419.53,  595.28],
			'a6'  : [ 297.64,  419.53], 'a7'  : [ 209.76,  297.64],
			'a8'  : [ 147.40,  209.76], 'a9'  : [ 104.88,  147.40],
			'a10' : [  73.70,  104.88], 'b0'  : [2834.65, 4008.19],
			'b1'  : [2004.09, 2834.65], 'b2'  : [1417.32, 2004.09],
			'b3'  : [1000.63, 1417.32], 'b4'  : [ 708.66, 1000.63],
			'b5'  : [ 498.90,  708.66], 'b6'  : [ 354.33,  498.90],
			'b7'  : [ 249.45,  354.33], 'b8'  : [ 175.75,  249.45],
			'b9'  : [ 124.72,  175.75], 'b10' : [  87.87,  124.72],
			'c0'  : [2599.37, 3676.54], 'c1'  : [1836.85, 2599.37],
			'c2'  : [1298.27, 1836.85], 'c3'  : [ 918.43, 1298.27],
			'c4'  : [ 649.13,  918.43], 'c5'  : [ 459.21,  649.13],
			'c6'  : [ 323.15,  459.21], 'c7'  : [ 229.61,  323.15],
			'c8'  : [ 161.57,  229.61], 'c9'  : [ 113.39,  161.57],
			'c10' : [  79.37,  113.39], 'dl'  : [ 311.81,  623.62],
			'letter'            : [612,   792],
			'government-letter' : [576,   756],
			'legal'             : [612,  1008],
			'junior-legal'      : [576,   360],
			'ledger'            : [1224,  792],
			'tabloid'           : [792,  1224],
			'credit-card'       : [153,   243]
		};

	/**
	 * jsPDF's Internal PubSub Implementation.
	 * See mrrio.github.io/jsPDF/doc/symbols/PubSub.html
	 * Backward compatible rewritten on 2014 by
	 * Diego Casorran, https://github.com/diegocr
	 *
	 * @class
	 * @name PubSub
	 */
	function PubSub(context) {
		var topics = {};

		this.subscribe = function(topic, callback, once) {
			if(typeof callback !== 'function') {
				return false;
			}

			if(!topics.hasOwnProperty(topic)) {
				topics[topic] = {};
			}

			var id = Math.random().toString(35);
			topics[topic][id] = [callback,!!once];

			return id;
		};

		this.unsubscribe = function(token) {
			for(var topic in topics) {
				if(topics[topic][token]) {
					delete topics[topic][token];
					return true;
				}
			}
			return false;
		};

		this.publish = function(topic) {
			if(topics.hasOwnProperty(topic)) {
				var args = Array.prototype.slice.call(arguments, 1), idr = [];

				for(var id in topics[topic]) {
					var sub = topics[topic][id];
					try {
						sub[0].apply(context, args);
					} catch(ex) {
						if(global.console) {
							console.error('jsPDF PubSub Error', ex.message, ex);
						}
					}
					if(sub[1]) idr.push(id);
				}
				if(idr.length) idr.forEach(this.unsubscribe);
			}
		};
	}

	/**
	 * @constructor
	 * @private
	 */
	function jsPDF(orientation, unit, format, compressPdf) {
		var options = {};

		if (typeof orientation === 'object') {
			options = orientation;

			orientation = options.orientation;
			unit = options.unit || unit;
			format = options.format || format;
			compressPdf = options.compress || options.compressPdf || compressPdf;
		}

		// Default options
		unit        = unit || 'mm';
		format      = format || 'a4';
		orientation = ('' + (orientation || 'P')).toLowerCase();

		var format_as_string = ('' + format).toLowerCase(),
			compress = !!compressPdf && typeof Uint8Array === 'function',
			textColor            = options.textColor  || '0 g',
			drawColor            = options.drawColor  || '0 G',
			activeFontSize       = options.fontSize   || 16,
			lineHeightProportion = options.lineHeight || 1.15,
			lineWidth            = options.lineWidth  || 0.200025, // 2mm
			objectNumber =  2,  // 'n' Current object number
			outToPages   = !1,  // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
			offsets      = [],  // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
			fonts        = {},  // collection of font objects, where key is fontKey - a dynamically created label for a given font.
			fontmap      = {},  // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
			activeFontKey,      // will be string representing the KEY of the font as combination of fontName + fontStyle
			k,                  // Scale factor
			tmp,
			page = 0,
			currentPage,
			pages = [],
			pagesContext = [], // same index as pages and pagedim
			pagedim = [],
			content = [],
			additionalObjects = [],
			lineCapID = 0,
			lineJoinID = 0,
			content_length = 0,
			pageWidth,
			pageHeight,
			pageMode,
			zoomMode,
			layoutMode,
			documentProperties = {
				'title'    : '',
				'subject'  : '',
				'author'   : '',
				'keywords' : '',
				'creator'  : ''
			},
			API = {},
			events = new PubSub(API),

		/////////////////////
		// Private functions
		/////////////////////
		f2 = function(number) {
			return number.toFixed(2); // Ie, %.2f
		},
		f3 = function(number) {
			return number.toFixed(3); // Ie, %.3f
		},
		padd2 = function(number) {
			return ('0' + parseInt(number)).slice(-2);
		},
		out = function(string) {
			if (outToPages) {
				/* set by beginPage */
				pages[currentPage].push(string);
			} else {
				// +1 for '\n' that will be used to join 'content'
				content_length += string.length + 1;
				content.push(string);
			}
		},
		newObject = function() {
			// Begin a new object
			objectNumber++;
			offsets[objectNumber] = content_length;
			out(objectNumber + ' 0 obj');
			return objectNumber;
		},
		// Does not output the object until after the pages have been output.
		// Returns an object containing the objectId and content.
		// All pages have been added so the object ID can be estimated to start right after.
		// This does not modify the current objectNumber;  It must be updated after the newObjects are output.
		newAdditionalObject = function() {
			var objId = pages.length * 2 + 1;
			objId += additionalObjects.length;
			var obj = {objId:objId, content:''};
			additionalObjects.push(obj);
			return obj;
		},
		// Does not output the object.  The caller must call newObjectDeferredBegin(oid) before outputing any data
		newObjectDeferred = function() {
			objectNumber++;
			offsets[objectNumber] = function(){
				return content_length;
			};
			return objectNumber;
		},
		newObjectDeferredBegin = function(oid) {
			offsets[oid] = content_length;
		},
		putStream = function(str) {
			out('stream');
			out(str);
			out('endstream');
		},
		putPages = function() {
			var n,p,arr,i,deflater,adler32,adler32cs,wPt,hPt;

			adler32cs = global.adler32cs || jsPDF.adler32cs;
			if (compress && typeof adler32cs === 'undefined') {
				compress = false;
			}

			// outToPages = false as set in endDocument(). out() writes to content.

			for (n = 1; n <= page; n++) {
				newObject();
				wPt = (pageWidth = pagedim[n].width) * k;
				hPt = (pageHeight = pagedim[n].height) * k;
				out('<</Type /Page');
				out('/Parent 1 0 R');
				out('/Resources 2 0 R');
				out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
				out('/Contents ' + (objectNumber + 1) + ' 0 R');
				// Added for annotation plugin
				events.publish('putPage', {pageNumber:n,page:pages[n]});
				out('>>');
				out('endobj');

				// Page content
				p = pages[n].join('\n');
				newObject();
				if (compress) {
					arr = [];
					i = p.length;
					while(i--) {
						arr[i] = p.charCodeAt(i);
					}
					adler32 = adler32cs.from(p);
					deflater = new Deflater(6);
					deflater.append(new Uint8Array(arr));
					p = deflater.flush();
					arr = new Uint8Array(p.length + 6);
					arr.set(new Uint8Array([120, 156])),
					arr.set(p, 2);
					arr.set(new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF]), p.length+2);
					p = String.fromCharCode.apply(null, arr);
					out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');
				} else {
					out('<</Length ' + p.length + '>>');
				}
				putStream(p);
				out('endobj');
			}
			offsets[1] = content_length;
			out('1 0 obj');
			out('<</Type /Pages');
			var kids = '/Kids [';
			for (i = 0; i < page; i++) {
				kids += (3 + 2 * i) + ' 0 R ';
			}
			out(kids + ']');
			out('/Count ' + page);
			out('>>');
			out('endobj');
		},
		putFont = function(font) {
			font.objectNumber = newObject();
			out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
			if (typeof font.encoding === 'string') {
				out('/Encoding/' + font.encoding);
			}
			out('/Subtype/Type1>>');
			out('endobj');
		},
		putFonts = function() {
			for (var fontKey in fonts) {
				if (fonts.hasOwnProperty(fontKey)) {
					putFont(fonts[fontKey]);
				}
			}
		},
		putXobjectDict = function() {
			// Loop through images, or other data objects
			events.publish('putXobjectDict');
		},
		putResourceDictionary = function() {
			out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
			out('/Font <<');

			// Do this for each font, the '1' bit is the index of the font
			for (var fontKey in fonts) {
				if (fonts.hasOwnProperty(fontKey)) {
					out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
				}
			}
			out('>>');
			out('/XObject <<');
			putXobjectDict();
			out('>>');
		},
		putResources = function() {
			putFonts();
			events.publish('putResources');
			// Resource dictionary
			offsets[2] = content_length;
			out('2 0 obj');
			out('<<');
			putResourceDictionary();
			out('>>');
			out('endobj');
			events.publish('postPutResources');
		},
		putAdditionalObjects = function() {
			events.publish('putAdditionalObjects');
			for (var i=0; i<additionalObjects.length; i++){
				var obj = additionalObjects[i];
				offsets[obj.objId] = content_length;
				out( obj.objId + ' 0 obj');
				out(obj.content);;
				out('endobj');
			}
			objectNumber += additionalObjects.length;
			events.publish('postPutAdditionalObjects');
		},
		addToFontDictionary = function(fontKey, fontName, fontStyle) {
			// this is mapping structure for quick font key lookup.
			// returns the KEY of the font (ex: "F1") for a given
			// pair of font name and type (ex: "Arial". "Italic")
			if (!fontmap.hasOwnProperty(fontName)) {
				fontmap[fontName] = {};
			}
			fontmap[fontName][fontStyle] = fontKey;
		},
		/**
		 * FontObject describes a particular font as member of an instnace of jsPDF
		 *
		 * It's a collection of properties like 'id' (to be used in PDF stream),
		 * 'fontName' (font's family name), 'fontStyle' (font's style variant label)
		 *
		 * @class
		 * @public
		 * @property id {String} PDF-document-instance-specific label assinged to the font.
		 * @property PostScriptName {String} PDF specification full name for the font
		 * @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
		 * @name FontObject
		 */
		addFont = function(PostScriptName, fontName, fontStyle, encoding) {
			var fontKey = 'F' + (Object.keys(fonts).length + 1).toString(10),
			// This is FontObject
			font = fonts[fontKey] = {
				'id'             : fontKey,
				'PostScriptName' : PostScriptName,
				'fontName'       : fontName,
				'fontStyle'      : fontStyle,
				'encoding'       : encoding,
				'metadata'       : {}
			};
			addToFontDictionary(fontKey, fontName, fontStyle);
			events.publish('addFont', font);

			return fontKey;
		},
		addFonts = function() {

			var HELVETICA     = "helvetica",
				TIMES         = "times",
				COURIER       = "courier",
				NORMAL        = "normal",
				BOLD          = "bold",
				ITALIC        = "italic",
				BOLD_ITALIC   = "bolditalic",
				encoding      = 'StandardEncoding',
				standardFonts = [
					['Helvetica', HELVETICA, NORMAL],
					['Helvetica-Bold', HELVETICA, BOLD],
					['Helvetica-Oblique', HELVETICA, ITALIC],
					['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
					['Courier', COURIER, NORMAL],
					['Courier-Bold', COURIER, BOLD],
					['Courier-Oblique', COURIER, ITALIC],
					['Courier-BoldOblique', COURIER, BOLD_ITALIC],
					['Times-Roman', TIMES, NORMAL],
					['Times-Bold', TIMES, BOLD],
					['Times-Italic', TIMES, ITALIC],
					['Times-BoldItalic', TIMES, BOLD_ITALIC]
				];

			for (var i = 0, l = standardFonts.length; i < l; i++) {
				var fontKey = addFont(
						standardFonts[i][0],
						standardFonts[i][1],
						standardFonts[i][2],
						encoding);

				// adding aliases for standard fonts, this time matching the capitalization
				var parts = standardFonts[i][0].split('-');
				addToFontDictionary(fontKey, parts[0], parts[1] || '');
			}
			events.publish('addFonts', { fonts : fonts, dictionary : fontmap });
		},
		SAFE = function __safeCall(fn) {
			fn.foo = function __safeCallWrapper() {
				try {
					return fn.apply(this, arguments);
				} catch (e) {
					var stack = e.stack || '';
					if(~stack.indexOf(' at ')) stack = stack.split(" at ")[1];
					var m = "Error in function " + stack.split("\n")[0].split('<')[0] + ": " + e.message;
					if(global.console) {
						global.console.error(m, e);
						if(global.alert) alert(m);
					} else {
						throw new Error(m);
					}
				}
			};
			fn.foo.bar = fn;
			return fn.foo;
		},
		to8bitStream = function(text, flags) {
		/**
		 * PDF 1.3 spec:
		 * "For text strings encoded in Unicode, the first two bytes must be 254 followed by
		 * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts
		 * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely
		 * to be a meaningful beginning of a word or phrase.) The remainder of the
		 * string consists of Unicode character codes, according to the UTF-16 encoding
		 * specified in the Unicode standard, version 2.0. Commonly used Unicode values
		 * are represented as 2 bytes per character, with the high-order byte appearing first
		 * in the string."
		 *
		 * In other words, if there are chars in a string with char code above 255, we
		 * recode the string to UCS2 BE - string doubles in length and BOM is prepended.
		 *
		 * HOWEVER!
		 * Actual *content* (body) text (as opposed to strings used in document properties etc)
		 * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)
		 *
		 * Because of Adobe's focus on "you subset your fonts!" you are not supposed to have
		 * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could
		 * fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode
		 * code page. There, however, all characters in the stream are treated as GIDs,
		 * including BOM, which is the reason we need to skip BOM in content text (i.e. that
		 * that is tied to a font).
		 *
		 * To signal this "special" PDFEscape / to8bitStream handling mode,
		 * API.text() function sets (unless you overwrite it with manual values
		 * given to API.text(.., flags) )
		 * flags.autoencode = true
		 * flags.noBOM = true
		 *
		 * ===================================================================================
		 * `flags` properties relied upon:
		 *   .sourceEncoding = string with encoding label.
		 *                     "Unicode" by default. = encoding of the incoming text.
		 *                     pass some non-existing encoding name
		 *                     (ex: 'Do not touch my strings! I know what I am doing.')
		 *                     to make encoding code skip the encoding step.
		 *   .outputEncoding = Either valid PDF encoding name
		 *                     (must be supported by jsPDF font metrics, otherwise no encoding)
		 *                     or a JS object, where key = sourceCharCode, value = outputCharCode
		 *                     missing keys will be treated as: sourceCharCode === outputCharCode
		 *   .noBOM
		 *       See comment higher above for explanation for why this is important
		 *   .autoencode
		 *       See comment higher above for explanation for why this is important
		 */

			var i,l,sourceEncoding,encodingBlock,outputEncoding,newtext,isUnicode,ch,bch;

			flags = flags || {};
			sourceEncoding = flags.sourceEncoding || 'Unicode';
			outputEncoding = flags.outputEncoding;

			// This 'encoding' section relies on font metrics format
			// attached to font objects by, among others,
			// "Willow Systems' standard_font_metrics plugin"
			// see jspdf.plugin.standard_font_metrics.js for format
			// of the font.metadata.encoding Object.
			// It should be something like
			//   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
			//   .widths = {0:width, code:width, ..., 'fof':divisor}
			//   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
			if ((flags.autoencode || outputEncoding) &&
				fonts[activeFontKey].metadata &&
				fonts[activeFontKey].metadata[sourceEncoding] &&
				fonts[activeFontKey].metadata[sourceEncoding].encoding) {
				encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

				// each font has default encoding. Some have it clearly defined.
				if (!outputEncoding && fonts[activeFontKey].encoding) {
					outputEncoding = fonts[activeFontKey].encoding;
				}

				// Hmmm, the above did not work? Let's try again, in different place.
				if (!outputEncoding && encodingBlock.codePages) {
					outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default
				}

				if (typeof outputEncoding === 'string') {
					outputEncoding = encodingBlock[outputEncoding];
				}
				// we want output encoding to be a JS Object, where
				// key = sourceEncoding's character code and
				// value = outputEncoding's character code.
				if (outputEncoding) {
					isUnicode = false;
					newtext = [];
					for (i = 0, l = text.length; i < l; i++) {
						ch = outputEncoding[text.charCodeAt(i)];
						if (ch) {
							newtext.push(
								String.fromCharCode(ch));
						} else {
							newtext.push(
								text[i]);
						}

						// since we are looping over chars anyway, might as well
						// check for residual unicodeness
						if (newtext[i].charCodeAt(0) >> 8) {
							/* more than 255 */
							isUnicode = true;
						}
					}
					text = newtext.join('');
				}
			}

			i = text.length;
			// isUnicode may be set to false above. Hence the triple-equal to undefined
			while (isUnicode === undefined && i !== 0) {
				if (text.charCodeAt(i - 1) >> 8) {
					/* more than 255 */
					isUnicode = true;
				}
				i--;
			}
			if (!isUnicode) {
				return text;
			}

			newtext = flags.noBOM ? [] : [254, 255];
			for (i = 0, l = text.length; i < l; i++) {
				ch = text.charCodeAt(i);
				bch = ch >> 8; // divide by 256
				if (bch >> 8) {
					/* something left after dividing by 256 second time */
					throw new Error("Character at position " + i + " of string '"
						+ text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
				}
				newtext.push(bch);
				newtext.push(ch - (bch << 8));
			}
			return String.fromCharCode.apply(undefined, newtext);
		},
		pdfEscape = function(text, flags) {
			/**
			 * Replace '/', '(', and ')' with pdf-safe versions
			 *
			 * Doing to8bitStream does NOT make this PDF display unicode text. For that
			 * we also need to reference a unicode font and embed it - royal pain in the rear.
			 *
			 * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
			 * which JavaScript Strings are happy to provide. So, while we still cannot display
			 * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
			 * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
			 * is still parseable.
			 * This will allow immediate support for unicode in document properties strings.
			 */
			return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
		},
		putInfo = function() {
			out('/Producer (jsPDF ' + jsPDF.version + ')');
			for(var key in documentProperties) {
				if(documentProperties.hasOwnProperty(key) && documentProperties[key]) {
					out('/'+key.substr(0,1).toUpperCase() + key.substr(1)
						+' (' + pdfEscape(documentProperties[key]) + ')');
				}
			}
			var created  = new Date(),
				tzoffset = created.getTimezoneOffset(),
				tzsign   = tzoffset < 0 ? '+' : '-',
				tzhour   = Math.floor(Math.abs(tzoffset / 60)),
				tzmin    = Math.abs(tzoffset % 60),
				tzstr    = [tzsign, padd2(tzhour), "'", padd2(tzmin), "'"].join('');
			out(['/CreationDate (D:',
					created.getFullYear(),
					padd2(created.getMonth() + 1),
					padd2(created.getDate()),
					padd2(created.getHours()),
					padd2(created.getMinutes()),
					padd2(created.getSeconds()), tzstr, ')'].join(''));
		},
		putCatalog = function() {
			out('/Type /Catalog');
			out('/Pages 1 0 R');
			// PDF13ref Section 7.2.1
			if (!zoomMode) zoomMode = 'fullwidth';
			switch(zoomMode) {
				case 'fullwidth'  : out('/OpenAction [3 0 R /FitH null]');       break;
				case 'fullheight' : out('/OpenAction [3 0 R /FitV null]');       break;
				case 'fullpage'   : out('/OpenAction [3 0 R /Fit]');             break;
				case 'original'   : out('/OpenAction [3 0 R /XYZ null null 1]'); break;
				default:
					var pcn = '' + zoomMode;
					if (pcn.substr(pcn.length-1) === '%')
						zoomMode = parseInt(zoomMode) / 100;
					if (typeof zoomMode === 'number') {
						out('/OpenAction [3 0 R /XYZ null null '+f2(zoomMode)+']');
					}
			}
			if (!layoutMode) layoutMode = 'continuous';
			switch(layoutMode) {
				case 'continuous' : out('/PageLayout /OneColumn');      break;
				case 'single'     : out('/PageLayout /SinglePage');     break;
				case 'two':
				case 'twoleft'    : out('/PageLayout /TwoColumnLeft');  break;
				case 'tworight'   : out('/PageLayout /TwoColumnRight'); break;
			}
			if (pageMode) {
				/**
				 * A name object specifying how the document should be displayed when opened:
				 * UseNone      : Neither document outline nor thumbnail images visible -- DEFAULT
				 * UseOutlines  : Document outline visible
				 * UseThumbs    : Thumbnail images visible
				 * FullScreen   : Full-screen mode, with no menu bar, window controls, or any other window visible
				 */
				out('/PageMode /' + pageMode);
			}
			events.publish('putCatalog');
		},
		putTrailer = function() {
			out('/Size ' + (objectNumber + 1));
			out('/Root ' + objectNumber + ' 0 R');
			out('/Info ' + (objectNumber - 1) + ' 0 R');
		},
		beginPage = function(width,height) {
			// Dimensions are stored as user units and converted to points on output
			var orientation = typeof height === 'string' && height.toLowerCase();
			if (typeof width === 'string') {
				var format = width.toLowerCase();
				if (pageFormats.hasOwnProperty(format)) {
					width  = pageFormats[format][0] / k;
					height = pageFormats[format][1] / k;
				}
			}
			if (Array.isArray(width)) {
				height = width[1];
				width = width[0];
			}
			if (orientation) {
				switch(orientation.substr(0,1)) {
					case 'l': if (height > width ) orientation = 's'; break;
					case 'p': if (width > height ) orientation = 's'; break;
				}
				if (orientation === 's') { tmp = width; width = height; height = tmp; }
			}
			outToPages = true;
			pages[++page] = [];
			pagedim[page] = {
				width  : Number(width)  || pageWidth,
				height : Number(height) || pageHeight
			};
			pagesContext[page] = {};
			_setPage(page);
		},
		_addPage = function() {
			beginPage.apply(this, arguments);
			// Set line width
			out(f2(lineWidth * k) + ' w');
			// Set draw color
			out(drawColor);
			// resurrecting non-default line caps, joins
			if (lineCapID !== 0) {
				out(lineCapID + ' J');
			}
			if (lineJoinID !== 0) {
				out(lineJoinID + ' j');
			}
			events.publish('addPage', { pageNumber : page });
		},
		_deletePage = function( n ) {
			if (n > 0 && n <= page) {
				pages.splice(n, 1);
				pagedim.splice(n, 1);
				page--;
				if (currentPage > page){
					currentPage = page;
				}
				this.setPage(currentPage);
			}
		},
		_setPage = function(n) {
			if (n > 0 && n <= page) {
				currentPage = n;
				pageWidth = pagedim[n].width;
				pageHeight = pagedim[n].height;
			}
		},
		/**
		 * Returns a document-specific font key - a label assigned to a
		 * font name + font type combination at the time the font was added
		 * to the font inventory.
		 *
		 * Font key is used as label for the desired font for a block of text
		 * to be added to the PDF document stream.
		 * @private
		 * @function
		 * @param fontName {String} can be undefined on "falthy" to indicate "use current"
		 * @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
		 * @returns {String} Font key.
		 */
		getFont = function(fontName, fontStyle) {
			var key;

			fontName  = fontName  !== undefined ? fontName  : fonts[activeFontKey].fontName;
			fontStyle = fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;

			if (fontName !== undefined){
				fontName = fontName.toLowerCase();
			}
			switch(fontName){
			case 'sans-serif':
			case 'verdana':
			case 'arial':
			case 'helvetica':
				fontName = 'helvetica';
				break;
			case 'fixed':
			case 'monospace':
			case 'terminal':
			case 'courier':
				fontName = 'courier';
				break;
			case 'serif':
			case 'cursive':
			case 'fantasy':
				default:
				fontName = 'times';
				break;
			}

			try {
			 // get a string like 'F3' - the KEY corresponding tot he font + type combination.
				key = fontmap[fontName][fontStyle];
			} catch (e) {}

			if (!key) {
				//throw new Error("Unable to look up font label for font '" + fontName + "', '"
					//+ fontStyle + "'. Refer to getFontList() for available fonts.");
				key = fontmap['times'][fontStyle];
				if (key == null){
					key = fontmap['times']['normal'];
				}
			}
			return key;
		},
		buildDocument = function() {

			outToPages = false; // switches out() to content
			objectNumber = 2;
			content = [];
			offsets = [];
			additionalObjects = [];

			// putHeader()
			out('%PDF-' + pdfVersion);

			putPages();

			// Must happen after putPages
			// Modifies current object Id
			putAdditionalObjects();

			putResources();

			// Info
			newObject();
			out('<<');
			putInfo();
			out('>>');
			out('endobj');

			// Catalog
			newObject();
			out('<<');
			putCatalog();
			out('>>');
			out('endobj');

			// Cross-ref
			var o = content_length, i, p = "0000000000";
			out('xref');
			out('0 ' + (objectNumber + 1));
			out(p+' 65535 f ');
			for (i = 1; i <= objectNumber; i++) {
				var offset = offsets[i];
				if (typeof offset === 'function'){
					out((p + offsets[i]()).slice(-10) + ' 00000 n ');
				}else{
					out((p + offsets[i]).slice(-10) + ' 00000 n ');
				}
			}
			// Trailer
			out('trailer');
			out('<<');
			putTrailer();
			out('>>');
			out('startxref');
			out(o);
			out('%%EOF');

			outToPages = true;

			return content.join('\n');
		},
		getStyle = function(style) {
			// see path-painting operators in PDF spec
			var op = 'S'; // stroke
			if (style === 'F') {
				op = 'f'; // fill
			} else if (style === 'FD' || style === 'DF') {
				op = 'B'; // both
			} else if (style === 'f' || style === 'f*' || style === 'B' || style === 'B*') {
				/*
				Allow direct use of these PDF path-painting operators:
				- f	fill using nonzero winding number rule
				- f*	fill using even-odd rule
				- B	fill then stroke with fill using non-zero winding number rule
				- B*	fill then stroke with fill using even-odd rule
				*/
				op = style;
			}
			return op;
		},
		getArrayBuffer = function() {
			var data = buildDocument(), len = data.length,
				ab = new ArrayBuffer(len), u8 = new Uint8Array(ab);

			while(len--) u8[len] = data.charCodeAt(len);
			return ab;
		},
		getBlob = function() {
			return new Blob([getArrayBuffer()], { type : "application/pdf" });
		},
		/**
		 * Generates the PDF document.
		 *
		 * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.
		 *
		 * @param {String} type A string identifying one of the possible output types.
		 * @param {Object} options An object providing some additional signalling to PDF generator.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name output
		 */
		output = SAFE(function(type, options) {
			var datauri = ('' + type).substr(0,6) === 'dataur'
				? 'data:application/pdf;base64,'+btoa(buildDocument()):0;

			switch (type) {
				case undefined:
					return buildDocument();
				case 'save':
					if (navigator.getUserMedia) {
						if (global.URL === undefined
						|| global.URL.createObjectURL === undefined) {
							return API.output('dataurlnewwindow');
						}
					}
					saveAs(getBlob(), options);
					if(typeof saveAs.unload === 'function') {
						if(global.setTimeout) {
							setTimeout(saveAs.unload,911);
						}
					}
					break;
				case 'arraybuffer':
					return getArrayBuffer();
				case 'blob':
					return getBlob();
				case 'bloburi':
				case 'bloburl':
					// User is responsible of calling revokeObjectURL
					return global.URL && global.URL.createObjectURL(getBlob()) || void 0;
				case 'datauristring':
				case 'dataurlstring':
					return datauri;
				case 'dataurlnewwindow':
					var nW = global.open(datauri);
					if (nW || typeof safari === "undefined") return nW;
					/* pass through */
				case 'datauri':
				case 'dataurl':
					return global.document.location.href = datauri;
				default:
					throw new Error('Output type "' + type + '" is not supported.');
			}
			// @TODO: Add different output options
		});

		switch (unit) {
			case 'pt':  k = 1;                break;
			case 'mm':  k = 72 / 25.4000508;  break;
			case 'cm':  k = 72 / 2.54000508;  break;
			case 'in':  k = 72;               break;
			case 'px':  k = 96 / 72;          break;
			case 'pc':  k = 12;               break;
			case 'em':  k = 12;               break;
			case 'ex':  k = 6;                break;
			default:
				throw ('Invalid unit: ' + unit);
		}

		//---------------------------------------
		// Public API

		/**
		 * Object exposing internal API to plugins
		 * @public
		 */
		API.internal = {
			'pdfEscape' : pdfEscape,
			'getStyle' : getStyle,
			/**
			 * Returns {FontObject} describing a particular font.
			 * @public
			 * @function
			 * @param fontName {String} (Optional) Font's family name
			 * @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
			 * @returns {FontObject}
			 */
			'getFont' : function() {
				return fonts[getFont.apply(API, arguments)];
			},
			'getFontSize' : function() {
				return activeFontSize;
			},
			'getLineHeight' : function() {
				return activeFontSize * lineHeightProportion;
			},
			'write' : function(string1 /*, string2, string3, etc */) {
				out(arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' '));
			},
			'getCoordinateString' : function(value) {
				return f2(value * k);
			},
			'getVerticalCoordinateString' : function(value) {
				return f2((pageHeight - value) * k);
			},
			'collections' : {},
			'newObject' : newObject,
			'newAdditionalObject' : newAdditionalObject,
			'newObjectDeferred' : newObjectDeferred,
			'newObjectDeferredBegin' : newObjectDeferredBegin,
			'putStream' : putStream,
			'events' : events,
			// ratio that you use in multiplication of a given "size" number to arrive to 'point'
			// units of measurement.
			// scaleFactor is set at initialization of the document and calculated against the stated
			// default measurement units for the document.
			// If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
			// through multiplication.
			'scaleFactor' : k,
			'pageSize' : {
				get width() {
					return pageWidth
				},
				get height() {
					return pageHeight
				}
			},
			'output' : function(type, options) {
				return output(type, options);
			},
			'getNumberOfPages' : function() {
				return pages.length - 1;
			},
			'pages' : pages,
			'out' : out,
			'f2' : f2,
			'getPageInfo' : function(pageNumberOneBased){
				var objId = (pageNumberOneBased - 1) * 2 + 3;
				return {objId:objId, pageNumber:pageNumberOneBased, pageContext:pagesContext[pageNumberOneBased]};
			},
			'getCurrentPageInfo' : function(){
				var objId = (currentPage - 1) * 2 + 3;
				return {objId:objId, pageNumber:currentPage, pageContext:pagesContext[currentPage]};
			}
		};

		/**
		 * Adds (and transfers the focus to) new page to the PDF document.
		 * @function
		 * @returns {jsPDF}
		 *
		 * @methodOf jsPDF#
		 * @name addPage
		 */
		API.addPage = function() {
			_addPage.apply(this, arguments);
			return this;
		};
		API.setPage = function() {
			_setPage.apply(this, arguments);
			return this;
		};
		API.insertPage = function(beforePage) {
			this.addPage();
			this.movePage(currentPage, beforePage);
			return this;
		};
		API.movePage = function(targetPage, beforePage) {
			if (targetPage > beforePage){
				var tmpPages = pages[targetPage];
				var tmpPagedim = pagedim[targetPage];
				var tmpPagesContext = pagesContext[targetPage];
				for (var i=targetPage; i>beforePage; i--){
					pages[i] = pages[i-1];
					pagedim[i] = pagedim[i-1];
					pagesContext[i] = pagesContext[i-1];
				}
				pages[beforePage] = tmpPages;
				pagedim[beforePage] = tmpPagedim;
				pagesContext[beforePage] = tmpPagesContext;
				this.setPage(beforePage);
			}else if (targetPage < beforePage){
				var tmpPages = pages[targetPage];
				var tmpPagedim = pagedim[targetPage];
				var tmpPagesContext = pagesContext[targetPage];
				for (var i=targetPage; i<beforePage; i++){
					pages[i] = pages[i+1];
					pagedim[i] = pagedim[i+1];
					pagesContext[i] = pagesContext[i+1];
				}
				pages[beforePage] = tmpPages;
				pagedim[beforePage] = tmpPagedim;
				pagesContext[beforePage] = tmpPagesContext;
				this.setPage(beforePage);
			}
			return this;
		};

		API.deletePage = function() {
			_deletePage.apply( this, arguments );
			return this;
		};
		API.setDisplayMode = function(zoom, layout, pmode) {
			zoomMode   = zoom;
			layoutMode = layout;
			pageMode   = pmode;
			return this;
		},

		/**
		 * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
		 *
		 * @function
		 * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name text
		 */
		API.text = function(text, x, y, flags, angle, align) {
			/**
			 * Inserts something like this into PDF
			 *   BT
			 *    /F1 16 Tf  % Font name + size
			 *    16 TL % How many units down for next line in multiline text
			 *    0 g % color
			 *    28.35 813.54 Td % position
			 *    (line one) Tj
			 *    T* (line two) Tj
			 *    T* (line three) Tj
			 *   ET
			 */
			function ESC(s) {
				s = s.split("\t").join(Array(options.TabLen||9).join(" "));
				return pdfEscape(s, flags);
			}

			// Pre-August-2012 the order of arguments was function(x, y, text, flags)
			// in effort to make all calls have similar signature like
			//   function(data, coordinates... , miscellaneous)
			// this method had its args flipped.
			// code below allows backward compatibility with old arg order.
			if (typeof text === 'number') {
				tmp = y;
				y = x;
				x = text;
				text = tmp;
			}

			// If there are any newlines in text, we assume
			// the user wanted to print multiple lines, so break the
			// text up into an array.  If the text is already an array,
			// we assume the user knows what they are doing.
			// Convert text into an array anyway to simplify
			// later code.
			if (typeof text === 'string') {
				if(text.match(/[\n\r]/)) {
					text = text.split( /\r\n|\r|\n/g);
				} else {
					text = [text];
				}
			}
			if (typeof angle === 'string') {
				align = angle;
				angle = null;
			}
			if (typeof flags === 'string') {
				align = flags;
				flags = null;
			}
			if (typeof flags === 'number') {
				angle = flags;
				flags = null;
			}
			var xtra = '',mode = 'Td', todo;
			if (angle) {
				angle *= (Math.PI / 180);
				var c = Math.cos(angle),
				s = Math.sin(angle);
				xtra = [f2(c), f2(s), f2(s * -1), f2(c), ''].join(" ");
				mode = 'Tm';
			}
			flags = flags || {};
			if (!('noBOM' in flags))
				flags.noBOM = true;
			if (!('autoencode' in flags))
				flags.autoencode = true;

			var strokeOption = '';
			var pageContext = this.internal.getCurrentPageInfo().pageContext;
			if (true === flags.stroke){
				if (pageContext.lastTextWasStroke !== true){
					strokeOption = '1 Tr\n';
					pageContext.lastTextWasStroke = true;
				}
			}
			else{
				if (pageContext.lastTextWasStroke){
					strokeOption = '0 Tr\n';
				}
				pageContext.lastTextWasStroke = false;
			}

			if (typeof this._runningPageHeight === 'undefined'){
				this._runningPageHeight = 0;
			}

			if (typeof text === 'string') {
				text = ESC(text);
			} else if (text instanceof Array) {
				// we don't want to destroy  original text array, so cloning it
				var sa = text.concat(), da = [], len = sa.length;
				// we do array.join('text that must not be PDFescaped")
				// thus, pdfEscape each component separately
				while (len--) {
					da.push(ESC(sa.shift()));
				}
				var linesLeft = Math.ceil((pageHeight - y - this._runningPageHeight) * k / (activeFontSize * lineHeightProportion));
				if (0 <= linesLeft && linesLeft < da.length + 1) {
					//todo = da.splice(linesLeft-1);
				}

				if( align ) {
					var left,
						prevX,
						maxLineLength,
						leading =  activeFontSize * lineHeightProportion,
						lineWidths = text.map( function( v ) {
							return this.getStringUnitWidth( v ) * activeFontSize / k;
						}, this );
					maxLineLength = Math.max.apply( Math, lineWidths );
					// The first line uses the "main" Td setting,
					// and the subsequent lines are offset by the
					// previous line's x coordinate.
					if( align === "center" ) {
						// The passed in x coordinate defines
						// the center point.
						left = x - maxLineLength / 2;
						x -= lineWidths[0] / 2;
					} else if ( align === "right" ) {
						// The passed in x coordinate defines the
						// rightmost point of the text.
						left = x - maxLineLength;
						x -= lineWidths[0];
					} else {
						throw new Error('Unrecognized alignment option, use "center" or "right".');
					}
					prevX = x;
					text = da[0] + ") Tj\n";
					for ( i = 1, len = da.length ; i < len; i++ ) {
						var delta = maxLineLength - lineWidths[i];
						if( align === "center" ) delta /= 2;
						// T* = x-offset leading Td ( text )
						text += ( ( left - prevX ) + delta ) + " -" + leading + " Td (" + da[i];
						prevX = left + delta;
						if( i < len - 1 ) {
							text += ") Tj\n";
						}
					}
				} else {
					text = da.join(") Tj\nT* (");
				}
			} else {
				throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
			}
			// Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates

			// BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET
			// if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
			// Thus, there is NO useful, *reliable* concept of "default" font for a page.
			// The fact that "default" (reuse font used before) font worked before in basic cases is an accident
			// - readers dealing smartly with brokenness of jsPDF's markup.

			var curY;

			if (todo){
				//this.addPage();
				//this._runningPageHeight += y -  (activeFontSize * 1.7 / k);
				//curY = f2(pageHeight - activeFontSize * 1.7 /k);
			}else{
				curY = f2((pageHeight - y) * k);
			}
			//curY = f2((pageHeight - (y - this._runningPageHeight)) * k);

//			if (curY < 0){
//				console.log('auto page break');
//				this.addPage();
//				this._runningPageHeight = y -  (activeFontSize * 1.7 / k);
//				curY = f2(pageHeight - activeFontSize * 1.7 /k);
//			}

			out(
				'BT\n/' +
				activeFontKey + ' ' + activeFontSize + ' Tf\n' +     // font face, style, size
				(activeFontSize * lineHeightProportion) + ' TL\n' +  // line spacing
				strokeOption +// stroke option
				textColor +
				'\n' + xtra + f2(x * k) + ' ' + curY + ' ' + mode + '\n(' +
				text +
				') Tj\nET');

			if (todo) {
				//this.text( todo, x, activeFontSize * 1.7 / k);
				//this.text( todo, x, this._runningPageHeight + (activeFontSize * 1.7 / k));
				this.text( todo, x, y);// + (activeFontSize * 1.7 / k));
			}

			return this;
		};

		API.lstext = function(text, x, y, spacing) {
			for (var i = 0, len = text.length ; i < len; i++, x += spacing) this.text(text[i], x, y);
		};

		API.line = function(x1, y1, x2, y2) {
			return this.lines([[x2 - x1, y2 - y1]], x1, y1);
		};

		API.clip = function() {
			// By patrick-roberts, github.com/MrRio/jsPDF/issues/328
			// Call .clip() after calling .rect() with a style argument of null
			out('W') // clip
			out('S') // stroke path; necessary for clip to work
		};

		/**
		 * Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
		 * All data points in `lines` are relative to last line origin.
		 * `x`, `y` become x1,y1 for first line / curve in the set.
		 * For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
		 * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.
		 *
		 * @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
		 * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @param {Boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name lines
		 */
		API.lines = function(lines, x, y, scale, style, closed) {
			var scalex,scaley,i,l,leg,x2,y2,x3,y3,x4,y4;

			// Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
			// in effort to make all calls have similar signature like
			//   function(content, coordinateX, coordinateY , miscellaneous)
			// this method had its args flipped.
			// code below allows backward compatibility with old arg order.
			if (typeof lines === 'number') {
				tmp = y;
				y = x;
				x = lines;
				lines = tmp;
			}

			scale = scale || [1, 1];

			// starting point
			out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

			scalex = scale[0];
			scaley = scale[1];
			l = lines.length;
			//, x2, y2 // bezier only. In page default measurement "units", *after* scaling
			//, x3, y3 // bezier only. In page default measurement "units", *after* scaling
			// ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
			x4 = x; // last / ending point = starting point for first item.
			y4 = y; // last / ending point = starting point for first item.

			for (i = 0; i < l; i++) {
				leg = lines[i];
				if (leg.length === 2) {
					// simple line
					x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
					y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
					out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
				} else {
					// bezier curve
					x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
					y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
					x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
					y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
					x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
					y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
					out(
						f3(x2 * k) + ' ' +
						f3((pageHeight - y2) * k) + ' ' +
						f3(x3 * k) + ' ' +
						f3((pageHeight - y3) * k) + ' ' +
						f3(x4 * k) + ' ' +
						f3((pageHeight - y4) * k) + ' c');
				}
			}

			if (closed) {
				out(' h');
			}

			// stroking / filling / both the path
			if (style !== null) {
				out(getStyle(style));
			}
			return this;
		};

		/**
		 * Adds a rectangle to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} w Width (in units declared at inception of PDF document)
		 * @param {Number} h Height (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name rect
		 */
		API.rect = function(x, y, w, h, style) {
			var op = getStyle(style);
			out([
					f2(x * k),
					f2((pageHeight - y) * k),
					f2(w * k),
					f2(-h * k),
					're'
				].join(' '));

			if (style !== null) {
				out(getStyle(style));
			}

			return this;
		};

		/**
		 * Adds a triangle to PDF
		 *
		 * @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name triangle
		 */
		API.triangle = function(x1, y1, x2, y2, x3, y3, style) {
			this.lines(
				[
					[x2 - x1, y2 - y1], // vector to point 2
					[x3 - x2, y3 - y2], // vector to point 3
					[x1 - x3, y1 - y3]// closing vector back to point 1
				],
				x1,
				y1, // start of path
				[1, 1],
				style,
				true);
			return this;
		};

		/**
		 * Adds a rectangle with rounded corners to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} w Width (in units declared at inception of PDF document)
		 * @param {Number} h Height (in units declared at inception of PDF document)
		 * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
		 * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name roundedRect
		 */
		API.roundedRect = function(x, y, w, h, rx, ry, style) {
			var MyArc = 4 / 3 * (Math.SQRT2 - 1);
			this.lines(
				[
					[(w - 2 * rx), 0],
					[(rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry],
					[0, (h - 2 * ry)],
					[0, (ry * MyArc),  - (rx * MyArc), ry, -rx, ry],
					[(-w + 2 * rx), 0],
					[ - (rx * MyArc), 0, -rx,  - (ry * MyArc), -rx, -ry],
					[0, (-h + 2 * ry)],
					[0,  - (ry * MyArc), (rx * MyArc), -ry, rx, -ry]
				],
				x + rx,
				y, // start of path
				[1, 1],
				style);
			return this;
		};

		/**
		 * Adds an ellipse to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
		 * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name ellipse
		 */
		API.ellipse = function(x, y, rx, ry, style) {
			var lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
				ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

			out([
					f2((x + rx) * k),
					f2((pageHeight - y) * k),
					'm',
					f2((x + rx) * k),
					f2((pageHeight - (y - ly)) * k),
					f2((x + lx) * k),
					f2((pageHeight - (y - ry)) * k),
					f2(x * k),
					f2((pageHeight - (y - ry)) * k),
					'c'
				].join(' '));
			out([
					f2((x - lx) * k),
					f2((pageHeight - (y - ry)) * k),
					f2((x - rx) * k),
					f2((pageHeight - (y - ly)) * k),
					f2((x - rx) * k),
					f2((pageHeight - y) * k),
					'c'
				].join(' '));
			out([
					f2((x - rx) * k),
					f2((pageHeight - (y + ly)) * k),
					f2((x - lx) * k),
					f2((pageHeight - (y + ry)) * k),
					f2(x * k),
					f2((pageHeight - (y + ry)) * k),
					'c'
				].join(' '));
			out([
					f2((x + lx) * k),
					f2((pageHeight - (y + ry)) * k),
					f2((x + rx) * k),
					f2((pageHeight - (y + ly)) * k),
					f2((x + rx) * k),
					f2((pageHeight - y) * k),
					'c'
				].join(' '));

			if (style !== null) {
				out(getStyle(style));
			}

			return this;
		};

		/**
		 * Adds an circle to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} r Radius (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name circle
		 */
		API.circle = function(x, y, r, style) {
			return this.ellipse(x, y, r, r, style);
		};

		/**
		 * Adds a properties to the PDF document
		 *
		 * @param {Object} A property_name-to-property_value object structure.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setProperties
		 */
		API.setProperties = function(properties) {
			// copying only those properties we can render.
			for (var property in documentProperties) {
				if (documentProperties.hasOwnProperty(property) && properties[property]) {
					documentProperties[property] = properties[property];
				}
			}
			return this;
		};

		/**
		 * Sets font size for upcoming text elements.
		 *
		 * @param {Number} size Font size in points.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFontSize
		 */
		API.setFontSize = function(size) {
			activeFontSize = size;
			return this;
		};

		/**
		 * Sets text font face, variant for upcoming text elements.
		 * See output of jsPDF.getFontList() for possible font names, styles.
		 *
		 * @param {String} fontName Font name or family. Example: "times"
		 * @param {String} fontStyle Font style or variant. Example: "italic"
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFont
		 */
		API.setFont = function(fontName, fontStyle) {
			activeFontKey = getFont(fontName, fontStyle);
			// if font is not found, the above line blows up and we never go further
			return this;
		};

		/**
		 * Switches font style or variant for upcoming text elements,
		 * while keeping the font face or family same.
		 * See output of jsPDF.getFontList() for possible font names, styles.
		 *
		 * @param {String} style Font style or variant. Example: "italic"
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFontStyle
		 */
		API.setFontStyle = API.setFontType = function(style) {
			activeFontKey = getFont(undefined, style);
			// if font is not found, the above line blows up and we never go further
			return this;
		};

		/**
		 * Returns an object - a tree of fontName to fontStyle relationships available to
		 * active PDF document.
		 *
		 * @public
		 * @function
		 * @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
		 * @methodOf jsPDF#
		 * @name getFontList
		 */
		API.getFontList = function() {
			// TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
			var list = {},fontName,fontStyle,tmp;

			for (fontName in fontmap) {
				if (fontmap.hasOwnProperty(fontName)) {
					list[fontName] = tmp = [];
					for (fontStyle in fontmap[fontName]) {
						if (fontmap[fontName].hasOwnProperty(fontStyle)) {
							tmp.push(fontStyle);
						}
					}
				}
			}

			return list;
		};

		/**
		 * Add a custom font.
		 *
		 * @param {String} Postscript name of the Font.  Example: "Menlo-Regular"
		 * @param {String} Name of font-family from @font-face definition.  Example: "Menlo Regular"
		 * @param {String} Font style.  Example: "normal"
		 * @function
		 * @returns the {fontKey} (same as the internal method)
		 * @methodOf jsPDF#
		 * @name addFont
		 */
		API.addFont = function(postScriptName, fontName, fontStyle) {
		  addFont(postScriptName, fontName, fontStyle, 'StandardEncoding');
		};

		/**
		 * Sets line width for upcoming lines.
		 *
		 * @param {Number} width Line width (in units declared at inception of PDF document)
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setLineWidth
		 */
		API.setLineWidth = function(width) {
			out((width * k).toFixed(2) + ' w');
			return this;
		};

		/**
		 * Sets the stroke color for upcoming elements.
		 *
		 * Depending on the number of arguments given, Gray, RGB, or CMYK
		 * color space is implied.
		 *
		 * When only ch1 is given, "Gray" color space is implied and it
		 * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
		 * if values are communicated as String types, or in range from 0 (black)
		 * to 255 (white) if communicated as Number type.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
		 * value must be in the range from 0.00 (minimum intensity) to to 1.00
		 * (max intensity) if values are communicated as String types, or
		 * from 0 (min intensity) to to 255 (max intensity) if values are communicated
		 * as Number types.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
		 * value must be a in the range from 0.00 (0% concentration) to to
		 * 1.00 (100% concentration)
		 *
		 * Because JavaScript treats fixed point numbers badly (rounds to
		 * floating point nearest to binary representation) it is highly advised to
		 * communicate the fractional numbers as String types, not JavaScript Number type.
		 *
		 * @param {Number|String} ch1 Color channel value
		 * @param {Number|String} ch2 Color channel value
		 * @param {Number|String} ch3 Color channel value
		 * @param {Number|String} ch4 Color channel value
		 *
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setDrawColor
		 */
		API.setDrawColor = function(ch1, ch2, ch3, ch4) {
			var color;
			if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
				// Gray color space.
				if (typeof ch1 === 'string') {
					color = ch1 + ' G';
				} else {
					color = f2(ch1 / 255) + ' G';
				}
			} else if (ch4 === undefined) {
				// RGB
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, 'RG'].join(' ');
				} else {
					color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
				}
			} else {
				// CMYK
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
				} else {
					color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
				}
			}

			out(color);
			return this;
		};

		/**
		 * Sets the fill color for upcoming elements.
		 *
		 * Depending on the number of arguments given, Gray, RGB, or CMYK
		 * color space is implied.
		 *
		 * When only ch1 is given, "Gray" color space is implied and it
		 * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
		 * if values are communicated as String types, or in range from 0 (black)
		 * to 255 (white) if communicated as Number type.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
		 * value must be in the range from 0.00 (minimum intensity) to to 1.00
		 * (max intensity) if values are communicated as String types, or
		 * from 0 (min intensity) to to 255 (max intensity) if values are communicated
		 * as Number types.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
		 * value must be a in the range from 0.00 (0% concentration) to to
		 * 1.00 (100% concentration)
		 *
		 * Because JavaScript treats fixed point numbers badly (rounds to
		 * floating point nearest to binary representation) it is highly advised to
		 * communicate the fractional numbers as String types, not JavaScript Number type.
		 *
		 * @param {Number|String} ch1 Color channel value
		 * @param {Number|String} ch2 Color channel value
		 * @param {Number|String} ch3 Color channel value
		 * @param {Number|String} ch4 Color channel value
		 *
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFillColor
		 */
		API.setFillColor = function(ch1, ch2, ch3, ch4) {
			var color;

			if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
				// Gray color space.
				if (typeof ch1 === 'string') {
					color = ch1 + ' g';
				} else {
					color = f2(ch1 / 255) + ' g';
				}
			} else if (ch4 === undefined || typeof ch4 === 'object') {
				// RGB
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, 'rg'].join(' ');
				} else {
					color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
				}
				if (ch4 && ch4.a === 0){
					//TODO Implement transparency.
					//WORKAROUND use white for now
					color = ['255', '255', '255', 'rg'].join(' ');
				}
			} else {
				// CMYK
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
				} else {
					color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
				}
			}

			out(color);
			return this;
		};

		/**
		 * Sets the text color for upcoming elements.
		 * If only one, first argument is given,
		 * treats the value as gray-scale color value.
		 *
		 * @param {Number} r Red channel color value in range 0-255 or {String} r color value in hexadecimal, example: '#FFFFFF'
		 * @param {Number} g Green channel color value in range 0-255
		 * @param {Number} b Blue channel color value in range 0-255
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setTextColor
		 */
		API.setTextColor = function(r, g, b) {
			if ((typeof r === 'string') && /^#[0-9A-Fa-f]{6}$/.test(r)) {
				var hex = parseInt(r.substr(1), 16);
				r = (hex >> 16) & 255;
				g = (hex >> 8) & 255;
				b = (hex & 255);
			}

			if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
				textColor = f3(r / 255) + ' g';
			} else {
				textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
			}
			return this;
		};

		/**
		 * Is an Object providing a mapping from human-readable to
		 * integer flag values designating the varieties of line cap
		 * and join styles.
		 *
		 * @returns {Object}
		 * @fieldOf jsPDF#
		 * @name CapJoinStyles
		 */
		API.CapJoinStyles = {
			0 : 0,
			'butt' : 0,
			'but' : 0,
			'miter' : 0,
			1 : 1,
			'round' : 1,
			'rounded' : 1,
			'circle' : 1,
			2 : 2,
			'projecting' : 2,
			'project' : 2,
			'square' : 2,
			'bevel' : 2
		};

		/**
		 * Sets the line cap styles
		 * See {jsPDF.CapJoinStyles} for variants
		 *
		 * @param {String|Number} style A string or number identifying the type of line cap
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setLineCap
		 */
		API.setLineCap = function(style) {
			var id = this.CapJoinStyles[style];
			if (id === undefined) {
				throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
			}
			lineCapID = id;
			out(id + ' J');

			return this;
		};

		/**
		 * Sets the line join styles
		 * See {jsPDF.CapJoinStyles} for variants
		 *
		 * @param {String|Number} style A string or number identifying the type of line join
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setLineJoin
		 */
		API.setLineJoin = function(style) {
			var id = this.CapJoinStyles[style];
			if (id === undefined) {
				throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
			}
			lineJoinID = id;
			out(id + ' j');

			return this;
		};

		// Output is both an internal (for plugins) and external function
		API.output = output;

		/**
		 * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf')
		 * @param  {String} filename The filename including extension.
		 *
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name save
		 */
		API.save = function(filename) {
			API.output('save', filename);
		};

		// applying plugins (more methods) ON TOP of built-in API.
		// this is intentional as we allow plugins to override
		// built-ins
		for (var plugin in jsPDF.API) {
			if (jsPDF.API.hasOwnProperty(plugin)) {
				if (plugin === 'events' && jsPDF.API.events.length) {
					(function(events, newEvents) {

						// jsPDF.API.events is a JS Array of Arrays
						// where each Array is a pair of event name, handler
						// Events were added by plugins to the jsPDF instantiator.
						// These are always added to the new instance and some ran
						// during instantiation.
						var eventname,handler_and_args,i;

						for (i = newEvents.length - 1; i !== -1; i--) {
							// subscribe takes 3 args: 'topic', function, runonce_flag
							// if undefined, runonce is false.
							// users can attach callback directly,
							// or they can attach an array with [callback, runonce_flag]
							// that's what the "apply" magic is for below.
							eventname = newEvents[i][0];
							handler_and_args = newEvents[i][1];
							events.subscribe.apply(
								events,
								[eventname].concat(
									typeof handler_and_args === 'function' ?
										[handler_and_args] : handler_and_args));
						}
					}(events, jsPDF.API.events));
				} else {
					API[plugin] = jsPDF.API[plugin];
				}
			}
		}

		//////////////////////////////////////////////////////
		// continuing initialization of jsPDF Document object
		//////////////////////////////////////////////////////
		// Add the first page automatically
		addFonts();
		activeFontKey = 'F1';
		_addPage(format, orientation);

		events.publish('initialized');
		return API;
	}

	/**
	 * jsPDF.API is a STATIC property of jsPDF class.
	 * jsPDF.API is an object you can add methods and properties to.
	 * The methods / properties you add will show up in new jsPDF objects.
	 *
	 * One property is prepopulated. It is the 'events' Object. Plugin authors can add topics,
	 * callbacks to this object. These will be reassigned to all new instances of jsPDF.
	 * Examples:
	 * jsPDF.API.events['initialized'] = function(){ 'this' is API object }
	 * jsPDF.API.events['addFont'] = function(added_font_object){ 'this' is API object }
	 *
	 * @static
	 * @public
	 * @memberOf jsPDF
	 * @name API
	 *
	 * @example
	 * jsPDF.API.mymethod = function(){
	 *   // 'this' will be ref to internal API object. see jsPDF source
	 *   // , so you can refer to built-in methods like so:
	 *   //     this.line(....)
	 *   //     this.text(....)
	 * }
	 * var pdfdoc = new jsPDF()
	 * pdfdoc.mymethod() // <- !!!!!!
	 */
	jsPDF.API = {events:[]};
	jsPDF.version = "1.0.0-trunk";

	if (typeof define === 'function' && define.amd) {
		define('jsPDF', function() {
			return jsPDF;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = jsPDF;
	} else {
		global.jsPDF = jsPDF;
	}
	return jsPDF;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this));



/** @preserve
 * jsPDF addImage plugin
 * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
 *               2013 Chris Dowling, https://github.com/gingerchris
 *               2013 Trinh Ho, https://github.com/ineedfat
 *               2013 Edwin Alejandro Perez, https://github.com/eaparango
 *               2013 Norah Smith, https://github.com/burnburnrocket
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

;(function(jsPDFAPI) {
	'use strict'

	var namespace = 'addImage_',
		supported_image_types = ['jpeg', 'jpg', 'png'];

	// Image functionality ported from pdf.js
	var putImage = function(img) {

		var objectNumber = this.internal.newObject()
		, out = this.internal.write
		, putStream = this.internal.putStream

		img['n'] = objectNumber

		out('<</Type /XObject')
		out('/Subtype /Image')
		out('/Width ' + img['w'])
		out('/Height ' + img['h'])
		if (img['cs'] === this.color_spaces.INDEXED) {
			out('/ColorSpace [/Indexed /DeviceRGB '
					// if an indexed png defines more than one colour with transparency, we've created a smask
					+ (img['pal'].length / 3 - 1) + ' ' + ('smask' in img ? objectNumber + 2 : objectNumber + 1)
					+ ' 0 R]');
		} else {
			out('/ColorSpace /' + img['cs']);
			if (img['cs'] === this.color_spaces.DEVICE_CMYK) {
				out('/Decode [1 0 1 0 1 0 1 0]');
			}
		}
		out('/BitsPerComponent ' + img['bpc']);
		if ('f' in img) {
			out('/Filter /' + img['f']);
		}
		if ('dp' in img) {
			out('/DecodeParms <<' + img['dp'] + '>>');
		}
		if ('trns' in img && img['trns'].constructor == Array) {
			var trns = '',
				i = 0,
				len = img['trns'].length;
			for (; i < len; i++)
				trns += (img['trns'][i] + ' ' + img['trns'][i] + ' ');
			out('/Mask [' + trns + ']');
		}
		if ('smask' in img) {
			out('/SMask ' + (objectNumber + 1) + ' 0 R');
		}
		out('/Length ' + img['data'].length + '>>');

		putStream(img['data']);

		out('endobj');

		// Soft mask
		if ('smask' in img) {
			var dp = '/Predictor 15 /Colors 1 /BitsPerComponent ' + img['bpc'] + ' /Columns ' + img['w'];
			var smask = {'w': img['w'], 'h': img['h'], 'cs': 'DeviceGray', 'bpc': img['bpc'], 'dp': dp, 'data': img['smask']};
			if ('f' in img)
				smask.f = img['f'];
			putImage.call(this, smask);
		}

	    //Palette
		if (img['cs'] === this.color_spaces.INDEXED) {

			this.internal.newObject();
			//out('<< /Filter / ' + img['f'] +' /Length ' + img['pal'].length + '>>');
			//putStream(zlib.compress(img['pal']));
			out('<< /Length ' + img['pal'].length + '>>');
			putStream(this.arrayBufferToBinaryString(new Uint8Array(img['pal'])));
			out('endobj');
		}
	}
	, putResourcesCallback = function() {
		var images = this.internal.collections[namespace + 'images']
		for ( var i in images ) {
			putImage.call(this, images[i])
		}
	}
	, putXObjectsDictCallback = function(){
		var images = this.internal.collections[namespace + 'images']
		, out = this.internal.write
		, image
		for (var i in images) {
			image = images[i]
			out(
				'/I' + image['i']
				, image['n']
				, '0'
				, 'R'
			)
		}
	}
	, checkCompressValue = function(value) {
		if(value && typeof value === 'string')
			value = value.toUpperCase();
		return value in jsPDFAPI.image_compression ? value : jsPDFAPI.image_compression.NONE;
	}
	, getImages = function() {
		var images = this.internal.collections[namespace + 'images'];
		//first run, so initialise stuff
		if(!images) {
			this.internal.collections[namespace + 'images'] = images = {};
			this.internal.events.subscribe('putResources', putResourcesCallback);
			this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback);
		}

		return images;
	}
	, getImageIndex = function(images) {
		var imageIndex = 0;

		if (images){
			// this is NOT the first time this method is ran on this instance of jsPDF object.
			imageIndex = Object.keys ?
			Object.keys(images).length :
			(function(o){
				var i = 0
				for (var e in o){if(o.hasOwnProperty(e)){ i++ }}
				return i
			})(images)
		}

		return imageIndex;
	}
	, notDefined = function(value) {
		return typeof value === 'undefined' || value === null;
	}
	, generateAliasFromData = function(data) {
		return typeof data === 'string' && jsPDFAPI.sHashCode(data);
	}
	, doesNotSupportImageType = function(type) {
		return supported_image_types.indexOf(type) === -1;
	}
	, processMethodNotEnabled = function(type) {
		return typeof jsPDFAPI['process' + type.toUpperCase()] !== 'function';
	}
	, isDOMElement = function(object) {
		return typeof object === 'object' && object.nodeType === 1;
	}
	, createDataURIFromElement = function(element, format, angle) {

		//if element is an image which uses data url defintion, just return the dataurl
		if (element.nodeName === 'IMG' && element.hasAttribute('src')) {
			var src = ''+element.getAttribute('src');
			if (!angle && src.indexOf('data:image/') === 0) return src;

			// only if the user doesn't care about a format
			if (!format && /\.png(?:[?#].*)?$/i.test(src)) format = 'png';
		}

		if(element.nodeName === 'CANVAS') {
			var canvas = element;
		} else {
			var canvas = document.createElement('canvas');
			canvas.width = element.clientWidth || element.width;
			canvas.height = element.clientHeight || element.height;

			var ctx = canvas.getContext('2d');
			if (!ctx) {
				throw ('addImage requires canvas to be supported by browser.');
			}
			if (angle) {
				var x, y, b, c, s, w, h, to_radians = Math.PI/180, angleInRadians;

				if (typeof angle === 'object') {
					x = angle.x;
					y = angle.y;
					b = angle.bg;
					angle = angle.angle;
				}
				angleInRadians = angle*to_radians;
				c = Math.abs(Math.cos(angleInRadians));
				s = Math.abs(Math.sin(angleInRadians));
				w = canvas.width;
				h = canvas.height;
				canvas.width = h * s + w * c;
				canvas.height = h * c + w * s;

				if (isNaN(x)) x = canvas.width / 2;
				if (isNaN(y)) y = canvas.height / 2;

				ctx.clearRect(0,0,canvas.width, canvas.height);
				ctx.fillStyle = b || 'white';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.save();
				ctx.translate(x, y);
				ctx.rotate(angleInRadians);
				ctx.drawImage(element, -(w/2), -(h/2));
				ctx.rotate(-angleInRadians);
				ctx.translate(-x, -y);
				ctx.restore();
			} else {
				ctx.drawImage(element, 0, 0, canvas.width, canvas.height);
			}
		}
		return canvas.toDataURL((''+format).toLowerCase() == 'png' ? 'image/png' : 'image/jpeg');
	}
	,checkImagesForAlias = function(alias, images) {
		var cached_info;
		if(images) {
			for(var e in images) {
				if(alias === images[e].alias) {
					cached_info = images[e];
					break;
				}
			}
		}
		return cached_info;
	}
	,determineWidthAndHeight = function(w, h, info) {
		if (!w && !h) {
			w = -96;
			h = -96;
		}
		if (w < 0) {
			w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
		}
		if (h < 0) {
			h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
		}
		if (w === 0) {
			w = h * info['w'] / info['h'];
		}
		if (h === 0) {
			h = w * info['h'] / info['w'];
		}

		return [w, h];
	}
	, writeImageToPDF = function(x, y, w, h, info, index, images) {
		var dims = determineWidthAndHeight.call(this, w, h, info),
			coord = this.internal.getCoordinateString,
			vcoord = this.internal.getVerticalCoordinateString;

		w = dims[0];
		h = dims[1];

		images[index] = info;

		this.internal.write(
			'q'
			, coord(w)
			, '0 0'
			, coord(h) // TODO: check if this should be shifted by vcoord
			, coord(x)
			, vcoord(y + h)
			, 'cm /I'+info['i']
			, 'Do Q'
		)
	};

	/**
	 * COLOR SPACES
	 */
	jsPDFAPI.color_spaces = {
		DEVICE_RGB:'DeviceRGB',
		DEVICE_GRAY:'DeviceGray',
		DEVICE_CMYK:'DeviceCMYK',
		CAL_GREY:'CalGray',
		CAL_RGB:'CalRGB',
		LAB:'Lab',
		ICC_BASED:'ICCBased',
		INDEXED:'Indexed',
		PATTERN:'Pattern',
		SEPERATION:'Seperation',
		DEVICE_N:'DeviceN'
	};

	/**
	 * DECODE METHODS
	 */
	jsPDFAPI.decode = {
		DCT_DECODE:'DCTDecode',
		FLATE_DECODE:'FlateDecode',
		LZW_DECODE:'LZWDecode',
		JPX_DECODE:'JPXDecode',
		JBIG2_DECODE:'JBIG2Decode',
		ASCII85_DECODE:'ASCII85Decode',
		ASCII_HEX_DECODE:'ASCIIHexDecode',
		RUN_LENGTH_DECODE:'RunLengthDecode',
		CCITT_FAX_DECODE:'CCITTFaxDecode'
	};

	/**
	 * IMAGE COMPRESSION TYPES
	 */
	jsPDFAPI.image_compression = {
		NONE: 'NONE',
		FAST: 'FAST',
		MEDIUM: 'MEDIUM',
		SLOW: 'SLOW'
	};

	jsPDFAPI.sHashCode = function(str) {
		return Array.prototype.reduce && str.split("").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);
	};

	jsPDFAPI.isString = function(object) {
		return typeof object === 'string';
	};

	/**
	 * Strips out and returns info from a valid base64 data URI
	 * @param {String[dataURI]} a valid data URI of format 'data:[<MIME-type>][;base64],<data>'
	 * @returns an Array containing the following
	 * [0] the complete data URI
	 * [1] <MIME-type>
	 * [2] format - the second part of the mime-type i.e 'png' in 'image/png'
	 * [4] <data>
	 */
	jsPDFAPI.extractInfoFromBase64DataURI = function(dataURI) {
		return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(dataURI);
	};

	/**
	 * Check to see if ArrayBuffer is supported
	 */
	jsPDFAPI.supportsArrayBuffer = function() {
		return typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';
	};

	/**
	 * Tests supplied object to determine if ArrayBuffer
	 * @param {Object[object]}
	 */
	jsPDFAPI.isArrayBuffer = function(object) {
		if(!this.supportsArrayBuffer())
	        return false;
		return object instanceof ArrayBuffer;
	};

	/**
	 * Tests supplied object to determine if it implements the ArrayBufferView (TypedArray) interface
	 * @param {Object[object]}
	 */
	jsPDFAPI.isArrayBufferView = function(object) {
		if(!this.supportsArrayBuffer())
	        return false;
		if(typeof Uint32Array === 'undefined')
			return false;
		return (object instanceof Int8Array ||
				object instanceof Uint8Array ||
				(typeof Uint8ClampedArray !== 'undefined' && object instanceof Uint8ClampedArray) ||
				object instanceof Int16Array ||
				object instanceof Uint16Array ||
				object instanceof Int32Array ||
				object instanceof Uint32Array ||
				object instanceof Float32Array ||
				object instanceof Float64Array );
	};

	/**
	 * Exactly what it says on the tin
	 */
	jsPDFAPI.binaryStringToUint8Array = function(binary_string) {
		/*
		 * not sure how efficient this will be will bigger files. Is there a native method?
		 */
		var len = binary_string.length;
	    var bytes = new Uint8Array( len );
	    for (var i = 0; i < len; i++) {
	        bytes[i] = binary_string.charCodeAt(i);
	    }
	    return bytes;
	};

	/**
	 * @see this discussion
	 * http://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers
	 *
	 * As stated, i imagine the method below is highly inefficent for large files.
	 *
	 * Also of note from Mozilla,
	 *
	 * "However, this is slow and error-prone, due to the need for multiple conversions (especially if the binary data is not actually byte-format data, but, for example, 32-bit integers or floats)."
	 *
	 * https://developer.mozilla.org/en-US/Add-ons/Code_snippets/StringView
	 *
	 * Although i'm strugglig to see how StringView solves this issue? Doesn't appear to be a direct method for conversion?
	 *
	 * Async method using Blob and FileReader could be best, but i'm not sure how to fit it into the flow?
	 */
	jsPDFAPI.arrayBufferToBinaryString = function(buffer) {
		if(this.isArrayBuffer(buffer))
			buffer = new Uint8Array(buffer);

	    var binary_string = '';
	    var len = buffer.byteLength;
	    for (var i = 0; i < len; i++) {
	        binary_string += String.fromCharCode(buffer[i]);
	    }
	    return binary_string;
	    /*
	     * Another solution is the method below - convert array buffer straight to base64 and then use atob
	     */
		//return atob(this.arrayBufferToBase64(buffer));
	};

	/**
	 * Converts an ArrayBuffer directly to base64
	 *
	 * Taken from here
	 *
	 * http://jsperf.com/encoding-xhr-image-data/31
	 *
	 * Need to test if this is a better solution for larger files
	 *
	 */
	jsPDFAPI.arrayBufferToBase64 = function(arrayBuffer) {
		var base64    = ''
		var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

		var bytes         = new Uint8Array(arrayBuffer)
		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	};

	jsPDFAPI.createImageInfo = function(data, wd, ht, cs, bpc, f, imageIndex, alias, dp, trns, pal, smask) {
		var info = {
				alias:alias,
				w : wd,
				h : ht,
				cs : cs,
				bpc : bpc,
				i : imageIndex,
				data : data
				// n: objectNumber will be added by putImage code
			};

		if(f) info.f = f;
		if(dp) info.dp = dp;
		if(trns) info.trns = trns;
		if(pal) info.pal = pal;
		if(smask) info.smask = smask;

		return info;
	};

	jsPDFAPI.addImage = function(imageData, format, x, y, w, h, alias, compression, rotation) {
		'use strict'

		if(typeof format !== 'string') {
			var tmp = h;
			h = w;
			w = y;
			y = x;
			x = format;
			format = tmp;
		}

		if (typeof imageData === 'object' && !isDOMElement(imageData) && "imageData" in imageData) {
			var options = imageData;

			imageData = options.imageData;
			format = options.format || format;
			x = options.x || x || 0;
			y = options.y || y || 0;
			w = options.w || w;
			h = options.h || h;
			alias = options.alias || alias;
			compression = options.compression || compression;
			rotation = options.rotation || options.angle || rotation;
		}

		if (isNaN(x) || isNaN(y))
		{
			console.error('jsPDF.addImage: Invalid coordinates', arguments);
			throw new Error('Invalid coordinates passed to jsPDF.addImage');
		}

		var images = getImages.call(this), info;

		if (!(info = checkImagesForAlias(imageData, images))) {
			var dataAsBinaryString;

			if(isDOMElement(imageData))
				imageData = createDataURIFromElement(imageData, format, rotation);

			if(notDefined(alias))
				alias = generateAliasFromData(imageData);

			if (!(info = checkImagesForAlias(alias, images))) {

				if(this.isString(imageData)) {

					var base64Info = this.extractInfoFromBase64DataURI(imageData);

					if(base64Info) {

						format = base64Info[2];
						imageData = atob(base64Info[3]);//convert to binary string

					} else {

						if (imageData.charCodeAt(0) === 0x89 &&
							imageData.charCodeAt(1) === 0x50 &&
							imageData.charCodeAt(2) === 0x4e &&
							imageData.charCodeAt(3) === 0x47  )  format = 'png';
					}
				}
				format = (format || 'JPEG').toLowerCase();

				if(doesNotSupportImageType(format))
					throw new Error('addImage currently only supports formats ' + supported_image_types + ', not \''+format+'\'');

				if(processMethodNotEnabled(format))
					throw new Error('please ensure that the plugin for \''+format+'\' support is added');

				/**
				 * need to test if it's more efficent to convert all binary strings
				 * to TypedArray - or should we just leave and process as string?
				 */
				if(this.supportsArrayBuffer()) {
					dataAsBinaryString = imageData;
					imageData = this.binaryStringToUint8Array(imageData);
				}

				info = this['process' + format.toUpperCase()](
					imageData,
					getImageIndex(images),
					alias,
					checkCompressValue(compression),
					dataAsBinaryString
				);

				if(!info)
					throw new Error('An unkwown error occurred whilst processing the image');
			}
		}

		writeImageToPDF.call(this, x, y, w, h, info, info.i, images);

		return this
	};

	/**
	 * JPEG SUPPORT
	 **/

	//takes a string imgData containing the raw bytes of
	//a jpeg image and returns [width, height]
	//Algorithm from: http://www.64lines.com/jpeg-width-height
	var getJpegSize = function(imgData) {
		'use strict'
		var width, height, numcomponents;
		// Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
		if (!imgData.charCodeAt(0) === 0xff ||
			!imgData.charCodeAt(1) === 0xd8 ||
			!imgData.charCodeAt(2) === 0xff ||
			!imgData.charCodeAt(3) === 0xe0 ||
			!imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||
			!imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||
			!imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||
			!imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||
			!imgData.charCodeAt(10) === 0x00) {
				throw new Error('getJpegSize requires a binary string jpeg file')
		}
		var blockLength = imgData.charCodeAt(4)*256 + imgData.charCodeAt(5);
		var i = 4, len = imgData.length;
		while ( i < len ) {
			i += blockLength;
			if (imgData.charCodeAt(i) !== 0xff) {
				throw new Error('getJpegSize could not find the size of the image');
			}
			if (imgData.charCodeAt(i+1) === 0xc0 || //(SOF) Huffman  - Baseline DCT
			    imgData.charCodeAt(i+1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT
			    imgData.charCodeAt(i+1) === 0xc2 || // Progressive DCT (SOF2)
			    imgData.charCodeAt(i+1) === 0xc3 || // Spatial (sequential) lossless (SOF3)
			    imgData.charCodeAt(i+1) === 0xc4 || // Differential sequential DCT (SOF5)
			    imgData.charCodeAt(i+1) === 0xc5 || // Differential progressive DCT (SOF6)
			    imgData.charCodeAt(i+1) === 0xc6 || // Differential spatial (SOF7)
			    imgData.charCodeAt(i+1) === 0xc7) {
				height = imgData.charCodeAt(i+5)*256 + imgData.charCodeAt(i+6);
				width = imgData.charCodeAt(i+7)*256 + imgData.charCodeAt(i+8);
                numcomponents = imgData.charCodeAt(i+9);
				return [width, height, numcomponents];
			} else {
				i += 2;
				blockLength = imgData.charCodeAt(i)*256 + imgData.charCodeAt(i+1)
			}
		}
	}
	, getJpegSizeFromBytes = function(data) {

		var hdr = (data[0] << 8) | data[1];

		if(hdr !== 0xFFD8)
			throw new Error('Supplied data is not a JPEG');

		var len = data.length,
			block = (data[4] << 8) + data[5],
			pos = 4,
			bytes, width, height, numcomponents;

		while(pos < len) {
			pos += block;
			bytes = readBytes(data, pos);
			block = (bytes[2] << 8) + bytes[3];
			if((bytes[1] === 0xC0 || bytes[1] === 0xC2) && bytes[0] === 0xFF && block > 7) {
				bytes = readBytes(data, pos + 5);
				width = (bytes[2] << 8) + bytes[3];
				height = (bytes[0] << 8) + bytes[1];
                numcomponents = bytes[4];
				return {width:width, height:height, numcomponents: numcomponents};
			}

			pos+=2;
		}

		throw new Error('getJpegSizeFromBytes could not find the size of the image');
	}
	, readBytes = function(data, offset) {
		return data.subarray(offset, offset+ 5);
	};

	jsPDFAPI.processJPEG = function(data, index, alias, compression, dataAsBinaryString) {
		'use strict'
		var colorSpace = this.color_spaces.DEVICE_RGB,
			filter = this.decode.DCT_DECODE,
			bpc = 8,
			dims;

		if(this.isString(data)) {
			dims = getJpegSize(data);
			return this.createImageInfo(data, dims[0], dims[1], dims[3] == 1 ? this.color_spaces.DEVICE_GRAY:colorSpace, bpc, filter, index, alias);
		}

		if(this.isArrayBuffer(data))
			data = new Uint8Array(data);

		if(this.isArrayBufferView(data)) {

			dims = getJpegSizeFromBytes(data);

			// if we already have a stored binary string rep use that
			data = dataAsBinaryString || this.arrayBufferToBinaryString(data);

			return this.createImageInfo(data, dims.width, dims.height, dims.numcomponents == 1 ? this.color_spaces.DEVICE_GRAY:colorSpace, bpc, filter, index, alias);
		}

		return null;
	};

	jsPDFAPI.processJPG = function(/*data, index, alias, compression, dataAsBinaryString*/) {
		return this.processJPEG.apply(this, arguments);
	}

})(jsPDF.API);


/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.1.20151003
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent)
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if (target_view && is_safari && typeof FileReader !== "undefined") {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var base64Data = reader.result;
							target_view.location.href = "data:attachment/file" + base64Data.slice(base64Data.search(/[,;]/));
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && is_safari) {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name, no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name || "download");
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}
},{}],56:[function(require,module,exports){
require('./controllers/app.controllers.js');
require('./services/app.services.js');
require('./directives/app.directives.js');
require('./templates/app.templates.js');
require('./helpers/app.helpers.js');
require('./filters/app.filters.js');
var agGrid = require('ag-grid');



agGrid.initialiseAgGridWithAngular1(angular);

var app = angular.module('app', ['agGrid', 'ionic', 'ngCordova', 'ion-affix', 'angular.filter', 'ui.router', 'ui.bootstrap', 'ngAnimate', 'app.templates', 'app.controllers', 'app.services', 'app.directives', 'app.helpers', 'app.filters', 'baiduMap', 'ui.grid', 'ui.grid.edit', 'ui.grid.cellNav', 'ui.grid.pagination', 'ui.grid.pinning', 'ui.grid.selection', 'ui.grid.infiniteScroll', 'ui.grid.edit', 'ui.grid.grouping', 'ui.tree', 'highcharts-ng', 'angular-loading-bar', 'rzModule', 'LocalStorageModule', 'ngFileUpload', 'ngMaterial', 'angular-cache', 'toastr'])
app.config(['$stateProvider', '$urlRouterProvider', '$ionicConfigProvider', '$provide', '$locationProvider', '$httpProvider', 'localStorageServiceProvider', '$mdThemingProvider', 'platformProvider', 'navDelegateProvider',
    function($stateProvider, $urlRouterProvider, $ionicConfigProvider, $provide, $locationProvider, $httpProvider, localStorageServiceProvider, $mdThemingProvider, platformProvider, navDelegateProvider) {

        $httpProvider.defaults.headers.common = {};
        $httpProvider.defaults.headers.post = {};
        $httpProvider.defaults.headers.put = {};
        $httpProvider.defaults.headers.patch = {};

        $ionicConfigProvider.backButton.text(null);
        $ionicConfigProvider.backButton.previousTitleText(false);
        $ionicConfigProvider.views.maxCache(0);

        if (platformProvider.isMobile()) {
            $locationProvider.html5Mode({ enabled: false });
            $urlRouterProvider.otherwise('/login');
        } else {
            var base = document.createElement('base');
            base.href = '/';
            document.getElementsByTagName('head')[0].appendChild(base);
            $locationProvider.html5Mode({ enabled: true });
            $urlRouterProvider.otherwise('/login');
        }

        //material design theme
        $mdThemingProvider.theme('default')
            .primaryPalette('light-green',{
              'default': '700', // by default use shade 400 from the pink palette for primary intentions
              'hue-1': '100', // use shade 100 for the <code>md-hue-1</code> class
              'hue-2': '600', // use shade 600 for the <code>md-hue-2</code> class
              'hue-3': 'A100' // use shade A100 for the <code>md-hue-3</code> class
            })
            .accentPalette('orange');

        localStorageServiceProvider.setPrefix('eqouta');

        /*

            root
                ''              ./_layout.html
                'nav@root'          ./nav.units.html
                'map@root'          ./views/home/map.html
                '@root'             - empty -


            *****************************************
            *
            *   LOGIN
            *
            *****************************************


            root.login      
                '@root'             ./login.html


             
            *****************************************
            *
            *   NAVIGATION
            *
            *****************************************


            // unit selection 
            root.home   
                '@root'             ./home/home.html                        always hidden to reveal map for Energy Unit selection
                

            // navigation for selected user 
            root.home.unit
                'nav@root'          ./nav.sitemap.html                      shown when Energy Unit selected                      



            *****************************************
            *
            *   REPORTS
            *
            *****************************************


            // RESERVED: layout for reports 
            root.home.unit.reports
                '@root'             ./views/reports.html                    reserved for Reports layout 


            root.home.unit.reports.*
                '@root.home.unit.reports'



            *****************************************
            *
            *   DATA
            *
            *****************************************


            root.home.unit.charts
                '@root'             ./views/charts.html                     reserved for Data layout  
                'nav@root'          ./views/charts/_sidebar.html 


            *****************************************
            *
            *   ACCOUNT
            *
            *****************************************


            root.login      
                '@root'             ./login.html


        */


        $stateProvider
            .state('root', {
                abstract: true,
                url: '',
                views: {
                    '': { // load: into nameless view in: ./common/templates/angular/index.html or ./mobile/ionic/www/index.html 
                        templateUrl: "static/views/_layout.html",
                        controller: 'rootCtrl'
                    },
                    // '@root': { // <-- load into nameless view in: ./views/_layout.html
                    //     templateUrl: DEFAULT_VIEW,
                    //     controller: DEFAULT_CTRL
                    // },
                    'map@root': {
                        templateUrl: "static/views/home/map.html",
                        controller: 'mapCtrl'
                    },
                    'subnav@root':{
                        templateUrl: 'static/views/nav.units.html',
                        controller: 'unitsCtrl'
                    }
                }
            })
            .state('root.login', {
                url: '/login',
                skipAuthorization: true,
                views: {
                    '': {
                        templateUrl: "static/views/login.html",
                        controller: 'loginCtrl'
                    }
                }
            })
            .state('root.home', {
                url: '/',
                data:{
                    title: 'Browse'
                },
                views: {
                    '': {
                        templateUrl: "static/views/home.html",
                        controller: 'homeCtrl'
                    }
                    /*,
                    'news@root.home': {
                        templateUrl: "static/views/news/news.list.html",
                        controller: 'newsCtrl'
                    },
                    'map@root.home': {
                        templateUrl: 'static/views/home/map.html',
                        controller: 'mapCtrl'
                    }*/
                }
            })
            .state('root.home.unit', {
                url: '{id:[0-9]+}',
                data:{
                    title: 'Browse'
                },
                views: {
                    'subnav@root': {
                        templateUrl: 'static/views/nav.sitemap.html',
                        controller: 'sitemapCtrl'
                    }
                }
            })


            /**********************************************************************************************
             *
             * News
            *
             **********************************************************************************************/

            .state('root.news', {
                url: '/news',
                data:{
                    title: 'News'
                },
                views: {
                    '@root': {},
                    'subnav@root': {
                        templateUrl: 'static/views/news/news.list.html',
                        controller: 'newsCtrl'
                    }
                }
            })
            .state('root.news.details', {
                url: '/:id',
                views: {
                    '@root': {
                        templateUrl: "static/views/news/news.details.html",
                        controller: 'newsCtrl'
                    }
                }
            })



            /**********************************************************************************************
             *
             * Reports
             * 
             **********************************************************************************************/

            .state('root.home.unit.reports', {
                abstract: true,
                url: '/reports',
                views: {
                    '@root': {
                        templateUrl: "static/views/reports.html",
                        //controller: 'reportsSharedCtrl'                        
                    },
                    // 'nav@root.reports': {
                    //     templateUrl: "static/views/reports/_sidebar.html",
                    //     controller: 'reportsNavCtrl'
                    // }
                }
            })

            .state('root.home.unit.reports.summary', {
                url: '/summary',
                data: { title: '核心能耗表现与综述', subtitle: 'Core Performance And Summary' },
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/summary.html",
                        controller: 'reportsSummaryCtrl'
                    },
                }
            })
            .state('root.home.unit.reports.daily', {
                data: { title: '能耗构成解析', subtitle: 'Daily Statics' },
                url: '/daily',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/daily.html",
                        controller: 'reportsDailyCtrl'
                    },
                }
            })
            .state('root.home.unit.reports.disagg', {
                data: { title: '能耗构成解析', subtitle: 'Energy Disaggregation' },
                url: '/disagg',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/disagg.html",
                        controller: 'reportsDisaggCtrl'
                    },
                }
            })
            
            /*.state('root.home.unit.reports.consumptionTrends', {
                data: { title: '各项能耗每月与月内趋势分析', subtitle: 'Energy Usage Percentage Trend' },
                url: '/consumption-trends',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/consumptionTrends.html",
                        controller: 'reportsConsumptionTrendsCtrl'
                    },
                }
            })*/
            .state('root.home.unit.reports.monthly', {
                data: { title: '全年各项能耗总计分析', subtitle: 'Annual Energy Consumption' },
                url: '/monthly',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/monthly.html",
                        controller: 'reportsMonthlyCtrl'
                    },
                }
            })
            .state('root.home.unit.reports.trend', {
                data: { title: '能耗趋势与外部因素分析', subtitle: 'Daily Energy Consumption and External Factors' },
                url: '/trend',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/trend.html",
                        controller: 'reportsTrendCtrl'
                    },
                }
            })
            .state('root.home.unit.reports.regular', {
                data: { title: '常规能耗指标分析', subtitle: 'Energy Efficiency and Metrics' },
                url: '/regular',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/regular.html",
                        controller: 'reportsRegularCtrl'
                    },
                }
            })
            .state('root.home.unit.reports.sankey', {
                data: { title: 'Sankey Flow', subtitle: 'Sankey flow and comsumption temperature analysis'},
                url: '/sankey',
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/sankey.html",
                        controller: 'reportsSankeyCtrl'
                    }
                }
            })
            .state('root.home.unit.reports.alerts', {
                data: { title: '异常警报', subtitle: '能效监测' },
                url: '/alerts',
                cache: false,
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/alerts.html",
                        controller: 'reportsAlertsCtrl'
                    },
                }
            })
            .state('root.home.unit.reports.alerts.details', {
                data: { title: '异常详情', subtitle: '能效监测' },
                url: '/details/:aid',
                cache: false,
                views: {
                    '@root.home.unit.reports': {
                        templateUrl: "static/views/reports/alert.details.html",
                        controller: 'reportsAlertDetailsCtrl'
                    },
                }
            })
            
            // reserved as in original
            //.state('root.reports.recommendation', {
            //    url: '/recommendation',
            //    views: {
            //        '@root.reports': {
            //            templateUrl: "static/views/reports/recommendation.html",
            //            //controller: 'reportsCtrl'
            //        },
            //    }
            //})

            /***********************************************
             *
             * Recomendations
             *
             ***********************************************/

	    .state('root.home.unit.tools', {
                abstract: true,
                url: '/tools',
                data: { title: '节能建议与策划', subtitle: 'Optimization and Recommendation' },
                views: {
                    '@root': {
                        templateUrl: "static/views/recommendations.html"
                    },
                    // 'nav@root.recommendations': {
                    //     templateUrl: "static/views/recommendations/_sidebar.html",
                    //     controller: 'recommendationsNavCtrl'
                    // }
                }
            })
	    .state('root.home.unit.tools.analysis', {
                url: '/anaylsis',
                data: { title: '节能策略方案', subtitle: 'Analysis' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/tools/analysis.html",
                        controller: 'analysisCtrl'
                    },
                }
            })
	    .state('root.home.unit.tools.strategies', {
                url: '/strategies',
                data: { title: '节能策略方案', subtitle: 'Energy Efficiency Strategies' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/recommendations/strategies.html",
                        controller: 'recommendationsStrategiesCtrl'
                    },
                }
            })
	    
            .state('root.home.unit.tools.strategies.strategy1', {
                url: '/strategy1',
                data: { title: '节能试验室: 分时段对比', subtitle: '...' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/recommendations/strategies/strategy1.html",
                        controller: 'strategy1Ctrl'
                    },
                }
            })
            .state('root.home.unit.tools.strategies.strategy2', {
                url: '/strategy2',
                data: { title: '节能试验室: 削峰填谷', subtitle: '...' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/recommendations/strategies/strategy2.html",
                        controller: 'strategy2Ctrl'
                    },
                }
            })
            .state('root.home.unit.tools.strategies.strategy3', {
                url: '/strategy3',
                data: { title: '节能试验室: 晚间与周末分析', subtitle: '...' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/recommendations/strategies/strategy3.html",
                        controller: 'strategy3Ctrl'
                    },
                }
            })
            .state('root.home.unit.tools.strategies.strategy4', {
                url: '/strategy4',
                data: { title: '策划与分析: 节能目标分析', subtitle: '...' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/recommendations/strategies/strategy4.html",
                        controller: 'strategy4Ctrl'
                    },
                }
            })
            .state('root.home.unit.tools.strategies.strategy5', {
                url: '/strategy5',
                data: { title: '策划与分析: 能耗表现', subtitle: '...' },
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/recommendations/strategies/strategy5.html",
                        controller: 'strategy5Ctrl'
                    },
                }
            })
	    .state('root.home.unit.tools.heatmap', {
                data: { title: '全年能耗透视图', subtitle: 'Energy MRI versus Temperature' },
                url: '/heatmap',
                views: {
                    '@root.home.unit.tools': {
                        templateUrl: "static/views/reports/heatmap.html",
                        controller: 'reportsHeatmapCtrl'
                    },
                }
            })


            .state('root.home.unit.recommendations', {
                abstract: true,
                url: '/recommendations',
                data: { title: '节能建议与策划', subtitle: 'Optimization and Recommendation' },
                views: {
                    '@root': {
                        templateUrl: "static/views/recommendations.html"
                    },
                    // 'nav@root.recommendations': {
                    //     templateUrl: "static/views/recommendations/_sidebar.html",
                    //     controller: 'recommendationsNavCtrl'
                    // }
                }
            })
            .state('root.home.unit.recommendations.summary', {
                url: '/summary',
                data: { title: '节能建议与策划', subtitle: 'Optimization and Recommendation' },
                views: {
                    '@root.home.unit.recommendations': {
                        templateUrl: "static/views/recommendations/summary.html",
                        controller: 'recommendationsSummaryCtrl'
                    },
                }
            })
            .state('root.home.unit.recommendations.details', {
                url: '/details/:rid',
                data: { title: '节能建议与策划', subtitle: 'Optimization and Recommendation' },
                views: {
                    '@root.home.unit.recommendations': {
                        templateUrl: "static/views/recommendations/summary.details.html",
                        controller: 'recommendationsSummaryDetailsCtrl'
                    },
                }
            })
            
            .state('root.home.unit.recommendations.configuration', {
                url: '/configuration',
                data: { title: '系统控制', subtitle: '节能建议系统控制' },
                views: {
                    '@root.home.unit.recommendations': {
                        templateUrl: "static/views/recommendations/configuration.html",
                        controller: 'recommendationsConfigurationCtrl'
                    },
                }
            })
	    .state('root.home.unit.recommendations.alerts', {
                data: { title: '异常警报', subtitle: '能效监测' },
                url: '/alerts',
                views: {
                    '@root.home.unit.recommendations': {
                        templateUrl: "static/views/reports/alerts.html",
                        controller: 'reportsAlertsCtrl'
                    },
                }
            })
            .state('root.home.unit.recommendations.alerts.details', {
                data: { title: '异常详情', subtitle: '能效监测' },
                url: '/details/:aid',
                views: {
                    '@root.home.unit.recommendations': {
                        templateUrl: "static/views/recommendations/alert.details.html",
                        controller: 'reportsAlertDetailsCtrl'
                    },
                }
            })

            /***********************************************
             *
             * Charts
             *
             ***********************************************/

            .state('root.charts', {
                abstract: true,
                url: '',
                views: {
                    '@root': {
                        templateUrl: "static/views/charts.html"
                    },
                    'subnav@root': {
                        templateUrl: "static/views/charts/_sidebar.html",
                        controller: 'chartsNavCtrl'
                    }
                }
            })
            .state('root.charts.summary', {
                url: '/charts',
                data: { title: '实时能源数据', subtitle: 'Energy data' },
                views: {
                    '@root.charts': {
                        templateUrl: "static/views/charts/summary.html",
                        controller: 'chartsCtrl'
                    }
                }
            })

            .state('root.charts.summary.list', {
                url: '/list',
                data: { title: 'LIST', subtitle: 'Entities' },
                views: {
                    '': {
                        templateUrl: "static/views/charts/list.html",
                        controller: 'chartsListCtrl'
                    }
                }
            })

            .state('root.charts.summary.edit', {
                url: '/edit/:uid',
                data: { title: 'Entity', subtitle: 'SETTINGS' },
                views: {
                    '': {
                        templateUrl: "static/views/charts/edit.html",
                        controller: 'chartsEditCtrl'
                    },
                    'subnav@root': {
                        templateUrl: "static/views/charts/_sidebarEdit.html",
                        controller: 'chartsNavCtrl'
                    }
                }
            })

            .state('root.charts.summary.import', {
                url: '/import/:uid',
                data: { title: 'Entity', subtitle: 'IMPORT' },
                views: {
                    '': {
                        templateUrl: "static/views/charts/import.html",
                        controller: 'chartsImportCtrl'
                    },
                    'subnav@root': {
                        templateUrl: "static/views/charts/_sidebarEdit.html",
                        controller: 'chartsNavCtrl'
                    }
                }
            })

            /***********************************************
             *
             * Admin
             *
             ***********************************************/

            .state('root.admin', {
                url: '/admin',
                views: {
                    '': {
                        templateUrl: "static/views/admin.html",
                        controller: 'adminCtrl'
                    }
                }
            })

             /***********************************************
             *
             * User Account
             *
             ***********************************************/

            .state('root.account', {
                abstract: true,
                url: '/account',
                views: {
                    '@root': {
                        templateUrl: "static/views/account.html"
                    },
                    'subnav@root': {
                        templateUrl: "static/views/account/_sidebar.html",
                        controller: 'profileNavCtrl'
                    }
                }
            })
            .state('root.account.user', {
                url: '/user',
                data: { title: '设置' },
                views: {
                    '@root.account': {
                        templateUrl: "static/views/account/profileUser.html",
                        controller: 'profileUserCtrl',
                    }
                }
            })
            .state('root.account.company', {
                url: '/company',
                data: { title: '设置' },
                views: {
                    '@root.account': {
                        templateUrl: "static/views/account/profileCompany.html",
                        controller: 'profileCompanyCtrl',
                    }
                }
            });

        //
        // MOVED: services/app.account.js
        //
        // $httpProvider.interceptors.push(['$q', '$location', '$rootScope', 'localStorageService',function($q, $location, $rootScope,localStorageService) {
        //     return {
        //         'request': function (config) {
        //             var token = localStorageService.get('token');
        //             config.headers = config.headers || {};
        //             if (token) {
        //                 config.headers.Authorization = 'Bearer ' + token;
        //             }
        //             return config;
        //         },
        //         'response':function(response){
        //             // refresh token
        //             storedToken=localStorageService.get('token');
        //             receivedToken=response.headers('http_authorization');
        //             if(receivedToken){
        //                 receivedToken=receivedToken.split(" ")[1];
        //                 if (receivedToken&&storedToken !== receivedToken){
        //                     localStorageService.set('token',receivedToken);
        //                 }
        //             }
        //             return response
        //         },
        //         'responseError': function(response) {
        //             if(response.status === 401 || response.status === 403) {
        //                 localStorageService.remove('token')
        //                 $location.path('/login/');
        //             }
        //             return $q.reject(response);
        //         }
        //     };
        // }]);

    }
]); // --app.config


app.run(['$rootScope', '$state', '$stateParams', '$location', '$anchorScroll', '$window','EnergyUnitFactory', 'authService', '$timeout', '$ionicViewSwitcher', '$ionicHistory',
    function ($rootScope, $state, $stateParams, $location, $anchorScroll, $window, EnergyUnitFactory, authService, $timeout, $ionicViewSwitcher, $ionicHistory) {

        // Reference $state and $stateParams to the $rootScope so that
        // we can access them from any scope within applications.
        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;

        $rootScope.activeView = 'content';
        $rootScope.setActiveView = function(viewName){
            $rootScope.activeView = viewName;
        }


        // TODO: Refactor window resize function

        $rootScope.resize = function(){
            $timeout(function(){
                angular.element($window).triggerHandler('resize');
                $($window).triggerHandler('resize');
                $rootScope.$broadcast('window:resize');
            });
        }



        // Cache buildings on authentication and reload 
        var loadBuildings = function(){
            EnergyUnitFactory.getByType(1).then(function(result) {
                $rootScope.buildings = result;
            });
        }
        
        // authService.login() event: app.account.js
        var onAuthSuccess = $rootScope.$on('auth:success', function() {
            loadBuildings();
        });

        // Cache on reload
        if(authService.isAuthorized()){
            loadBuildings();
        }


        $rootScope.$watch(authService.profile(), function(newValue){
            $rootScope.account = newValue;
        });
        
        $rootScope.isAuthorized = function(){
            return authService.isAuthorized();
        }


        // TODO: Refactor mobile sidemenu functions

        $rootScope.toggleBuildings = function(){
            $rootScope.expanded = !$rootScope.expanded; 
        };

        $rootScope.buildingsExpanded = function(){
            return $rootScope.expanded; 
        };

        $rootScope.selectBuilding = function(building){
            $rootScope.expanded = false;
            $rootScope.$state.go($rootScope.$state.current.name, { id: building.id });
        }


        $rootScope.go = function(stateName, stateParams, direction = 'forward'){
        console.log('stateParams ' , stateParams);
            $ionicViewSwitcher.nextDirection(direction);
            $state.go(stateName, stateParams);
        }

        $rootScope.goBack = function(levels){
            if(!levels) levels = -1;
                $ionicHistory.goBack(levels);
        }

        // App destroy event

        $rootScope.$on('$destroy', function() {
            onAuthSuccess();
        });

    }
]);


angular.element(document).ready(function () {
    angular.bootstrap(document, ['app']);
});

// Material design: Google Chrome password field decoration fix 
var mdInputContainerDirective = ['$delegate', '$interval', '$mdTheming', function($delegate, $interval,  $mdTheming) {
     var directive = $delegate[0];

     directive.compile = function() {
      return {
        post: function($scope, element, attr, ctrl) {
          $mdTheming(element);
 
          var interval;
          var count = 0;

          if (ctrl.input[0].type === 'password') {
            interval = $interval(function() {
              if (count > 10) {
                $interval.cancel(interval);
              }

              if (ctrl.input.parent()[0].querySelector('input:-webkit-autofill')) {
                ctrl.element.addClass('md-input-has-value');
                $interval.cancel(interval);
              }

              count++;
            }, 25);
          }
        }
      };
    };
}];

},{"./controllers/app.controllers.js":6,"./directives/app.directives.js":50,"./filters/app.filters.js":57,"./helpers/app.helpers.js":58,"./services/app.services.js":71,"./templates/app.templates.js":72,"ag-grid":162}],57:[function(require,module,exports){
angular.module('app.filters', [])
   // Used to filter editable form fields in Charts section
    // Angular replacement for backbone version of user_admin
    .filter('keyExists', ['$filter', function ($filter) {
        return function (items, keys) {
            if (!items) return false;
            var result = {};
            angular.forEach(items, function (value, key) {
                if (keys.indexOf(key) != -1)
                    result[key] = value;
            });
            return result;
        };
    }])

    // ng-bind-html
    .filter('to_trusted', ['$sce', function($sce){
        return function(text) {
            return $sce.trustAsHtml(text);
        };
    }])
},{}],58:[function(require,module,exports){
require('./datepicker.decorator.js');
angular.module('app.helpers', []);

},{"./datepicker.decorator.js":59}],59:[function(require,module,exports){
angular.module('ui.bootstrap.datepicker')
    .config(['$provide', function($provide) {
        $provide.decorator('uibDatepickerDirective', ['$delegate', function($delegate) {
            var directive = $delegate[0];
            var link = directive.link;

            directive.compile = function() {
                return function(scope, element, attrs, ctrls) {
                    link.apply(this, arguments);

                    var datepickerCtrl = ctrls[0];
                    var ngModelCtrl = ctrls[1];

                    if (ngModelCtrl) {
                        // Listen for 'refreshDatepickers' event...
                        scope.$on('refreshDatepickers', function refreshView() {
                            datepickerCtrl.refreshView();
                        });
                    }
                }
            };
            return $delegate;
        }]);
    }]);
},{}],60:[function(require,module,exports){
angular.module('app.alerts', [])
.factory('AlertService', ['$q', '$http', 'Upload', function($q, $http, Upload) {
	var get, getByID, getByDateRange, setStatus;

	//obsolete
	// var sampleData = [
	// 	{ id: 1, alerttype: 1, alertstatus: 2, title: 'Alert title 1', saving_potential: 888, energy_saved: 888, description: 'Alert indicators, descriptions or both', created: moment().subtract(2, 'week').valueOf()},
	//        { id: 2, alerttype: 2, alertstatus: 1, title: 'Alert title 2', saving_potential: 888, energy_saved: 888, description: 'Alert indicators, descriptions or both', created: moment().subtract(4, 'day').valueOf()},
 	//        { id: 3, alerttype: 2, alertstatus: 1, title: 'Alert title 2', saving_potential: 888, energy_saved: 888, description: 'Alert indicators, descriptions or both', created: moment().subtract(3, 'day').valueOf()},
 	//        { id: 4, alerttype: 1, alertstatus: 0, title: 'Alert title 3', saving_potential: 888, energy_saved: 888, description: 'Alert indicators, descriptions or both', created: moment().subtract(2, 'day').valueOf()},
	// 	{ id: 5, alerttype: 1, alertstatus: 0, title: 'Alert title 4', saving_potential: 888, energy_saved: 888, description: 'Alert indicators, descriptions or both', created: moment().subtract(1, 'day').valueOf()}
	// ];

	var buffer = [];

	get = function(buildingID, refresh) {
		var deferred = $q.defer();

		if(buffer.length > 0 && !refresh)
			deferred.resolve(buffer);
		else
		{
			$http({
			    url:"api/alert_log/",
			    data: {"energyunit": buildingID},
			    method: 'GET'
			}).then(function(result){
				console.log('GET api/alert_log/'+buildingID, result);
				buffer = result.data.objects;
				// var _tmp = 0;
				// buffer = _.map(buffer, function(item){
				// 	return angular.extend(item, {alerttype: 1, alertstatus: _tmp = (_tmp == 0 ? 1 : 0) });
				// })

				deferred.resolve(buffer);		    
			},function(err){
			   deferred.resolve([]);  
			})
		}

		return deferred.promise;
	};

	getByID = function(buildingID, alertID){
		var deferred = $q.defer();

		get(buildingID).then(function(data){
			var result = _.find(data, function(match){
				return match.id == alertID;
			});

			deferred.resolve(result);
		})

		return deferred.promise;
	}
	

	getByDateRange = function(buildingID, start, end, refresh){
		var deferred = $q.defer();

		get(buildingID, refresh).then(function(data){
			var result = _.filter(data, function(match){
				return moment(match.alert_time) >= start && moment(match.alert_time) < end;
			});

			deferred.resolve(result);
		})

		return deferred.promise;
	}

	setStatus = function(buildingID, alertID, newStatus){
		
		var deferred=$q.defer();

		// AlertStatus: 1 == unread, 2 == ignored, 3 == dismissed

    	$http({
		    url:'api/alert_log/' + alertID + '/',
		    data: {alertstatus: 'api/alertstatus/' + newStatus + '/', id: alertID },
		    method: 'PUT'
		}).then(function(result){
			console.log('PUT api/alert_log/'+alertID, result);
			deferred.resolve(buffer);		    
		},function(err){
			console.log('ERROR: PUT api/alert_log/'+buildingID, err);
		   	deferred.resolve([]);  
		})

        return deferred.promise;
	};

	return {
		get: get,
		setStatus: setStatus,
		getByID: getByID,
		getByDateRange: getByDateRange
	};
}])
},{}],61:[function(require,module,exports){
angular.module('app.account', ['angular-jwt'])
.factory('CompanyService', ['$q', '$http', 'Upload', function($q, $http, Upload) {
	var get, save, uploadLogo;
	get = function() {
		var deferred = $q.defer();
		$http.get('api/company').then(
			function(success){
				deferred.resolve(success.data.objects[0])
			},
			function(error){
				deferred.reject(error)	
			}
		);
		return deferred.promise;
	};
	
	save = function(id, props){
		var deferred = $q.defer();
		$http.put('api/company/' + id + '/', props).then(function(result){
        	deferred.resolve(result);
        })
        return deferred.promise;
	};

	uploadLogo = function(id, file){
		var deferred = $q.defer();
		Upload.upload({
                url: 'api/company/' + id + '/',
                data: { logo: file },
                method: 'PUT'
            }).then(function (resp) {
            	deferred.resolve(resp.config.data.file.name)
            }, function (resp) {
                deferred.reject(resp.status);
            }, function (evt) {
                deferred.notify(parseInt(100.0 * evt.loaded / evt.total));
            });
		return deferred.promise;
	};

	return {
		get: get,
		save: save,
		uploadLogo: uploadLogo
	};
}])
.factory('UserService', ['$q', '$http', 'Upload', function($q, $http, Upload) {
	var get, save, uploadAvatar;

	get = function() {
		var deferred = $q.defer();

		$http.get('api/user').then(
			function(success){
				if(success.data.objects.length)
				{
					deferred.resolve(success.data.objects[0])
				}
				else
				{
					deferred.reject('No data')	
				}
			},
			function(error){
				console.log('error ' , error);
				deferred.reject(error)	
			}
		);

		return deferred.promise;
	}

	save = function(id, props){
		var deferred = $q.defer();
		$http.put('api/user/' + id + '/', props).then(function(result){
        	deferred.resolve(result);
        })
        return deferred.promise;
	}

	uploadAvatar = function(id, file){
		var deferred = $q.defer();
		Upload.upload({
                url: 'api/client_settings/' + id + '/',
                data: { avatar: file },
                method: 'PUT'
            }).then(function (result) {
            	deferred.resolve(result)
            }, function (resp) {
                deferred.reject(resp.status);
            }, function (evt) {
                deferred.notify(parseInt(100.0 * evt.loaded / evt.total));
            });
		return deferred.promise;
	}

	return {
		get: get,
		save: save,
		uploadAvatar: uploadAvatar
	};
}])
.factory('accountService', ['$rootScope', '$http', '$q', 'urlService', '$injector', function($rootScope, $http, $q, urlService, $injector){
	
	//methods
	var get, reload, reset;
	
	//properties
	var account; 

	//get account profile
	get = function(){
		var deferred = $q.defer();

		if(account) {

			deferred.resolve(account);

		}	else	{
			
			reload().then(
				function(success){
					deferred.resolve(success);
				},
				function(error){
					deferred.reject(error);
				}
			);

		}

		
		return deferred.promise;
	}, // -- get

	//reload account profile
	reload = function(){
		
		var deferred = $q.defer();

		$http.get('api/client_settings/').then(
			function(success){

				// get avatar and logo urls
				var avatarUrl = success.data.objects.length && (success.data.objects[0].avatar ? success.data.objects[0].avatar : null);
				var companyLogoUrl = success.data.objects.length && (success.data.objects[0].company_logo ? success.data.objects[0].company_logo : null);

				// check for availability and substitute with defaults otherwise
				var avatarPromise = urlService.exists(avatarUrl, '/static/image/default.avatar.jpg');
				var logoPromise = urlService.exists(companyLogoUrl, '/static/image/default.logo.jpg');
				
				var userProfile = $injector.get('UserService').get();
				var companyProfile = $injector.get('CompanyService').get();

				$q.all([avatarPromise, logoPromise, userProfile, companyProfile]).then(
					function(result){
						if(success.data.objects.length)
						{
							//combine account profile with avatar
							success.data.objects[0].avatar = result[0];
							success.data.objects[0].company_logo = result[1];
							
							success.data.objects[0].userProfile = result[2];
							success.data.objects[0].companyProfile = result[3];

							//cache account
							account = angular.copy(success.data.objects[0]);

							$rootScope.account = account;

							deferred.resolve(success.data.objects[0]);
						}
						else
						{
							deferred.resolve({ avatar: resultUrl[0], company_logo: resultUrl[1] });
						}
					},
					function(err){
						deferred.reject(err);
					}
				);

			},
			function(failure){
				deferred.reject(failure);
			}
		);

		return deferred.promise;
	}

	//clear account profile on logout
	reset = function(){
		account = {};
	}

	return {
		get: get,
		reload: reload,
		reset: reset,
		account: function(){
			return account;
		}
	}
}])
.factory('authService', ['$q', '$rootScope', 'accountService', 'localStorageService', 'jwtHelper', '$http', 'accountService', function ($q, $rootScope, accountService, localStorageService, jwtHelper, $http, accountService) {

        var _profile, login, logout, refresh, isAuthorized, isUserInRoles, getProfile;

        isAuthorized = function(){
        	var token = localStorageService.get('token');
        	return token && !jwtHelper.isTokenExpired(token);
        }

		login = function(formData){
			var deferred = $q.defer();

			//remove token if exists before authorization
	    	if(localStorageService.get('token')){
            	localStorageService.remove('token');
	    	}

	    	//authorize
			$http.post('api-token-auth/',formData).then(
				function(success){

					$rootScope.$broadcast('auth:success');

	                //save auth token
					var token = (success.data||{}).token;
	                localStorageService.set('token', token);

	                //reload user profile
	                accountService.reload();

					deferred.resolve(token);
				},
				function(err){
					deferred.reject(err);
				})
			return deferred.promise;
		}
        
        logout = function(){
			localStorageService.remove('token');
        	authorized = false;
        	accountService.reset();
        }
        
        isUserInRoles = function (roles) {
            var deferred = $q.defer();
            deferred.resolve(true);
            return deferred.promise;
        };
        
        refresh = function(){
        	//TODO: Refresh token here

        	//Reload profile
        	accountService.reload();
        }

        return {
        	refresh: refresh,
            login: login,
            logout: logout,
            isAuthorized: isAuthorized,
            isUserInRoles: isUserInRoles,
            profile: function(){
            	return accountService.account;
            }
        };
}])
.factory('$requestLog', [function(){

	var requests = [];

	return {
		add: function(request){
			if(request.url.indexOf('---') >= 0)
				requests = [];
			else
				requests.push(request);
		},
		list: function(){
			return requests;
		}
	}

}])
.config(['$httpProvider', function($httpProvider) {
	
	$httpProvider.interceptors.push(['$q', '$location', '$rootScope', 'localStorageService', '$requestLog','$timeout', function($q, $location, $rootScope,localStorageService, $requestLog, $timeout) {
        return {
            'request': function (config) {
                var token = localStorageService.get('token');
                config.headers = config.headers || {};
                if (token) {
                    config.headers.Authorization = 'Bearer ' + token;
                }
                config.headers["Content-Type"]="application/json"
                return config;
            },
            'response':function(response){
                // refresh token
                storedToken=localStorageService.get('token');
                receivedToken=response.headers('http_authorization');
                if(receivedToken){
                    receivedToken=receivedToken.split(" ")[1];
                    if (receivedToken&&storedToken !== receivedToken){
                        localStorageService.set('token',receivedToken);
                    }
                }
             //    $timeout(function(){
             //    	if(response.config.url.indexOf('api') > -1)
             //    		$requestLog.add({ url: response.config.url, method: response.config.method, status: response.status, data: response.data }); 
            	// })
                return response
            },
            'responseError': function(response) {
                if(response.status === 401 || response.status === 403) {
                    localStorageService.remove('token')
                    $location.path('/login/');
                }
                return $q.reject(response);
            }
        };
    }]);

}])
.run(['$rootScope', 'authService', 'localStorageService', 'jwtHelper', 'accountService', '$injector', function($rootScope, authService, localStorageService, jwtHelper, accountService, $injector){

	$rootScope.$on('$stateChangeStart', function (evt, toState, toParams, fromState, fromParams) {

            // Prevent unauthorized access
            if(!toState.skipAuthorization){
                
                // Is authorized
                if (!authService.isAuthorized()){
                	
                	// save destination to redirect after authorization 
                	$rootScope.returnState = toState;
                	$rootScope.returnParams = toParams;
                    
                    // redirect to login
                    return $rootScope.$state.go('root.login');

                }

                // Ensure user profile loaded
	            if(!$rootScope.user)
	            	authService.refresh();

            }

    });



	var unbindAuthSuccess = $rootScope.$on('auth:success', function(){
		
		var UserService = $injector.get("UserService");
		UserService.get().then(function(user){
			$rootScope.user = user;
		});

		var CompanyService = $injector.get("CompanyService");
		CompanyService.get().then(function(profile){
			$rootScope.user = profile;
		})

		accountService.get().then(function(profile){
			//$rootScope.user = profile;
		})
	});


    $rootScope.logout=function(){
        authService.logout();
        $rootScope.$state.go('root.login');
    }

    $rootScope.$on('$destroy', function(){
		unbindAuthSuccess();
    });

}]);

// taken from angular-jwt package 
// https://github.com/auth0/angular-jwt

angular.module('angular-jwt', [])
  .service('jwtHelper', function() {

    this.urlBase64Decode = function(str) {
		var output = str.replace(/-/g, '+').replace(/_/g, '/');
			switch (output.length % 4) {
			case 0: { break; }
			case 2: { output += '=='; break; }
			case 3: { output += '='; break; }
			default: {
			  throw 'Illegal base64url string!';
			}
		}
		return decodeURIComponent(escape(window.atob(output))); //polifyll https://github.com/davidchambers/Base64.js
    }


    this.decodeToken = function(token) {
      var parts = token.split('.');

      if (parts.length !== 3) {
        throw new Error('JWT must have 3 parts');
      }

      var decoded = this.urlBase64Decode(parts[1]);
      if (!decoded) {
        throw new Error('Cannot decode the token');
      }

      return JSON.parse(decoded);
    }

    this.getTokenExpirationDate = function(token) {
      var decoded;
      decoded = this.decodeToken(token);

      if(typeof decoded.exp === "undefined") {
        return null;
      }

      var d = new Date(0); // The 0 here is the key, which sets the date to the epoch
      d.setUTCSeconds(decoded.exp);

      return d;
    };

    this.isTokenExpired = function(token, offsetSeconds) {
      var d = this.getTokenExpirationDate(token);
      offsetSeconds = offsetSeconds || 0;
      if (d === null) {
        return false;
      }

      // Token expired?
      return !(d.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));
    };
});
// .factory('authorization', ['$rootScope', '$state', 'AuthService',
//     function ($rootScope, $state, AuthService) {
//         return {
//             authorize: function () {
//                 return;
//                 var identity = AuthService.identity();
            
//                 if ($rootScope.toState.data && $rootScope.toState.data.roles && $rootScope.toState.data.roles.length > 0) {
                
//                     var roles = angular.copy($rootScope.toState.data.roles);
//                     AuthService.isUserInRoles(roles).then(function (hasRoles) {
//                         if (identity) {
//                             if (hasRoles === false) {
//                                 $state.go('root.accessdenied');
//                             }
//                         } else {
//                             // track state
//                             $rootScope.returnToState = $rootScope.toState;
//                             $rootScope.returnToStateParams = $rootScope.toStateParams;
                        
//                             // redirect to signin
//                             $state.go('root.login');
//                         }

//                     });

//                 }

//             }
//         };
//     }])
},{}],62:[function(require,module,exports){
// TODO: RESERVED: EXTERNAL API CALLS FUNCTIONALITY
angular.module('app.config', [])
.factory('configService', ['$q', '$rootScope', '$http', function ($q, $rootScope, $http) {

	var load, settings = {};

	load = function(){
		return $http.get('static/js/config.json');
	}

	var toReturn=load().then(
		function(res){
			return res.data
		},
		function(){

		}
	);

	return {
		settings: toReturn
	}
	

}])
// .factory('rewriteService', ['$q', 'platformService', '$injector', function($q, platformService, $injector){

// 	var rewriteInjector = {
// 		request: function(config) {
// 			if(platformService.isMobile() && config.url){

// 				//var configService = $injector.get('configService');

// 				//Adjust request url occording to config.json 
// 				// if(config.url.indexOf('api/') > -1 || config.url.indexOf('api-token-auth') > -1){
// 				// 	config.url = '/' +
// 				// 	 	(config.url.indexOf('/') == 0 ? config.url.substring(1) : config.url);
// 				// 	// config.url = 
// 				// 	// 	'http://' + 
// 				// 	// 	(configService.settings().API_IP ? configService.settings().API_IP + ':' + configService.settings().API_PORT : 'localhost:8000') + '/'  + 
// 				// 	// 	(config.url.indexOf('/') == 0 ? config.url.substring(1) : config.url);
// 				// }

// 				// Disable authorization
// 				// if(config.url.indexOf('api/getSeries/') > -1){
// 				// 	config.skipAuthorization = true;
// 				// }
// 			}
//             return config;
//         },
//         response:function(response){
//         	return response;
// 		},
// 		responseError: function(response){
//             return $q.reject(response);
// 		}
// 	};

// 	return rewriteInjector;

// }])
// .config(['$httpProvider', function($httpProvider) {  
//     $httpProvider.interceptors.push('rewriteService');
// }]);
},{}],63:[function(require,module,exports){
angular.module('app.csv2json', [])
.factory('csv2json', ['$q', '$rootScope', '$http', function ($q, $rootScope, $http) {

	function toArray(strData, strDelimiter) {
	    // Check to see if the delimiter is defined. If not,
	    // then default to comma.
	    strDelimiter = (strDelimiter || ",");
	    // Create a regular expression to parse the CSV values.
	    var objPattern = new RegExp((
	    // Delimiters.
	    "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +
	    // Quoted fields.
	    "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
	    // Standard fields.
	    "([^\"\\" + strDelimiter + "\\r\\n]*))"), "gi");
	    // Create an array to hold our data. Give the array
	    // a default empty first row.
	    var arrData = [[]];
	    // Create an array to hold our individual pattern
	    // matching groups.
	    var arrMatches = null;
	    // Keep looping over the regular expression matches
	    // until we can no longer find a match.
	    while (arrMatches = objPattern.exec(strData)) {
	        // Get the delimiter that was found.
	        var strMatchedDelimiter = arrMatches[1];
	        // Check to see if the given delimiter has a length
	        // (is not the start of string) and if it matches
	        // field delimiter. If id does not, then we know
	        // that this delimiter is a row delimiter.
	        if (strMatchedDelimiter.length && (strMatchedDelimiter != strDelimiter)) {
	            // Since we have reached a new row of data,
	            // add an empty row to our data array.
	            arrData.push([]);
	        }
	        // Now that we have our delimiter out of the way,
	        // let's check to see which kind of value we
	        // captured (quoted or unquoted).
	        if (arrMatches[2]) {
	            // We found a quoted value. When we capture
	            // this value, unescape any double quotes.
	            var strMatchedValue = arrMatches[2].replace(
	            new RegExp("\"\"", "g"), "\"");
	        } else {
	            // We found a non-quoted value.
	            var strMatchedValue = arrMatches[3];
	        }
	        // Now that we have our value string, let's add
	        // it to the data array.
	        arrData[arrData.length - 1].push(strMatchedValue);
	    }
	    // Return the parsed data.
	    return (arrData);
	}

	function toJson(csv) {
	    var array = toArray(csv);
	    var objArray = [];
	    for (var i = 1; i < array.length; i++) {
	        objArray[i - 1] = {};
	        for (var k = 0; k < array[0].length && k < array[i].length; k++) {
	            var key = array[0][k];
	            objArray[i - 1][key] = array[i][k]
	        }
	    }
	    console.log(objArray);
	    return objArray;
	}

	function toJsonString(csv){
		var objJson = toJson(csv);
	    var json = JSON.stringify(objJson);
	    json = json.replace(/},/g, "},\r\n");
	    return json;
	}

	return {
		toJson: toJson,
		toJsonString: toJsonString
	}
}]);
},{}],64:[function(require,module,exports){
angular.module('app.error', [])
.factory('ErrorHandler', ['$q', '$http', 'Upload', 'toastr', 'toastrConfig', function($q, $http, Upload, toastr, toastrConfig) {
	var list, notify;


    toastrConfig.positionClass = 'toast-bottom-full-width pa w100p';
    toastrConfig.maxOpened = 1; 
    toastrConfig.autoDismiss = true;
    toastrConfig.toastClass = 'custom-toast';
    toastrConfig.target = '.map-marker-details-container'; //TODO: change this


	list = function() {

	};

	notify = function(title, description) {

		toastr.info(title, description, { 
            extraData: marker.id,
            closeButton: true,
            extendedTimeOut: 60000,
            timeOut: 60000,
            onTap: function(toast){
                $rootScope.$state.go('root.reports.summary', { id: toast.extraData });
            }
        });

	};

	
	return {
		list: list,
		notify: notify
	};
}])
},{}],65:[function(require,module,exports){
angular.module('app.export', [])
.factory('Exporter', ['$q', '$rootScope', 'EnergyUnitFactory', '$compile', function ($q, $rootScope, EnergyUnitFactory, $compile) {

	return {
		toPDF: function(filePrefix){
			$rootScope.$broadcast('export.pdf', {filePrefix: filePrefix});
		}
	}

}])
.directive('exportPdf', ['$rootScope', '$parse', '$timeout', '$window', '$compile', 'html2pdf', function ($rootScope, $parse, $timeout, $window, $compile, html2pdf) {
    return {
        priority: 1001,
        link: function ($scope, element, attrs, ctrl) {
    		if($('#export-container').length){
    			console.log('EXPORTPDF Directive: Element with id "export-container" already defined.');
    			return;
    		}

			var config = $parse(attrs.exportPdf)($scope);
			
			element.attr('id', 'export-container');

    		var unbindExportListener = $rootScope.$on('export.pdf', function(params){

                html2pdf.export($(element), config.filePrefix || 'export');

    		})

    		$scope.$on('$destroy', function(){
    			unbindExportListener();
    		})

        }
    }
}])
.run(['$rootScope', 'Exporter', function($rootScope, Exporter){

	$rootScope.getExporter = function(){
		return Exporter;
	}

}]);
},{}],66:[function(require,module,exports){
angular.module('app.geo', [])
.factory('geoService', ['$http', '$q', 'localStorageService', function($http, $q, localStorageService){
	var ak = 'KRNQDv3desnEOULRaeOsmyvI', // unify with directives/baidumap.js 
		toGPS;


	var getLocationFromCache = function(unitId){
		var cache = localStorageService.get('geo');
		
		if(!cache) return null;

		var location = _.find(cache,function(d){
        	return unitId == d.unitId;
        });

        return location;
	}

	var addLocationToCache = function(location){
		var cache = localStorageService.get('geo');

		if(!cache) cache = [];

		var locationCached = getLocationFromCache(location.unitId);

        if(!locationCached){
        	cache.push(location);
			localStorageService.set('geo', cache);        	
        }
	}

	toGPS = function(unitId){
		var deferred = $q.defer();
		
		if(!unitId) {
			
			deferred.reject("Unit id cannot be empty.");

		} else {

			// Check local storage for address 
			var location = getLocationFromCache(unitId)
			if(!location){

				// TODO: REMOVE IT ONE GEOCODDER WORKS
				deferred.reject();
				return deferred.promise;



				var url =	'api/geocoder/' + 
							'?eu=' + unitId + 
							'&ak=' + ak;

				$http.get(url).then(function(success){
					
					// Add address to location
					location = success.data;
					location.unitId= unitId;
					
					// Save location into local storage
					addLocationToCache(location);
					
					// resolve promise
					deferred.resolve(location);

				},function(err){
					deferred.reject(err);
				});
			}
			else
			{
				deferred.resolve(location);
			}

		}
		return deferred.promise;
	}

    return {
    	toGPS: toGPS
    };
}])
},{}],67:[function(require,module,exports){
var jsPDF = require('../external/jsPDF/jspdf'); // v1.1.135 customized. Latest npm v1.0.272 broken without RequireJS

angular.module('app.html2pdf', [])
.service('html2pdf', function() {

	this.export = function(elem, filePrefix){

	   html2canvas(elem, {
	        onrendered: function(canvas) {
	            var namefile = prompt("Save as...", filePrefix + "." + moment().format("YYYY-MM-DD") + ".pdf");
	            if(!namefile.endswith)

	            canvas.toBlob(function(blob){

	                var urlCreator = window.URL || window.webkitURL;
	                var imageUrl = urlCreator.createObjectURL(blob);
	                var img = new Image();
	                img.src = imageUrl;
	                img.onload = function(){
	                    var pdf = new jsPDF('l','px',[img.height, img.width]);
	                    pdf.addImage(img, 0, 0, img.width, img.height);
	                    pdf.save(namefile);
	                };
	            });
	        }
	    });

	}

	return this;
});
},{"../external/jsPDF/jspdf":55}],68:[function(require,module,exports){
angular.module('app.io', [])
.factory('urlService', ['$http', '$q', function($http, $q){
	var exists;

	exists = function(url, fallbackUrl){
		var deferred = $q.defer();
		if(!url) return $q.resolve(fallbackUrl);
		if(url){
			$http.get(url).then(
				function(success){
					deferred.resolve(url);
				},
				function(failure){
					deferred.resolve(fallbackUrl);
				}
			)
		}
		else
		{
			deferred.resolve(fallbackUrl);
		}

		
		return deferred.promise;
	}

	return {
		exists: exists
	}

}])
.run(['$rootScope', '$timeout', function($rootScope, $timeout){
		
		/***********************************************
         *
         * Global busy status using cfpLoadingBar http interceptor
         *
         ***********************************************/

        $rootScope.busyCount = 0;
        $rootScope.isBusy = false;

        var loadingEvent = $rootScope.$on('cfpLoadingBar:loading', function (opts) {
            if ($rootScope.busyCount < 0) $rootScope.busyCount = 0;
            $rootScope.busyCount++;
            $rootScope.isBusy = true;
        });

        var loadedEvent = $rootScope.$on('cfpLoadingBar:loaded', function (opts) {
            $rootScope.busyTimeout = $timeout(function () {
                $rootScope.busyCount--;
                if ($rootScope.busyCount <= 0) {
                    $rootScope.isBusy = false;
                }
            }, 1000);
        });

}])
},{}],69:[function(require,module,exports){
angular.module('app.nav', [])
	.factory('navDelegateService', ['$q', '$http', '$ionicHistory', '$templateCache', 
		function($q, $http, $ionicHistory, $templateCache) {
			var _data = [];
			var _current = {};

			return {
				get: function() {
					return _current;
				},
				load: function(url, ctrl){
					_current = {url: url, ctrl: ctrl};
				}
			}
		}
	])
	.provider('navDelegate', [function(){
		
		var _current = {};

	    this.$get = function() {
	        return {
			        	current: {
				            url: 'static/views/nav.html',
				            ctrl: 'navCtrl'
			        	}
	        		}
	    };


	}])
	.run(['$rootScope', '$templateCache',function($rootScope, $templateCache){

		$rootScope.navDelegate = function(){
			return navDelegateProvider;
		}

	}]);


},{}],70:[function(require,module,exports){
angular.module('app.platform', [])
.factory('platformService', ['$q', function($q){

	var isMobile;

	isMobile = function(){

        var isWebView = ionic.Platform.isWebView();
        var isIPad = ionic.Platform.isIPad();
        var isIOS = ionic.Platform.isIOS();
        var isAndroid = ionic.Platform.isAndroid();
        var isWindowsPhone = ionic.Platform.isWindowsPhone();

        // Cordova runs app as file system
		if(document.URL.indexOf( 'http://' ) === -1 && document.URL.indexOf( 'https://' ) === -1)
			return true;

		// Ionic platform check
        if(isIPad || isIOS || isAndroid || isWindowsPhone){
        	return true;
        }

        //assume everything else are desktops
		var deviceInformation = ionic.Platform.device();
        var currentPlatform = ionic.Platform.platform();
        var currentPlatformVersion = ionic.Platform.version();

        return false;
	};

	return {
		isMobile: isMobile
	};

}])
.provider('platform', [function(){

	var isMobilePlatform = true;

    this.$get = function() {
        return {
            isMobile: function() {
				return isMobilePlatform;
            }
        }
    };

    this.isMobile = function(){
		return isMobilePlatform;
    	return document.URL.indexOf( 'http://' ) === -1 && document.URL.indexOf( 'https://' ) === -1;
    }

}])
.run(['$rootScope', '$ionicPlatform', '$cordovaStatusbar', '$ionicHistory', 'platform', 'platformService',
	function($rootScope, $ionicPlatform, $cordovaStatusbar, $ionicHistory, platformProvider, platformService){
	
		//alert(platformService.isMobile());

		$rootScope.platform = function(){
			return platformProvider;
		}

		$ionicPlatform.ready(function() {
	        // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
	        // for form inputs)
	        if (window.cordova && window.cordova.plugins.Keyboard) {
	            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
	            cordova.plugins.Keyboard.disableScroll(true);
	            //alert('cordova');
	        }

	        if (window.StatusBar) {
	            $cordovaStatusbar.overlaysWebView(false);
	            $cordovaStatusbar.styleHex('#f50'); 
	        }

	  //       setTimeout(function() {
	  //       	alert(window.StatusBar);
			//   if (window.StatusBar) {
			//     StatusBar.styleBlackTranslucent();
			//     StatusBar.backgroundColorByName('black');
			//   }
			// }, 3000); 

	    });

	    $rootScope.onBackClicked = function(){
	        console.log('onBackClicked');
	        if($ionicHistory.backView())
	            $ionicHistory.goBack();
	        else{
	            $ionicHistory.clearHistory();
	            $rootScope.$state.go('root.home');
	        }
	    }

}])
.directive('element', ['$rootScope', '$injector', '$compile', '$parse', '$injector', function ($rootScope, dialogService, $compile, $parse, $injector) {
        return {
            restrict: "EA",
            priority: 1000,
        	terminal: true,
        	replace: false,
            compile: function compile(element, attrs) {
            	var props = $parse(attrs.element)($rootScope);
            	if(!props || !props.render || !props.name)
            		return;

				element.attr(props.name, '');
				element.removeAttr("element");
				return {
			        pre: function preLink(scope, iElement, iAttrs, controller) {  },
			        post: function postLink(scope, iElement, iAttrs, controller) {  
			            $compile(iElement)(scope);
					}
				};
            }
        };
}]);




// TODO: Integrate cache for offline usage

angular.module('ngHttpCache', [])
.provider('ngHttpCacheConfig', function() {

    this.urls = ['/api'];

    var _this = this;

    this.$get = function() {
        return {
            urls: _this.urls
        };
    };

})
.factory('httpCache', ['CacheFactory', function(CacheFactory){
	var httpCache;

	// Check to make sure the cache doesn't already exist
	if (!CacheFactory.get('httpCache')) {
		httpCache = CacheFactory('httpCache',{
		  storageMode: 'localStorage'
		});
	}
	else
	{
	}

    // var httpCache = $cacheFactory('httpCache');
    return httpCache;
}])
.factory('lbInterceptor', ['httpCache', 'ngHttpCacheConfig',function(httpCache, ngHttpCacheConfig){
    return {
        request: function(config){
            var shouldCache = ngHttpCacheConfig.urls.reduce(function(should, url){
                if(config.url.indexOf(url) > -1){
                    return true;
                }
                return should;
            }, false);

            if(shouldCache){
                config.cache = httpCache;
                // console.log(config.cache.get(config.url));
                // the cache will be stored in `httpCache.get(config.url)`
            }
            return config;
        }
    };
}])
.config(['$httpProvider', '$ionicConfigProvider', function($httpProvider, $ionicConfigProvider){
    $httpProvider.interceptors.push('lbInterceptor');

    $ionicConfigProvider.navBar.alignTitle('center');
}])





angular.module('httpCacheHelper', ['ngHttpCache'])
.config(['ngHttpCacheConfigProvider', function(ngHttpCacheConfigProvider){
    ngHttpCacheConfigProvider.urls = ['api'];
}]);








// angular.module('offlinecheck', [])
// .config(['offlineProvider', function (offlineProvider) {
//     offlineProvider.debug(true);
// }])
// .run(['$http', 'offline', 'CacheFactory', 'connectionStatus', function ($http, offline, CacheFactory, connectionStatus){

// 		offline.start($http);
// 		offline.stackCache = CacheFactory('stackCache',{
// 		  storageMode: 'localStorage'
// 		});

// 		// https://docs.angularjs.org/api/ng/service/$http#caching
// 		$http.defaults.cache = CacheFactory('httpCache', {
// 		  storageMode: 'localStorage'
// 		});

// 		// based on navigator.onLine
// 		connectionStatus.$on('online', function () {
// 		  console.log('We are now online');
// 		});

// 		connectionStatus.$on('offline', function () {
// 		  console.log('We are now offline');
// 		});

// }]);
},{}],71:[function(require,module,exports){
/********************************************************************
 * 
 * 
 *  App Services
 *  - Angular services are substitutable objects that are wired 
 *    together using dependency injection (DI). You can use services 
 *    to organize and share code across your app.
 *  
 *  There are 2 types of services
 *  1: Services 
 *     Instantiated new each time injected
 *     
 *  2: Factories
 *     Instantiated once and available throughout app lifetime 
 *     
*********************************************************************/
require('./app.csv2json')
require('./app.html2pdf')
require('./app.geo')
require('./app.account')
require('./app.io')
require('./app.platform')
require('./app.error')
require('./app.nav')
require('./app.export')
require('./app.config')
require('./api.alerts')

angular.module('app.services', ['app.csv2json', 'app.html2pdf', 'app.geo', 'app.account', 'app.io', 'app.platform', 'app.error', 'app.nav', 'app.export', 'app.config', 'app.alerts'])
.service('HelperService', [function() {
    var toPyTime, toJsTime;
    toPyTime = function(ts) {
        return moment(ts).unix();
    },
    toJsTime = function(ts) {
        return moment.unix(ts).valueOf();
    }
    return {
        toPyTime: toPyTime,
        toJsTime: toJsTime
    };
}])
.factory('DataSource', ['$q', '$rootScope', 'EnergyUnitFactory', function ($q, $rootScope, EnergyUnitFactory) {
    var EnergyUnits, EnergyUnitsOfType;
    var that = this;
    var _EnergyUnits = { meta: {}, objects: [] };
    var busy = false;
    var lastUpdated = moment();

    EnergyUnits = function(reload){
        if(!reload || _EnergyUnits.length > 0 || busy)
            return _EnergyUnits.objects;

        busy = true;
        EnergyUnitFactory.get().then(function(data){
            _EnergyUnits = data;
            busy = false;
        });

        return _EnergyUnits.objects;
    }

    var Units = function(reload){
        var deferred = $q.defer();

        if(!reload && _EnergyUnits.objects.length > 0 && !busy){
            //console.log('UNITS SOFT LOAD');
            deferred.resolve(_EnergyUnits.objects);
            return deferred.promise;
        }

        //console.log('UNITS HARD LOAD');

        busy = true;
        EnergyUnitFactory.get().then(function(data){
            _EnergyUnits = data;
            busy = false;
            deferred.resolve(_EnergyUnits.objects);
        });

        return deferred.promise;

    }

    var getUnitByID = function(id){
        var deferred = $q.defer();

        if(!id){
            console.log('getUnitByID: reference ID is undefined');
            deferred.resolve();
            return deferred.promise;
        }

        Units().then(
            function(units){
                var foundByID = _.find(units, function (unit) { return unit.id == id })
                deferred.resolve(foundByID);
            },
            function(){
                deferred.reject('ERROR: getUnitByID');
            }
        );
        return deferred.promise;
    }

    EnergyUnitsOfType = function(typeID){
        return EnergyUnits().objects.filter(function (building) {
            return building.type == typeID;
        });
    }


    var addUnit = function(unit){
        _EnergyUnits.objects.push(unit);
        console.log('_EnergyUnits.objects ' , _EnergyUnits.objects);
    }

    //TODO: Improve this
    //Watch for authorization to reload data
    $rootScope.$watch(function(){
            return $rootScope.isAuthorized();        
        }, 
        function(value){
            if(value)
                EnergyUnits(true);    
        }
    );

    // initial load
    if($rootScope.isAuthorized())
        EnergyUnits();

    return {
        EnergyUnits: EnergyUnits,
        _EnergyUnits: function() {
            return _EnergyUnits; 
        },
        changed: function(){
            var deferred = $q.defer();

            $rootScope.$watchCollection(
                function(){
                    return EnergyUnits();
                }, 
                function(newValue, oldValue){
                    if(!angular.equals(newValue, oldValue))
                        deferred.resolve(EnergyUnits());
                }
            );

            return deferred.promise;
        },
        Units: function(reload){
            return Units(reload);
        },
        getUnitByID: function(id){
            return getUnitByID(id);
        },
        addUnit: function(unit){
            return addUnit(unit);
        }
    }

}])
.factory('EnergyUnitFactory', ['$q', '$rootScope', '$http', function ($q, $rootScope, $http) {
    var get, getByType, getByTypes, getByID, update, getCategories, getType, create;

    // var unitCache = [];

    // var getFromCache = function(url){
    //     return _.find(unitCache, function (unit) { return unit.url === url })
    // };

    get = function (options) {
        var deferred = $q.defer();

        //build request url
        options=options||{};
        var url='api/energyunit/';
        if(options.id){
            url+=options.id+"/";
            delete options.id;
        }
        url+='?format=json&';

        // use cache to prevent overhead
        // var unit = getFromCache(url);
        // if(unitCache.length > 0 && unit){
        //     deferred.resolve(unit.data);
        //     return deferred.promise;
        // }

        // request server
        $http.get(url,{params: options}).then(function (result) {
            
            // cache results
            var data = result.data;
            // unitCache.push({ url: url, data: data});
            
            deferred.resolve(data);

        },function(err){
            deferred.reject(err);
        });

        return deferred.promise;
    };
    getCategories=function(){
        var deferred=$q.defer();
        $http.get('api/category/?format=json&').then(function(result){
            deferred.resolve(result.data);
        });
        return deferred.promise;
    };
    getType=function(){
        var deferred=$q.defer();
        $http.get('api/unittype/?format=json&').then(function(result){
            deferred.resolve(result.data);
        });
        return deferred.promise;
    };
    getByType = function(typeID) {
        var deferred = $q.defer();

        get().then(function(result) {
            var buildings = result.objects.filter(function (building) {
                return building.type == typeID;
            });

            deferred.resolve(buildings);
        });

        return deferred.promise;
    };

    getByTypes = function(types) {
        var deferred = $q.defer();

        get().then(function(result) {
            var buildings = result.objects.filter(function (building) {
                return types.indexOf(building.type) >= 0;
            });

            deferred.resolve(buildings);
        });

        return deferred.promise;
    };

    getByID = function (id,options) {
        var deferred = $q.defer();
        options=options||{};
        options.id=id;
        get(options).then(function (result) {
            // var buildings = result.objects.filter(function (building) {
            //     return building.id == id;
            // });

            deferred.resolve(result);
        });
        return deferred.promise;
    };
    getDetail=function(id,options){
        var deferred=$q.defer();
        getByID(id,options).then(function(building){
            if(!building) deferred.reject();
            var p;
            switch(building.type){
                case "Building":
                case 1: p=$http.get('api/buildingparam/?id='+building.buildingparam.id);break;
                case "Campus":
                case 2: p=$http.get('api/campusparam/?id='+building.campusparam.id);break;
                case "Meter":
                case 3: p=$http.get('api/meterparam/?id='+building.meterparam.id);break;
                default:
                    deferred.reject("no detail"); return;
            }
            p.then(function(result){
                (result.data.objects[0]||{}).super=building;;
                deferred.resolve(result.data);
            })
        });
        return deferred.promise;
    }
    update=function(unit,data,param,options){
        var deferred=$q.defer();
        var url='api/energyunit/'+unit.id+'/?format=json';
        var promise1=$http.put(url,data);
        var promise2=$q.defer();
        switch(unit.type){
            case 1:promise2=$http.put('api/buildingparam/'+unit.buildingparam.id+'/',param);break;
            case 2:promise2=$http.put('api/campusparam/'+unit.campusparam.id+'/',param);break;
            case 3:promise2=$http.put('api/meterparam/'+unit.meterparam.id+'/',param);break;
        }
        $q.all([promise1,promise2]).then(function(result){
            deferred.resolve(result.data);
        },function(err){
            console.log(err);
        });
        return deferred.promise;
    }
    create=function(data,options){
        var deferred=$q.defer();
        var url='api/energyunit/';
        var unit=_.clone(data);
        if(typeof(unit.type)=='number'){
            var type="Building";
            switch(unit.type){
                case 1: break;
                case 2: type="Campus";break;
                case 3: type="Meter";break;
            }
            unit.type="api/unittype/"+type+"/";
        }
        //data = {"parent": "api/energyunit/85/", "type": "api/unittype/Building/", "name": "A new test meter"}
        
        if(typeof(unit.parent)=='number'){
            unit.parent="api/energyunit/"+unit.parent+"/";
        }
        var promise1=$http.post(url,unit).then(function(result){
            deferred.resolve(result.data);
        },function(err){
           deferred.reject(err);
        });
        return deferred.promise;   
    }

    return {
        get: get,
        getByType: getByType,
        getByTypes: getByTypes,
        getByID: getByID,
        getDetail:getDetail,
        getCategories:getCategories,
        update:update,
        getType:getType,
        create:create
    };
}])
// .factory('BlogPostFactory',['$q','$rootScope','$http',function($q,$rootScope,$http){
//     var get;
// }])
.factory('MiscSelectionFactory',['$q','$http',function($q,$http){
    var get;
    get=function(options){
        var deferred=$q.defer();
        $http.get('api/'+options.name+"/").then(function(result){
            deferred.resolve(result.data);
        })
        return deferred.promise;
    }
    return {
        get:get
    }
}])
.factory('RecommendationFactory',['$q','$http',function($q,$http){
    var get, getByBuilding,getByDateRange, getDetail,getStatusLog;
    get = function (options) {
        var deferred = $q.defer();
        $http.get('api/recommendation/',{params:options.params}).then(function (result) {
            deferred.resolve(result.data);
        });
        return deferred.promise;
    };
    getByBuilding=function(building){
        var deferred=$q.defer();
        get({params:{energy_unit:building}}).then(function(result){
            var recommendations=result.objects
            deferred.resolve(recommendations);
        });
        return deferred.promise;
    };
    getByDateRange=function(building, start, end){
        var deferred=$q.defer();
        get({params:{energy_unit:building}}).then(function(result){
            var r = _.filter(result.objects, function(match){
                return moment(match.date_of_creation) >= start && moment(match.date_of_creation) < end;
            });
            deferred.resolve(r);
        });
        return deferred.promise;
    };
    getDetail=function(recommendationID){
        // get the max, min, money, co2 fields;
        return $q.resolve({ max1: 20000, max2: 20000, max3: 20000, current1: 10000, current2: 3000, current3: 9000 , money: 8310, co2: 4510});

    };
    getStatusLog=function(recommendationID){
        var deferred=$q.defer();
        $http.get('api/recommendation_status_log/?',{params :{recommendation:recommendationID}}).then(function(result){
            deferred.resolve(result.data);
        })
        return deferred.promise;
    }
    update=function(options){
        var deferred=$q.defer();
        // Current api is not implemented
        var reflink="/backend/"
        console.log(options.status);
        $http.put('api/recommendation/'+options.id+"/",{"status":"api/recommendation_status/"+options.status+"/",comment:options.comment, date_of_change: moment().valueOf() }).then(function (result) {
            deferred.resolve(result.data);
        });
        return deferred.promise;
    }
    return {
        get:get,
        getByBuilding:getByBuilding,
        update:update,
        getStatusLog:getStatusLog,
        getDetail:getDetail,
        getByDateRange: getByDateRange
    }
}])
.factory('UtilityService', ['$q', '$rootScope', '$http', function ($q, $rootScope, $http) {
    var timeRange, groupDataByTime, getAreaUnderCurve,getEnergyPrice,whichTimeRange,isSummer;


    timeRange = function(data,options){
        var start=options.starttime;
        var end=options.endtime;
        if(options.sharpTime){
            var t=new Date(options.starttime);
            start=new Date((t.getMonth()+1)+"/"+t.getDate()+"/"+t.getFullYear()).getTime();
            t=new Date(options.endtime);
            t.setDate(t.getDate()+1);
            end=new Date((t.getMonth()+1)+"/"+t.getDate()+"/"+t.getFullYear()).getTime();
        }
        if(!start||!end){
            return [];
        }
        var toReturn=_.filter(data,function(d){
            if(d[0]>=start&&d[0]<end) return true;
        });
        return toReturn;
    };

    getAreaUnderCurve = function(data,options){
        var sum=0;
        var toReturn={};
        options=options||{};
        // first filter out data error, 
        data=_.filter(data,function(d){
            if(d[1]==0) return false;
            return true;
        })
        for(var i=0;i<data.length-1;i++){
            if(options.weekdaysOnly){
                var d=new Date(data[i][0]);
                if(d.getDay()==6||d.getDay()==7) continue; // Skip these points
                d=new Date(data[i+1][0]);
                if(d.getDay()==6||d.getDay()==7) continue;
            }
            var h1=new Date(data[i+1][0]).getHours();
            var h2=new Date(data[i][0]).getHours();
            var s1=isSummer(data[i+1][0]);
            var s2=isSummer(data[i][0]);
            if(options.partitions){
                var r1=whichTimeRange(data[i+1][0],{s:s1})
                var r2=whichTimeRange(data[i][0],{s:s2})
                if(r1!=r2) continue;
                var u=(data[i+1][0]-data[i][0])/3600000
                if(!toReturn[r1]) toReturn[r1]=0;
                toReturn[r1]+=data[i][1]*u;
                // for(var j=0;j<options.partitions.length;j++){
                //     var section=options.partitions[j];
                //     if(section.start<section.end){
                //         if(h1<section.start||h1>section.end||h2<section.start||h2>section.end){
                //             continue;
                //         }
                //     }else{
                //         if((h1>section.end&&h1<section.start)||(h2>section.end&&h2<section.start)){
                //             continue;
                //         }
                //     }
                //     // Here means h1, h2 both in range.                     
                //     var u=(data[i+1][0]-data[i][0])/3600000;// make it in units of hour
                //     toReturn[j]=(toReturn[j]||0)+data[i][1]*u;
                // }
            } 
            var u=(data[i+1][0]-data[i][0])/3600000;// make it in units of hour
            sum+=data[i][1]*u; // This is like enumerate integration
        }
        if(options.partitions)return toReturn;
        return sum;
    };
    isSummer=function(time){
        var m=new Date(time).getMonth();
        if(m>=6&&m<=8) return true;
    }
    groupDataByTime = function(data,options){     
        var groupedData=_.groupBy(data,function(d){
            var date=moment(new Date(d[0]));
            date.utcOffset(480);
            var day="0"+date.date();
            var month="0"+(date.month()+1);
            var year = date.year();

            if(options.month){
                return year + "/" + month.slice(-2); // ex: 2015/11    
            }else if(options.hour==true){
                return year + "/" + month.slice(-2) + "/" + day.slice(-2) + ":" + date.hour(); // ex: 2015/11/11:18
            }else{
                return year + "/" + month.slice(-2) + "/" + day.slice(-2); // ex: 2015/11/11
            }
        });
        var groupedEnergy=[]
        for (key in groupedData){
            if(groupedData.hasOwnProperty(key)){
                var d=groupedData[key];
                if(d.length<2){
                    var energy=d[0][1];
                    groupedEnergy.push({time:key,total:energy});
                }else{
                    var energy=getAreaUnderCurve(d,{partitions:options.partitions});
                    groupedEnergy.push({time:key,total:energy});
                }
                
            }
        }
        // groupedData=_.map(groupedData,function(d){
        //     var da=new Date(d[0][0]);
        //     var interval=da.getHours()*60+da.getMinutes();
        //     da=new Date(d[d.length-1][0]);
        //     var interval2=24*60-da.getHours()*60-da.getMinutes();
        //     interval=Math.max(interval,interval2);
        //     var avg=60*24/d.length;
        //     return interval<avg*2
        // });
        
        // // Now for each group, calculate the power usage. 
        // var summary=_.map(groupedData,function(d){
        //     var sum=0;
        //     var date="";
        //     for(var i=0;i<d.length-1;i++){
        //         var x=(d[i+1][0]-d[i][0])/3600000; // x interval in (h);
        //         sum+=d[i][1]*x; // Like enumerate integration
        //         if(options.month){
        //             date= year+"/"+month.slice(-2);    
        //         }else if(options.day){
        //             date= year+"/"+month.slice(-2)+"/"+day.slice(-2);
        //         }
        //     }
        //     return {date:date,total:sum};
        // });
        return groupedEnergy;        
    }
    getEnergyPrice=function(){
        // This is done this way to prepare that future may using api to get it
        return $q.resolve({
            "s":{
                h:1.196,
                m:0.734,
                l:0.357
            },
            "ns":{
                h:1.231,
                m:0.769,
                l:0.292
            }
        })
    },
    whichTimeRange=function(time,options){
        var d=moment(time);
        //d.zone(-480); //<-- depricated
        d.utcOffset(-480);

        var hour = d.hours();
        if(hour<6||hour>=22) return "l";
        if(hour<11&&hour>=8) return "h";
        if(hour<21&&hour>=18) return "h";
        if(options.s==true){
            if(hour<15&&hour>=13) return "h";
        }
        return "m";
    }
    return {
        timeRange: timeRange,
        isSummer:isSummer,
        groupDataByTime: groupDataByTime,
        getAreaUnderCurve: getAreaUnderCurve,
        getEnergyPrice:getEnergyPrice
    };
}])
.factory('LanguageFactory',['$rootScope',function($rootScope){
    var filterFields;
    var hash={"description":"介绍",
    "type":"类型",
    "name":"名称",
    "value":"信息",
    "address":"地址",
    "buildingarea":"建筑范围",
    "yearbuild":"建筑年份",
    "manufacturer":"制造商",
    "modelname":"型号",
    "samplerate":"取点频率",
    "gpslocation":"GPS位置",
    "category":"类型",
    "employeenumber":"员工人数",
    "refrigerationunits":"冷却单位",
    "numberofrooms":"房间数量",
    "energysystemintro":"能耗系统介绍",
    "cookingfacility":"厨房"
    
    }
    function getTranslatedLabel(txt){
        return hash[txt.toLowerCase()]||txt;
    };
    function displayField(txt){
        //var fieldHash={"id":false,"buildingparam":false,"campus":false,"campusparam":false,"influxkey":false,"meterparam":false,"parent":false}
        var fieldHash={samplerate:true,"gpslocation":false,"category":true,"name":true,"type":false,"value":false,address:true,buildingarea:true,yearbuild:true,manufacturer:true,modelname:true,}
        return !!fieldHash[txt.toLowerCase()];
    }
    function getIcon(key) {
        //TODO: Find appropriate icons
        return 'icon-building';
    }
    filterFields=function(attr){
        var fields=[]
        for (var key in attr){
            if(attr.hasOwnProperty(key)&&key!='resource_uri'){
                if (displayField(key)) {
                    var i={ name: key, alias: getTranslatedLabel(key.toLowerCase()), value: attr[key], icon: getIcon(key) }
                    if (key=='buildingarea'){
                        i['value']+="平方米"
                    }
                    fields.push(i);
                    //fields[getTranslatedLabel(key.toLowerCase())]=attr[key];
                }
            }
        }
        return fields;
    }

    return {
        filterFields:filterFields,
        getTranslatedLabel:getTranslatedLabel
    }
}])

/***********************************************
* 
*   All Meters Service
*   /api/getAllMeters
* 
***********************************************/
.factory('AllMetersService', ['$q', '$rootScope', '$http', '$filter', 'UtilityService', 'seriesService','EnergyUnitFactory',function ($q, $rootScope, $http, $filter, UtilityService,seriesService,EnergyUnitFactory) {
    var load, calculate,partitionedEnergyUse,calculateBuildingEnergies;


    load = function (buildingID, start, end,options) {
        // var deferred = $q.defer();

        // $http({
        //     url: '/api/getAllMeters/',
        //     params: { serieName: buildingID, start: start, end: end },
        //     headers: { 'X-CSRF-Token': $("meta[name='csrf-param']").attr('content') }
        // }).then(function (result) {
        //     deferred.resolve(result.data);
        // });
        console.log('series service loading...');

    	var loadOption=_.extend({interval:"auto"},options);    
        // return deferred.promise;
        return seriesService.load(buildingID,start,end,loadOption);
    };

    calculateBuildingEnergies=function(buildings,start,end){

        var promises=_.map(buildings,function(building){
            var deferred=$q.defer();
            load(building.id,start.getTime(),end.getTime()).then(function(result){
                result=result[0]||{};
                var points = result.points || [];
                points = points.reverse();
                var energy=UtilityService.getAreaUnderCurve(points);
                deferred.resolve(energy);
            },function(err){
                deferred.reject(err);
            });
            return deferred.promise;
        });
            
        return $q.all(promises).then(function(energies){
            var data=[];
            for(var i=0;i<buildings.length;i++){
                data.push([buildings[i].name,energies[i]])
            
            }            
            return $q.resolve(data);
        })
    };

    calculate = function(building, options, cache) {
        var deferred = $q.defer(),
            loadData,
        options=options||{};
        var buildingarea=parseInt((building.buildingparam||{}).buildingarea)||1; 
        var meterStart=options.meterStart||parseInt((building.buildingparam||{}).billingCycleStart);
            var p;
            if(meterStart&&buildingarea){
                p=Promise.resolve([meterStart,buildingarea]);
            }else{
                p=EnergyUnitFactory.getDetail(building.id).then(function(bd){
                    bd=bd.objects[0]||{};
                    return Promise.resolve([parseInt(bd.billingCycleStart),parseInt(bd.buildingarea)]);
                });
            }
            p.then(function(buildingparam){
                billingCycle=buildingparam[0];
                buildingarea=buildingparam[1];
                billingCycle=billingCycle||1;
                buildingarea=buildingarea||1;
                var now = moment().valueOf();
                var now_moment=moment().utcOffset(480);
                yesterday = moment(now_moment).subtract(1, 'day').valueOf(),
                lastWeekStart = moment(now_moment).subtract(1, 'week').startOf('isoweek').valueOf(),
                lastYearSameMonthStart=now_moment.date()>billingCycle?moment(now_moment).subtract(1,'year').date(billingCycle).valueOf():moment(now_moment).subtract(1,'year').subtract(1,'month').date(billingCycle).valueOf();
                lastYearSameMonthToday=moment(now_moment).subtract(1, 'year').valueOf(),
                thisMonthStart = now_moment.date()>billingCycle?moment(now_moment).date(billingCycle).valueOf():moment(now_moment).subtract(1,'month').date(billingCycle).valueOf(),
                lastMonthToday = moment(now_moment).subtract(1, 'month').valueOf(),
                lastMonthStart = now_moment.date()>billingCycle?moment(now_moment).subtract(1,'month').date(billingCycle).valueOf():moment(now_moment).subtract(2,'month').date(billingCycle).valueOf(),

                loadData = cache ? $q.resolve(cache) : load(building.id, lastMonthStart, now);

                $q.all([loadData,load(building.id,lastYearSameMonthStart,lastYearSameMonthToday)]).then(
                    function (result) {
                        var lastYearData=result[1][0]||{};
                        var lastYearPoints=(lastYearData.points||[]).reverse();

                        result = result[0][0] || {};
                        var points = result.points || [];
                        points = points.reverse();

                        if (points.length < 1) {
                            return deferred.resolve({});
                        }

                        // Now get the subset of data
                        var lastMonthData = UtilityService.timeRange(points, { starttime: lastMonthStart, endtime: thisMonthStart, sharpTime: true });
                        var lastMonthEnergy = UtilityService.getAreaUnderCurve(lastMonthData);
                        var lastMonthPeak = UtilityService.getAreaUnderCurve(lastMonthData, { partitions: true})['h'];

                        // Last Month Same period compare to this month
                        var lastMonthCorespondData = UtilityService.timeRange(lastYearPoints, { starttime: lastYearSameMonthStart, endtime: lastYearSameMonthToday, sharpTime: true });
                        var lastMonthSamePeriod = UtilityService.getAreaUnderCurve(lastMonthCorespondData);
                        var thisMonthSamePeriod = UtilityService.getAreaUnderCurve(UtilityService.timeRange(points, { starttime: thisMonthStart, endtime: now }));

                        // Get last week, 5 business days energy
                        var lastWeekData = UtilityService.timeRange(points, { starttime: lastWeekStart, endtime: now, sharpTime: true });
                        var lastWeekEnergy = UtilityService.getAreaUnderCurve(lastWeekData, { weekdaysOnly: true });
                        var lastWeekPeak = UtilityService.getAreaUnderCurve(lastWeekData, { weekdaysOnly: true, partitions: true })['h'];

                        // Get Yesterday energy
                        var yesterdayData = UtilityService.timeRange(lastWeekData, { starttime: yesterday, endtime: yesterday, sharpTime: true })
                        var yesterdayEnergy = UtilityService.getAreaUnderCurve(yesterdayData);
                        var yesterdayPeak = UtilityService.getAreaUnderCurve(yesterdayData, { partitions: true })['h'];

                        // Get Today energy
                        var lastDay = new Date(points[points.length-1][0]);
                        var todayData = UtilityService.timeRange(lastWeekData, { starttime: lastDay.getTime(), endtime: lastDay.getTime(), sharpTime: true });
                        var todayEnergy = UtilityService.getAreaUnderCurve(todayData);
                        var todayPeak = UtilityService.getAreaUnderCurve(todayData, { partitions: true })['h'];

                        deferred.resolve({
                            lastMonthEnergyPerSqr: lastMonthEnergy/buildingarea,
                            lastMonthEnergy:lastMonthEnergy,
                            lastMonthPeak: lastMonthPeak,
                            lastMonthCompare: (thisMonthSamePeriod / lastMonthSamePeriod - 1)*100,
                            thisMonthSamePeriod: thisMonthSamePeriod,
                            dailyAverage: lastWeekEnergy / 5,
                            peakAverage: lastWeekPeak / 5,
                            yesterdayEnergy: yesterdayEnergy,
                            yesterdayPeak: yesterdayPeak,
                            todayEnergy: todayEnergy,
                            todayPeak: todayPeak
                        })
                    },
                    function(error) {
                        deferred.reject(error);
                    }
                );
            })


        return deferred.promise;
    };

    partitionedEnergyUse=function(buildingID,options, cache) {
        var deferred = $q.defer(),
            loadData;

        options = options || {};

        var start = options.starttime || moment().subtract(1, 'year').valueOf();
        var end = options.endtime || moment().valueOf();

        //TODO: CACHE TO OFFLINE
        loadData = /*cache ? $q.resolve(cache) :*/ load(buildingID, start, end);

        loadData.then(function(result) {
            result = result[0] || {};
            var points = result.points || [];
            points = points.reverse();
            var monthlyEnergy = UtilityService.groupDataByTime(points, options)
            deferred.resolve(monthlyEnergy);
        });

        return deferred.promise;
    }

    return {
        load: load,
        calculate: calculate,
        partitionedEnergyUse:partitionedEnergyUse,
        calculateBuildingEnergies:calculateBuildingEnergies
    };
}])

.factory('WeatherFactory', ['$q', '$rootScope', '$http', 'HelperService',function ($q, $rootScope, $http,HelperService) {
    var get,hdd,cdd;

    get = function(id,starttime,endtime) {
        var deferred = $q.defer();
        var data = { "isExternalRequest": "False", "time_format": "ms", "interval": "60m", "operation": "mean(TemperatureC),mean(Humidity)"}
        
        if (starttime)
            data.start_utc = HelperService.toPyTime(starttime);
        
        if (endtime)
            data.end_utc = HelperService.toPyTime(endtime);
        
        var url='api/getweather/'+id+"/";
        
        // $http({
        //     url: '/api/series',
        //     params: { serieName: buildingId,start:start,end:end },
        //     headers: { 'X-CSRF-Token': $("meta[name='csrf-param']").attr('content') }
        // }).then(function (result) {
        //     deferred.resolve(result.data);
        // });
        $http({
            url:url,
            data: data,
            method: 'POST'
        }).then(function(result){
            if(result.data){
                var points=(result.data[0]||{}).points||[];
                points=points.reverse();
                deferred.resolve(points);    
            }else{
                deferred.reject({error:"no data"});
            }
            
        },function(err){
           deferred.resolve([]);  
        })

        // $http.get('/static/data/api.weather.shanghai.zsss.2015.30m.json').then(function (result) {
        //     var data=result.data;
        //     if(starttime||endtime){
        //         data=_.filter(data||[],function(d){
        //             var t=new Date(d.date);
        //             if(starttime){
        //                 if(t<starttime)return false;
        //             }
        //             if(endtime){
        //                 if(t>endtime) return false;
        //             }
        //             return true;
        //         });    
        //     }
        //     deferred.resolve(data);
        // });

        return deferred.promise;
    }
    hdd=function(desiredTemp,tempSeries,options){
        var daily=_.groupBy(tempSeries,function(d){
            var date = new Date(d[0]);
            return (date.getMonth()+1) + '/' + date.getDate() + '/'+date.getFullYear();
        });
        var summary = { cdd: [], hdd: [] };
        angular.forEach(daily, function (v, k) {
            var tempSum = 0.0;
            var tempcdd=0,count=0,temphdd=0,count=0;
            for (var j = 0; j < daily[k].length; j++) {
                var diff=parseFloat(daily[k][j][1])-desiredTemp;
                if(diff>0){
                    tempcdd+=diff;
                    count++;
                }else if(diff<0){
                    temphdd-=diff;
                    count++;
                }
            }
            var time=new Date(k).getTime();
            if(!time){
                console.log(k);
            }
            summary.cdd.push([time,Math.round(tempcdd/count)]);
            summary.hdd.push([time, Math.round(temphdd / count)]);
        });
        return summary;
    }

    return {
        get: get,
        hdd:hdd
    };
}])


.factory('FormService', ['$q', '$rootScope', '$http', 'EnergyUnitFactory', function ($q, $rootScope, $http,EnergyUnitFactory) {
    var load,save;

    load = function (options) {

        var deferred = $q.defer();
        if(options.id){
            $http.get('api/monitoring_config/'+options.id+'/').then(function (result) {
                deferred.resolve(result.data);
            },function(err){
                deferred.reject(err);
            });    
        }else if(options.energy_unit_id){
            EnergyUnitFactory.getByID(options.energy_unit_id).then(function(result){
                return $http.get('api/monitoring_config/'+result.monitor_config+'/');
            }).then(function(result){
                deferred.resolve(result.data);
            },function(err){
                deferred.reject(err);
            })
        }
        

        return deferred.promise;
    }
    save=function(config,options){
        var deferred=$q.defer();
        if(options.id){
            $http.put('api/monitoring_config/'+id+"/",config).then(function (result) {
                deferred.resolve(result.data);
            },function(err){
                deferred.reject(err);
            });
        }else if(options.energy_unit_id){
            EnergyUnitFactory.getByID(options.energy_unit_id).then(function(result){
                return $http.put('api/monitoring_config/'+result.monitor_config+"/",config,{headers:{'Content-Type':'application/json'}});
            }).then(function(result){
                deferred.resolve(result.data);
            },function(err){
                deferred.reject(err);
            })
        }
        
        return deferred.promise;
    }

    return {
        load: load,
        save:save
    };
}])

.factory('seriesService', ['$q', '$rootScope', '$http', 'UtilityService', 'HelperService', '$templateCache', 
    function ($q, $rootScope, $http, UtilityService, HelperService, $templateCache) {
    
    var load,summaryStats;
    load = function (buildingId, start, end,options) {
        var interval=(options||{}).interval?options.interval:"auto";
        
        var deferred = $q.defer();
        var data = { "isExternalRequest": "False", "time_format": "ms", "interval": interval, "operation": "mean(value)"}
        if((options||{}).disagg){
            data['disagg']=options.disagg;
        }
        
        //  WARNING: 
        //      INFO:
        //      --- python unix_time returns seconds
        //      --- js getTime returns milliseconds
        //      --- python month starts with 1
        //      --- js month starts with 0
        //
        //      --- backend doesn't account this inconsistancy (view.py)
        //
        //      SOLUTION:
        //      --- Until backend didn't incorporate conversion, its implemented here

        if (start)
            data.start_utc = HelperService.toPyTime(start);
        
        if (end)
            data.end_utc = HelperService.toPyTime(end);
        
        var url='api/getseries/'+buildingId+"/";
        if(options.predict){
            url="api/predictseries/"+buildingId+"/";
        }
        // $http({
        //     url: '/api/series',
        //     params: { serieName: buildingId,start:start,end:end },
        //     headers: { 'X-CSRF-Token': $("meta[name='csrf-param']").attr('content') }
        // }).then(function (result) {
        //     deferred.resolve(result.data);
        // });

        $http.post(url, data).then(function (result) {

            // Py to Js time conversion, see warning above
            // Change the time unit into "ms", then the returned time is also "ms"
            // if (result.data && result.data.length > 0) {
            //     result.data[0].points = _.map(result.data[0].points, function (obj) {
            //         return [HelperService.toJsTime(obj[0]), obj[1]];
            //     });
            // }

            deferred.resolve(result.data);
        },function(err){
            console.log(err);
            deferred.resolve([]);
        });
        return deferred.promise;
    }
    summaryStats=function(data){
        return $q.resolve({}).then(function(){
            data=_.filter(data,function(d){
                return d[1]!=0;
            })
            var fulldatapeak = UtilityService.getAreaUnderCurve(data, { partitions:true})['h'];
            var energy=UtilityService.getAreaUnderCurve(data);
            var byDay=_.groupBy(data,function(d){
                var date=new Date(d[0]);
                var day="0"+date.getDate();
                var month="0"+(date.getMonth()+1);
                var year=date.getFullYear();
                return year+"/"+month.slice(-2)+"/"+day.slice(-2);
            })
            // check the head and tail see if they have enough data.
            // basically if the interval between midnight to first point, or last point to midnight next day is too big. then cut it
            byDay=_.filter(byDay,function(d){
                var da=new Date(d[0][0]);
                var interval=da.getHours()*60+da.getMinutes();
                da=new Date(d[d.length-1][0]);
                var interval2=da.getHours()*60+da.getMinutes();
                if(interval2-interval<12*60){
                    return false;
                }
                return true;
                // interval=Math.max(interval,interval2);
                // var avg=60*24/d.length;
                // return interval<avg*5
            })
            var dailyResult=_.map(byDay,function(d){
                 var result={sum:0,min:99999,max:0}
                 var currentMax=0,currentMin=999999,currentSum=0;
                 for(var i=0;i<d.length-1;i++){
                    var u=(d[i+1][0]-d[i][0])/3600000;// make it in units of hour
                    result.sum+=d[i][1]*u; // This is like enumerate integration
                    var td=new Date(d[i][0]).getHours();
                    var td2=new Date(d[i+1][0]).getHours();
                    if(td===td2){
                        currentSum+=d[i][1]*u;
                    }else{
                        result.max=Math.max(result.max,currentSum);
                        result.min=Math.min(result.min,currentSum);
                        currentSum=0;
                    }
                 }
                result.max=Math.max(result.max,currentSum);
                result.min=Math.min(result.min,currentSum);
                if(result.sum==0){
                    console.log(result);
                }
                return result;
            });
            var usage=_.pluck(dailyResult,"sum");
            var hmax=_.pluck(dailyResult,"max");
            var hmin=_.pluck(dailyResult,"min");
            var result={};
            // Calculate highest energy use point,
            var peak=0,avg=0;
            for(var i=0;i<data.length;i++){
                avg+=data[i][1];
                if(data[i][1]>peak){
                    peak=data[i][1];
                }
            }
            avg=avg/data.length;
            if(usage.length>0){
                result={
                    "dailymax":Math.max.apply(Math,usage).toFixed(2),
                    "dailymin":Math.min.apply(Math,usage).toFixed(2),
                    "dailyavg":(_.reduce(usage,function(s,u){return s+u},0)/usage.length).toFixed(2),
                    "hourlymax":Math.max.apply(Math,hmax).toFixed(2),
                    "hourlymin":Math.max.apply(Math,hmin).toFixed(2),
                    "peakPercent":(fulldatapeak/energy).toFixed(2),
                    "loadingFactor":(avg/peak).toFixed(2)
                }
            }else{
                result={
                    "dailymax":0,
                    "dailymin":0,
                    "dailyavg":0,
                    "hourlymax":0,
                    "hourlymin":0,
                    "peakPercent":0
                }
            }
            return $q.resolve(result);
        })
    }

    return {
        load: load,
        summaryStats:summaryStats
    };
}])

.service('modalService', ['$uibModal', function ($modal) {

    var modalDefaults = {
        backdrop: true,
        keyboard: true,
        modalFade: true,
        templateUrl: '/static/views/shared/dialog.html'
    };

    var modalOptions = {
        closeButtonText: 'Close',
        actionButtonText: 'OK',
        headerText: 'Proceed?',
        bodyText: 'Perform this action?'
    };

    var instance = null;

    this.show = function (customModalDefaults, customModalOptions) {

        if (instance) {
            instance.dismiss('cancel');
            instance = null;
        }



        //Create temp objects to work with since we're in a singleton service
        var tempModalDefaults = {};
        var tempModalOptions = {};

        //Map angular-ui modal custom defaults to modal defaults defined in service
        angular.extend(tempModalDefaults, modalDefaults, customModalDefaults);

        //Map modal.html $scope custom properties to defaults defined in service
        angular.extend(tempModalOptions, modalOptions, customModalOptions);

        if (!tempModalDefaults.controller) {
            tempModalDefaults.controller = function ($scope, $modalInstance) {

                instance = $modalInstance;

                $scope.modalOptions = tempModalOptions;

                $scope.modalOptions.ok = function (result) {
                    instance = null;
                    $modalInstance.close(result);
                };

                $scope.modalOptions.close = function (result) {
                    $modalInstance.dismiss('cancel');
                };
            };
        }

        return $modal.open(tempModalDefaults).result;
    };

    this.dismiss = function () {
        if (instance) {
            instance.dismiss('cancel');
            instance = null;
        }
    };


}])

.service('wizardService', ['$rootScope', 'modalService', '$q', '$injector', '$http', 'limitToFilter', function ($rootScope, modalService, $q, $injector, $http, limitToFilter) {

    this.show = function (scopeData, handler, customOptions) {
        var deferred = $q.defer();



        var defaultOptions = {
            templateUrl: 'template/wizard.html',
            windowClass: 'dialog',
            controller: function ($scope, $modalInstance) {
                $scope.data = scopeData;
                $scope.index = 0;

                $scope.steps = [
                    'template/wizard/step1.html', 'template/wizard/step2.html', 'template/wizard/step3.html'
                ];

                $scope.doStep = function (count) {
                    $scope.index += count;

                    $scope.index = Math.min($scope.index, $scope.steps.length);
                    $scope.index = Math.max($scope.index, 0);
                }


                $scope.ok = function (result) { $modalInstance.close(result); };
                $scope.close = function (result) { $modalInstance.dismiss('cancel'); };
            }
        };

        var tempOptions = {};
        angular.extend(tempOptions, defaultOptions, customOptions);

        modalService.show(tempOptions).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });

        return deferred.promise;

    };

}])

},{"./api.alerts":60,"./app.account":61,"./app.config":62,"./app.csv2json":63,"./app.error":64,"./app.export":65,"./app.geo":66,"./app.html2pdf":67,"./app.io":68,"./app.nav":69,"./app.platform":70}],72:[function(require,module,exports){
angular.module('app.templates', []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/daterange-datepicker.html",
        '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">' +
        '  <uib-daypicker template-url="template/daterange-daypicker.html" ng-switch-when="day" tabindex="0"></uib-daypicker>' +
        '  <uib-monthpicker ng-switch-when="month" tabindex="0"></uib-monthpicker>' +
        '  <uib-yearpicker ng-switch-when="year" tabindex="0"></uib-yearpicker>' +
        '</div>' +
    '');

    $templateCache.put("template/daterange-daypicker.html",
        '<table class="uib-daypicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">' +
        '  <thead>' +
        '    <tr>' +
        '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>' +
        '      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>' +
        '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>' +
        '    </tr>' +
        '    <tr>' +
        '      <th ng-if="showWeeks" class="text-center"></th>' +
        '      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>' +
        '    </tr>' +
        '  </thead>' +
        '  <tbody>' +
        '    <tr class="uib-weeks" ng-repeat="row in rows track by $index">' +
        '      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>' +
        '      <td ng-repeat="dt in row track by dt.date" class="uib-day text-center" role="gridcell" id="{{::dt.uid}}" ng-class="dt.customClass">' +
        '        <button type="button" style="min-width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>' +
        '      </td>' +
        '    </tr>' +
        '  </tbody>' +
        '</table>' +
    '');

    $templateCache.put("template/rz-slider.html",
        '<span class="rz-bar-wrapper"><span class="rz-bar"></span></span>' + <!-- // 0 The slider bar -->
        '<span class="rz-bar-wrapper"><span class="rz-bar rz-selection"></span></span>' + <!-- // 1 Highlight between two handles -->
        '<span class="rz-pointer"></span>' + <!-- // 2 Left slider handle -->
        '<span class="rz-pointer"></span>' + <!-- // 3 Right slider handle -->
        '<span class="rz-bubble rz-limit"></span>' + <!-- // 4 Floor label -->
        '<span class="rz-bubble rz-limit"></span>' + <!-- // 5 Ceiling label -->
        '<span class="rz-bubble rz-handle-label"></span>' + <!-- // 6 Label above left slider handle -->
        '<span class="rz-bubble rz-label"></span>' + <!-- // 7 Label above right slider handle -->
        '<span class="rz-bubble rz-label"></span>' + <!-- // 8 Range label when the slider handles are close ex. 15 - 17 -->
        '<ul class="rz-ticks"></ul>' + <!-- // 9 The ticks -->
    '');


    $templateCache.put("template/tree-node-2.html",
        '<div ui-tree-handle data-nodrag ng-style="{opacity: node.nodes.length == 0 && (node.type == 2 || node.type == 1) ? \'0.4\' : \'1\' }">' +
        '    <a class="expander" data-nodrag style="position: absolute; left: -21px; top: 0; line-height: 22px;"" ng-show="node.type == 3 && node.nodes.length > 0">' +
        '        <i ng-click="toggle(this)" class="fa" style="font-size:11px;" ng-class="{ \'fa-plus-square-o\': this.collapsed, \'fa-minus-square-o\': !this.collapsed }"></i>' +
        '    </a>' +
        '' +
        '    <a class="icon" data-nodrag>' +
        '        <i ng-click="toggle(this)" class="" ng-class="{ \'icon-building fs14\': node.type == 1, \'icon-building-6 fs16\': node.type == 2, \'icon-gauge-4\': node.type == 3 }" ng-style="{ \'color\': node.color }"></i>' +
        '    </a>' +
        '    <!-- groups & buildings -->' +
        '    <a class="text editable" ng-show="node.nodes.length > 0 && node.type != 3" ng-click="toggle(this);" ng-class="{selected: isSelected(node.id)}">' +
        '        <i class="icon-pencil" ng-click="edit(node, $event);" ng-style="{color: node.color}"></i>' +
        '        <span ng-bind="node.name"></span>' +
        '    </a>' +
        '    <!-- meters -->' +
        '    <a class="text pl25 editable" ng-hide="node.nodes.length > 0 && node.type != 3" ng-click="toggleSeries(node, this)" ng-style="{ \'color\': node.color }">' +
        '        <i class="icon-pencil" ng-click="edit(node, $event);" ng-style="{color: node.color}"></i>' +
        '        <span ng-bind="node.name"></span>' +
        '    </a>' +
        '</div>' +
        '<ol ui-tree-nodes="" ng-model="node.nodes" ng-class="{hidden: collapsed}">' +
        '    <li ng-repeat="node in node.nodes" ui-tree-node ng-include="\'template/tree-node-2.html\'" data-collapsed="true">' +
        '    </li>' +
        '</ol>' +
    '');

    $templateCache.put("template/dialog.prompt.html",
        '<form class="form-horizontal" name="newMeterForm">' + 
        '    <table class="table table-bordered">' + 
        '        <tbody>' + 
        '            <tr >' + 
        '                <td>' + 
        '                    <span ng-bind="config.model[0].name" title="{{config.model[0].name}}" class="green"></span>' + 
        '                </td>' + 
        '                <td class="p0">' + 
        '                    <input type="text" class="form-control" ng-model="config.model[0].value" autofocus>' + 
        '                </td></tr ><tr >' + 
        '                 <td>' + 
        '                    <span ng-bind="config.model[1].name" title="{{config.model[1].name}}" class="green"></span>' + 
        '                </td>' + 
        '                <td class="p0">' + 
        '                    <div  uib-dropdown dropdown-append-to-body>'+
        '                      <a class="dropdown-toggle" uib-dropdown-toggle role="menu" aria-labelledby="single-button">'+
        '                           <span  ng-bind="getType(config.model[1].value)">---</span> <i class="fa fa-caret-down" style="color: #333"></i>'+
        '                       </a>'+
        '                       <ul class="dropdown-menu uib-dropdown-menu">'+
        '                           <li ng-repeat="item in typeOptions">'+
        '                               <a class="" ng-click="config.model[1].value=item.id">{{item.name}}</a>'+
        '                           </li>'+
        '                       </ul>'+
        '                   </div>' + 
        '                </td>' + 
        '            </tr>' + 
        '        </tbody>' + 
        '    </table>' + 
        '</form>' +
    '');

    $templateCache.put("template/dialog.prompt.import.html",
        '<div class="flex">' + 
        '   <button class="btn btn-success flex-resize mb10" ng-click="config.onMerge()">保留现有数据</button>' + 
        '   <button class="btn btn-danger flex-resize" ng-click="config.onReplace()">替换现有数据</button>' + 
        '</div>' +
    '');

    $templateCache.put("template/ui.grid.chart.import.edit.dialog.html",
        '<form class="form-horizontal" name="newEntryForm">' + 
        '    <input type="hidden" ng-model="config.model[1].value">' + 
        '    <table class="table table-bordered">' + 
        '        <tbody>' + 
        '            <tr>' + 
        '                <td>' + 
        '                    <span ng-bind="config.model[0].name" title="{{config.model[0].name}}" class="green"></span>' + 
        '                </td>' + 
        '                <td class="rel p0">' + 
        '                   <div class="flex" uib-dropdown dropdown-append-to-body auto-close="disabled" is-open="config.model[0].isDatePickerOpen">' +
        '                       <div>' +
        '                           <span class="flex-resize" style="padding: 8px 12px;display:block">{{config.model[0].getDate()}}</span>' +
        '                           <button uib-dropdown-toggle class="btn btn-default btn-flat wa m0" style="position: absolute; right: 0; top: 0; border: 0; border-left: solid 1px #ccc; height: 100%; border-radius: 0;">' +
        '                               <i class="icon-pencil"></i>' +
        '                           </button>' +
        '                       </div>' +
        '                       <div class="uib-dropdown-menu datepicker" style="position: absolute; left: 0; top: 0; bottom:auto; border: solid 1px #ccc;">' +
        '                           <div class="flex">' +
        '                               <div class="flex" style="padding: 7.5px; background: #efefef; box-shadow: 0 5px 10px rgba(0,0,0,.05) inset;">' +
        '                                   <div class="flex" style="padding: 7.5px">' +
        '                                       <uib-datepicker template-url="template/daterange-datepicker.html" ng-model="config.model[0].value" starting-day="1" class="datepicker"></uib-datepicker>' +
        '                                   </div>' +
        '                                   <div class="flex flex-center" style="padding: 7.5px">' +
        '                                        <uib-timepicker ng-model="config.model[0].value" hour-step="1" minute-step="1" show-meridian="false"></uib-timepicker>' +
        '                                   </div>' +
        '                               </div>' +
        '                               <div class="flex" style="padding: 7.5px">' +
        '                                   <button class="btn btn-default btn-blue" ng-click="config.model[0].applyDateTime()">Apply</button>' +
        '                               </div>' +
        '                           </div>' +
        '                       </div>' +
        '                   </div>' +
        '                </td>' +
        '            </tr>' +
        '            <tr>' + 
        '                <td>' + 
        '                    <span ng-bind="config.model[1].name" title="{{config.model[1].name}}" class="green"></span>' + 
        '                </td>' + 
        '                <td class="p0">' + 
        '                    <input type="number" class="form-control" ng-model="config.model[1].value" autofocus>' + 
        '                </td>' + 
        '            </tr>' + 
        '        </tbody>' + 
        '    </table>' + 
        '</form>' +
    '');

    $templateCache.put("template/ui.grid.chart.import.edit.dialog.html",
        '<form class="form-horizontal" name="newEntryForm">' + 
        '    <input type="hidden" ng-model="config.model[1].value">' + 
        '    <table class="table table-bordered">' + 
        '        <tbody>' + 
        '            <tr>' + 
        '                <td>' + 
        '                    <span ng-bind="config.model[0].name" title="{{config.model[0].name}}" class="green"></span>' + 
        '                </td>' + 
        '                <td class="rel p0">' + 
        '                   <div class="flex " uib-dropdown dropdown-append-to-body auto-close="disabled" is-open="config.model[0].isDatePickerOpen">' +
        '                       <div>' +
        '                           <span class="flex-resize" style="padding: 8px 12px;display:block">{{config.model[0].getDate()}}</span>' +
        '                           <button uib-dropdown-toggle class="btn btn-default btn-flat wa m0" style="position: absolute; right: 0; top: 0; border: 0; border-left: solid 1px #ccc; height: 100%; border-radius: 0;">' +
        '                               <i class="icon-pencil"></i>' +
        '                           </button>' +
        '                       </div>' +
        '                       <div class="uib-dropdown-menu datepicker" style="position: absolute; left: 0; top: 0; bottom:auto; border: solid 1px #ccc;">' +
        '                           <div class="flex ">' +
        '                               <div class="flex " style="padding: 7.5px; background: #efefef; box-shadow: 0 5px 10px rgba(0,0,0,.05) inset;">' +
        '                                   <div class="flex " style="padding: 7.5px">' +
        '                                       <uib-datepicker template-url="template/daterange-datepicker.html" ng-model="config.model[0].value" starting-day="1" class="datepicker"></uib-datepicker>' +
        '                                   </div>' +
        '                                   <div class="flex  flex-center" style="padding: 7.5px">' +
        '                                        <uib-timepicker ng-model="config.model[0].value" hour-step="1" minute-step="1" show-meridian="false"></uib-timepicker>' +
        '                                   </div>' +
        '                               </div>' +
        '                               <div class="flex " style="padding: 7.5px">' +
        '                                   <button class="btn btn-default btn-blue" ng-click="config.model[0].applyDateTime()">Apply</button>' +
        '                               </div>' +
        '                           </div>' +
        '                       </div>' +
        '                   </div>' +
        '                </td>' +
        '            </tr>' +
        '            <tr>' + 
        '                <td>' + 
        '                    <span ng-bind="config.model[1].name" title="{{config.model[1].name}}" class="green"></span>' + 
        '                </td>' + 
        '                <td class="p0">' + 
        '                    <input type="number" class="form-control" ng-model="config.model[1].value" autofocus>' + 
        '                </td>' + 
        '            </tr>' + 
        '        </tbody>' + 
        '    </table>' + 
        '</form>' +
    '');

   $templateCache.put("template/dialog.generic.compare.html",
        '<form class="form-horizontal" name="newEntryForm" autocomplete="off">' + 
        '   <table class="table table-bordered">' +
        '       <tbody>' +
        '          <tr>' +
        '               <td>' +
        '                   <span ng-bind="config.model[0].name" title="{{config.model[0].name}}" class="green"></span>' + 
        '               </td>' +
        '              <td class="p0">' + 
        '                   <input autocomplete="new-password" type="{{config.model[0].type}}" class="form-control" ng-model="config.model[0].value" mandatory autofocus>' + 
        '               </td>' + 
        '           </tr>' +
        '           <tr>' +
        '               <td>' +
        '                   <span ng-bind="config.model[1].name" title="{{config.model[1].name}}" class="green"></span>' + 
        '               </td>' +
        '              <td class="p0">' + 
        '                   <input autocomplete="new-password" type="{{config.model[1].type}}" class="form-control" ng-model="config.model[1].value" mandatory compare-to="config.model[0].value != config.model[1].value ? \'*\' : \'\' ">' + 
        '               </td>' + 
        '           </tr>' +
        '       <tbody>' +
        '   </table>' +
        '</form>' +
    '');

   $templateCache.put("template/popover-list-menu.html",
        '<ion-popover-view>' + 
        '    <ion-content>' + 
        '       <div class="list m0">' + 
        '           <a class="item" ng-repeat="item in popover.scope.$parent.popData" ng-bind="item.title" ng-click="popSelected(item)">' + 
        '               ' + 
        '           </a>' + 
        '       </div>' + 
        '    </ion-content>' + 
        '</ion-popover-view>' + 
    '');

   $templateCache.put("template/popover-confirm-email.html",
        '<ion-popover-view style="max-width: 350px; height: 200px;">' + 
        '    <ion-content>' + 
        '       <div class="list m0">' + 
        '           <a class="item" ng-repeat="item in popover.scope.$parent.popData" ng-bind="item.title" ng-click="popSelected(item)">' + 
        '               ' + 
        '           </a>' + 
        '       </div>' + 
        '       <form name="emailConfirmForm">' + 
        '           <table class="table table-bordered">' +
        '               <tbody>' +
        '                   <tr>' +
        '                       <td>' +
        '                           <span ng-bind="popoverEmail.model.title" title="{{popoverEmail.model.title}}" class="green wsnw"></span>' + 
        '                       </td>' +
        '                       <td class="p0">' + 
        '                           <input autocomplete="new-password" type="email" class="form-control" ng-model="popoverEmail.model.value" mandatory autofocus>' + 
        '                       </td>' + 
        '                   </tr>' +
        '                   <tr>' +
        '                       <td>' +
        '                           <span ng-bind="popoverEmail.model.confirmTitle" title="{{popoverEmail.model.confirmTitle}}" class="green wsnw"></span>' + 
        '                       </td>' +
        '                       <td class="p0">' + 
        '                           <input autocomplete="new-password" type="email" class="form-control" ng-model="popoverEmail.model.value2" mandatory compare-to="popoverEmail.model.value != popoverEmail.model.value2 ? \'*\' : \'\' ">' + 
        '                       </td>' + 
        '                   </tr>' +
        '               </tbody>' +
        '               <tfoot>' +
        '                   <tr>' +
        '                       <td>' +
        '                           <button class="btn btn-link" ng-click="popoverEmail.onCancel()">Cancel</button>' + 
        '                       </td>' +
        '                       <td>' + 
        '                           <button class="btn btn-link" ng-click="popoverEmail.onOk()" ng-disabled="emailConfirmForm.$invalid">Save</button>' + 
        '                       </td>' + 
        '                   </tr>' +
        '               </tfoot>' +
        '           </table>' +
        '       </form>' +
        '    </ion-content>' + 
        '</ion-popover-view>' + 
    '');

   $templateCache.put("template/popover-confirm-password.html",
        '<ion-popover-view style="max-width: 350px; height: 200px;">' + 
        '    <ion-content>' + 
        '       <div class="list m0">' + 
        '           <a class="item" ng-repeat="item in popover.scope.$parent.popData" ng-bind="item.title" ng-click="popSelected(item)">' + 
        '               ' + 
        '           </a>' + 
        '       </div>' + 
        '       <form name="passwordConfirmForm">' + 
        '           <table class="table table-bordered">' +
        '               <tbody>' +
        '                   <tr>' +
        '                       <td>' +
        '                           <span ng-bind="popoverPassword.model.title" title="{{popoverPassword.model.title}}" class="green wsnw"></span>' + 
        '                       </td>' +
        '                       <td class="p0">' + 
        '                           <input autocomplete="new-password" type="password" class="form-control" ng-model="popoverPassword.model.value" mandatory autofocus>' + 
        '                       </td>' + 
        '                   </tr>' +
        '                   <tr>' +
        '                       <td>' +
        '                           <span ng-bind="popoverPassword.model.confirmTitle" title="{{popoverPassword.model.confirmTitle}}" class="green wsnw"></span>' + 
        '                       </td>' +
        '                       <td class="p0">' + 
        '                           <input autocomplete="new-password" type="password" class="form-control" ng-model="popoverPassword.model.value2" mandatory compare-to="popoverPassword.model.value != popoverPassword.model.value2 ? \'*\' : \'\' ">' + 
        '                       </td>' + 
        '                   </tr>' +
        '               </tbody>' +
        '               <tfoot>' +
        '                   <tr>' +
        '                       <td>' +
        '                           <button class="btn btn-link" ng-click="popoverPassword.onCancel()">Cancel</button>' + 
        '                       </td>' +
        '                       <td>' + 
        '                           <button class="btn btn-link" ng-click="popoverPassword.onOk()" ng-disabled="passwordConfirmForm.$invalid">Save</button>' + 
        '                       </td>' + 
        '                   </tr>' +
        '               </tfoot>' +
        '           </table>' +
        '       </form>' +
        '    </ion-content>' + 
        '</ion-popover-view>' + 
    '');

   $templateCache.put("template/modal.html",
      '<ion-modal-view>' +
      '  <ion-header-bar>' +
      //'    <h1 class="title">TITLE</h1>' +
      '  </ion-header-bar>' +
      '  <ion-content>' +
      '    <div ag-grid="gridOptions" class="ag-fresh flex-absolute" style="top: 70px;"></div>' +
      '  </ion-content>' +
      '</ion-modal-view>' +
    '');

    $templateCache.put("templates/toast.progressbar.html",
        '<div class="toast-progress"></div>'
    );

    $templateCache.put("templates/unit.toast.html",
        '<div class="unit-toast" ng-click="tapToast()">' +  
        '    <i class="svg-building"></i>'+
        '    <div ng-switch on="allowHtml">' + 
        '        <div ng-switch-default ng-if="title" class="{{titleClass}}" aria-label="{{title}}">{{title}}</div>'+
        '        <div ng-switch-default class="{{messageClass}}" aria-label="{{message}}">{{message}}</div>'+
        '        <div ng-switch-when="true" ng-if="title" class="{{titleClass}}" ng-bind-html="title"></div>'+
        '        <div ng-switch-when="true" class="{{messageClass}}" ng-bind-html="message"></div>'+
        '    </div>'+
        '    <progress-bar ng-if="progressBar"></progress-bar>'+
        '</div>');
}]);


},{}],73:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("./context/context");
var constants_1 = require("./constants");
var columnController_1 = require("./columnController/columnController");
var floatingRowModel_1 = require("./rowControllers/floatingRowModel");
var utils_1 = require("./utils");
var gridRow_1 = require("./entities/gridRow");
var gridCell_1 = require("./entities/gridCell");
var CellNavigationService = (function () {
    function CellNavigationService() {
    }
    CellNavigationService.prototype.getNextCellToFocus = function (key, lastCellToFocus) {
        switch (key) {
            case constants_1.Constants.KEY_UP: return this.getCellAbove(lastCellToFocus);
            case constants_1.Constants.KEY_DOWN: return this.getCellBelow(lastCellToFocus);
            case constants_1.Constants.KEY_RIGHT: return this.getCellToRight(lastCellToFocus);
            case constants_1.Constants.KEY_LEFT: return this.getCellToLeft(lastCellToFocus);
            default: console.log('ag-Grid: unknown key for navigation ' + key);
        }
    };
    CellNavigationService.prototype.getCellToLeft = function (lastCell) {
        var colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);
        if (!colToLeft) {
            return null;
        }
        else {
            return new gridCell_1.GridCell(lastCell.rowIndex, lastCell.floating, colToLeft);
        }
    };
    CellNavigationService.prototype.getCellToRight = function (lastCell) {
        var colToRight = this.columnController.getDisplayedColAfter(lastCell.column);
        // if already on right, do nothing
        if (!colToRight) {
            return null;
        }
        else {
            return new gridCell_1.GridCell(lastCell.rowIndex, lastCell.floating, colToRight);
        }
    };
    CellNavigationService.prototype.getRowBelow = function (lastRow) {
        // if already on top row, do nothing
        if (this.isLastRowInContainer(lastRow)) {
            if (lastRow.isFloatingBottom()) {
                return null;
            }
            else if (lastRow.isNotFloating()) {
                if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_BOTTOM)) {
                    return new gridRow_1.GridRow(0, constants_1.Constants.FLOATING_BOTTOM);
                }
                else {
                    return null;
                }
            }
            else {
                if (this.rowModel.isRowsToRender()) {
                    return new gridRow_1.GridRow(0, null);
                }
                else if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_BOTTOM)) {
                    return new gridRow_1.GridRow(0, constants_1.Constants.FLOATING_BOTTOM);
                }
                else {
                    return null;
                }
            }
        }
        else {
            return new gridRow_1.GridRow(lastRow.rowIndex + 1, lastRow.floating);
        }
    };
    CellNavigationService.prototype.getCellBelow = function (lastCell) {
        var rowBelow = this.getRowBelow(lastCell.getGridRow());
        if (rowBelow) {
            return new gridCell_1.GridCell(rowBelow.rowIndex, rowBelow.floating, lastCell.column);
        }
        else {
            return null;
        }
    };
    CellNavigationService.prototype.isLastRowInContainer = function (gridRow) {
        if (gridRow.isFloatingTop()) {
            var lastTopIndex = this.floatingRowModel.getFloatingTopRowData().length - 1;
            return lastTopIndex === gridRow.rowIndex;
        }
        else if (gridRow.isFloatingBottom()) {
            var lastBottomIndex = this.floatingRowModel.getFloatingBottomRowData().length - 1;
            return lastBottomIndex === gridRow.rowIndex;
        }
        else {
            var lastBodyIndex = this.rowModel.getRowCount() - 1;
            return lastBodyIndex === gridRow.rowIndex;
        }
    };
    CellNavigationService.prototype.getRowAbove = function (lastRow) {
        // if already on top row, do nothing
        if (lastRow.rowIndex === 0) {
            if (lastRow.isFloatingTop()) {
                return null;
            }
            else if (lastRow.isNotFloating()) {
                if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_TOP)) {
                    return this.getLastFloatingTopRow();
                }
                else {
                    return null;
                }
            }
            else {
                // last floating bottom
                if (this.rowModel.isRowsToRender()) {
                    return this.getLastBodyCell();
                }
                else if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_TOP)) {
                    return this.getLastFloatingTopRow();
                }
                else {
                    return null;
                }
            }
        }
        else {
            return new gridRow_1.GridRow(lastRow.rowIndex - 1, lastRow.floating);
        }
    };
    CellNavigationService.prototype.getCellAbove = function (lastCell) {
        var rowAbove = this.getRowAbove(lastCell.getGridRow());
        if (rowAbove) {
            return new gridCell_1.GridCell(rowAbove.rowIndex, rowAbove.floating, lastCell.column);
        }
        else {
            return null;
        }
    };
    CellNavigationService.prototype.getLastBodyCell = function () {
        var lastBodyRow = this.rowModel.getRowCount() - 1;
        return new gridRow_1.GridRow(lastBodyRow, null);
    };
    CellNavigationService.prototype.getLastFloatingTopRow = function () {
        var lastFloatingRow = this.floatingRowModel.getFloatingTopRowData().length - 1;
        return new gridRow_1.GridRow(lastFloatingRow, constants_1.Constants.FLOATING_TOP);
    };
    CellNavigationService.prototype.getNextTabbedCell = function (gridCell, backwards) {
        if (backwards) {
            return this.getNextTabbedCellBackwards(gridCell);
        }
        else {
            return this.getNextTabbedCellForwards(gridCell);
        }
    };
    CellNavigationService.prototype.getNextTabbedCellForwards = function (gridCell) {
        var displayedColumns = this.columnController.getAllDisplayedColumns();
        var newRowIndex = gridCell.rowIndex;
        var newFloating = gridCell.floating;
        // move along to the next cell
        var newColumn = this.columnController.getDisplayedColAfter(gridCell.column);
        // check if end of the row, and if so, go forward a row
        if (!newColumn) {
            newColumn = displayedColumns[0];
            var rowBelow = this.getRowBelow(gridCell.getGridRow());
            if (utils_1.Utils.missing(rowBelow)) {
                return;
            }
            newRowIndex = rowBelow.rowIndex;
            newFloating = rowBelow.floating;
        }
        return new gridCell_1.GridCell(newRowIndex, newFloating, newColumn);
    };
    CellNavigationService.prototype.getNextTabbedCellBackwards = function (gridCell) {
        var displayedColumns = this.columnController.getAllDisplayedColumns();
        var newRowIndex = gridCell.rowIndex;
        var newFloating = gridCell.floating;
        // move along to the next cell
        var newColumn = this.columnController.getDisplayedColBefore(gridCell.column);
        // check if end of the row, and if so, go forward a row
        if (!newColumn) {
            newColumn = displayedColumns[displayedColumns.length - 1];
            var rowAbove = this.getRowAbove(gridCell.getGridRow());
            if (utils_1.Utils.missing(rowAbove)) {
                return;
            }
            newRowIndex = rowAbove.rowIndex;
            newFloating = rowAbove.floating;
        }
        return new gridCell_1.GridCell(newRowIndex, newFloating, newColumn);
    };
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], CellNavigationService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], CellNavigationService.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('floatingRowModel'), 
        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
    ], CellNavigationService.prototype, "floatingRowModel", void 0);
    CellNavigationService = __decorate([
        context_1.Bean('cellNavigationService'), 
        __metadata('design:paramtypes', [])
    ], CellNavigationService);
    return CellNavigationService;
})();
exports.CellNavigationService = CellNavigationService;

},{"./columnController/columnController":77,"./constants":86,"./context/context":87,"./entities/gridCell":94,"./entities/gridRow":95,"./rowControllers/floatingRowModel":145,"./utils":156}],74:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var grid_1 = require("./grid");
var gridApi_1 = require("./gridApi");
var events_1 = require("./events");
var componentUtil_1 = require("./components/componentUtil");
var columnController_1 = require("./columnController/columnController");
var agGridNg1_1 = require("./components/agGridNg1");
var agGridWebComponent_1 = require("./components/agGridWebComponent");
var gridCell_1 = require("./entities/gridCell");
var rowNode_1 = require("./entities/rowNode");
var originalColumnGroup_1 = require("./entities/originalColumnGroup");
var columnGroup_1 = require("./entities/columnGroup");
var column_1 = require("./entities/column");
var focusedCellController_1 = require("./focusedCellController");
var functions_1 = require("./functions");
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var balancedColumnTreeBuilder_1 = require("./columnController/balancedColumnTreeBuilder");
var columnKeyCreator_1 = require("./columnController/columnKeyCreator");
var columnUtils_1 = require("./columnController/columnUtils");
var displayedGroupCreator_1 = require("./columnController/displayedGroupCreator");
var groupInstanceIdCreator_1 = require("./columnController/groupInstanceIdCreator");
var context_1 = require("./context/context");
var dragAndDropService_1 = require("./dragAndDrop/dragAndDropService");
var dragService_1 = require("./dragAndDrop/dragService");
var filterManager_1 = require("./filter/filterManager");
var numberFilter_1 = require("./filter/numberFilter");
var textFilter_1 = require("./filter/textFilter");
var gridPanel_1 = require("./gridPanel/gridPanel");
var mouseEventService_1 = require("./gridPanel/mouseEventService");
var cssClassApplier_1 = require("./headerRendering/cssClassApplier");
var headerContainer_1 = require("./headerRendering/headerContainer");
var headerRenderer_1 = require("./headerRendering/headerRenderer");
var headerTemplateLoader_1 = require("./headerRendering/headerTemplateLoader");
var horizontalDragService_1 = require("./headerRendering/horizontalDragService");
var moveColumnController_1 = require("./headerRendering/moveColumnController");
var renderedHeaderCell_1 = require("./headerRendering/renderedHeaderCell");
var renderedHeaderGroupCell_1 = require("./headerRendering/renderedHeaderGroupCell");
var standardMenu_1 = require("./headerRendering/standardMenu");
var borderLayout_1 = require("./layout/borderLayout");
var tabbedLayout_1 = require("./layout/tabbedLayout");
var verticalStack_1 = require("./layout/verticalStack");
var autoWidthCalculator_1 = require("./rendering/autoWidthCalculator");
var renderedRow_1 = require("./rendering/renderedRow");
var rowRenderer_1 = require("./rendering/rowRenderer");
var filterStage_1 = require("./rowControllers/inMemory/filterStage");
var flattenStage_1 = require("./rowControllers/inMemory/flattenStage");
var sortStage_1 = require("./rowControllers/inMemory/sortStage");
var floatingRowModel_1 = require("./rowControllers/floatingRowModel");
var paginationController_1 = require("./rowControllers/paginationController");
var component_1 = require("./widgets/component");
var menuList_1 = require("./widgets/menuList");
var cellNavigationService_1 = require("./cellNavigationService");
var columnChangeEvent_1 = require("./columnChangeEvent");
var constants_1 = require("./constants");
var csvCreator_1 = require("./csvCreator");
var eventService_1 = require("./eventService");
var expressionService_1 = require("./expressionService");
var gridCore_1 = require("./gridCore");
var logger_1 = require("./logger");
var masterSlaveService_1 = require("./masterSlaveService");
var selectionController_1 = require("./selectionController");
var sortController_1 = require("./sortController");
var svgFactory_1 = require("./svgFactory");
var templateService_1 = require("./templateService");
var utils_1 = require("./utils");
var valueService_1 = require("./valueService");
var popupService_1 = require("./widgets/popupService");
var gridRow_1 = require("./entities/gridRow");
var inMemoryRowModel_1 = require("./rowControllers/inMemory/inMemoryRowModel");
var virtualPageRowModel_1 = require("./rowControllers/virtualPageRowModel");
var menuItemComponent_1 = require("./widgets/menuItemComponent");
var animateSlideCellRenderer_1 = require("./rendering/cellRenderers/animateSlideCellRenderer");
var cellEditorFactory_1 = require("./rendering/cellEditorFactory");
var popupEditorWrapper_1 = require("./rendering/cellEditors/popupEditorWrapper");
var popupSelectCellEditor_1 = require("./rendering/cellEditors/popupSelectCellEditor");
var popupTextCellEditor_1 = require("./rendering/cellEditors/popupTextCellEditor");
var selectCellEditor_1 = require("./rendering/cellEditors/selectCellEditor");
var textCellEditor_1 = require("./rendering/cellEditors/textCellEditor");
var cellRendererFactory_1 = require("./rendering/cellRendererFactory");
var groupCellRenderer_1 = require("./rendering/cellRenderers/groupCellRenderer");
var cellRendererService_1 = require("./rendering/cellRendererService");
var valueFormatterService_1 = require("./rendering/valueFormatterService");
var dateCellEditor_1 = require("./rendering/cellEditors/dateCellEditor");
var checkboxSelectionComponent_1 = require("./rendering/checkboxSelectionComponent");
var pivotService_1 = require("./columnController/pivotService");
function populateClientExports(exports) {
    // columnController
    exports.BalancedColumnTreeBuilder = balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder;
    exports.ColumnController = columnController_1.ColumnController;
    exports.ColumnKeyCreator = columnKeyCreator_1.ColumnKeyCreator;
    exports.ColumnUtils = columnUtils_1.ColumnUtils;
    exports.DisplayedGroupCreator = displayedGroupCreator_1.DisplayedGroupCreator;
    exports.GroupInstanceIdCreator = groupInstanceIdCreator_1.GroupInstanceIdCreator;
    exports.PivotService = pivotService_1.PivotService;
    // components
    exports.ComponentUtil = componentUtil_1.ComponentUtil;
    exports.initialiseAgGridWithAngular1 = agGridNg1_1.initialiseAgGridWithAngular1;
    exports.initialiseAgGridWithWebComponents = agGridWebComponent_1.initialiseAgGridWithWebComponents;
    // context
    exports.Context = context_1.Context;
    exports.Autowired = context_1.Autowired;
    exports.PostConstruct = context_1.PostConstruct;
    exports.PreDestroy = context_1.PreDestroy;
    exports.Optional = context_1.Optional;
    exports.Bean = context_1.Bean;
    exports.Qualifier = context_1.Qualifier;
    // dragAndDrop
    exports.DragAndDropService = dragAndDropService_1.DragAndDropService;
    exports.DragService = dragService_1.DragService;
    // entities
    exports.Column = column_1.Column;
    exports.ColumnGroup = columnGroup_1.ColumnGroup;
    exports.GridCell = gridCell_1.GridCell;
    exports.GridRow = gridRow_1.GridRow;
    exports.OriginalColumnGroup = originalColumnGroup_1.OriginalColumnGroup;
    exports.RowNode = rowNode_1.RowNode;
    // filter
    exports.FilterManager = filterManager_1.FilterManager;
    exports.NumberFilter = numberFilter_1.NumberFilter;
    exports.TextFilter = textFilter_1.TextFilter;
    // gridPanel
    exports.GridPanel = gridPanel_1.GridPanel;
    exports.MouseEventService = mouseEventService_1.MouseEventService;
    // headerRendering
    exports.CssClassApplier = cssClassApplier_1.CssClassApplier;
    exports.HeaderContainer = headerContainer_1.HeaderContainer;
    exports.HeaderRenderer = headerRenderer_1.HeaderRenderer;
    exports.HeaderTemplateLoader = headerTemplateLoader_1.HeaderTemplateLoader;
    exports.HorizontalDragService = horizontalDragService_1.HorizontalDragService;
    exports.MoveColumnController = moveColumnController_1.MoveColumnController;
    exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
    exports.RenderedHeaderGroupCell = renderedHeaderGroupCell_1.RenderedHeaderGroupCell;
    exports.StandardMenuFactory = standardMenu_1.StandardMenuFactory;
    // layout
    exports.BorderLayout = borderLayout_1.BorderLayout;
    exports.TabbedLayout = tabbedLayout_1.TabbedLayout;
    exports.VerticalStack = verticalStack_1.VerticalStack;
    // rendering / cellEditors
    exports.DateCellEditor = dateCellEditor_1.DateCellEditor;
    exports.PopupEditorWrapper = popupEditorWrapper_1.PopupEditorWrapper;
    exports.PopupSelectCellEditor = popupSelectCellEditor_1.PopupSelectCellEditor;
    exports.PopupTextCellEditor = popupTextCellEditor_1.PopupTextCellEditor;
    exports.SelectCellEditor = selectCellEditor_1.SelectCellEditor;
    exports.TextCellEditor = textCellEditor_1.TextCellEditor;
    // rendering / cellRenderers
    exports.AnimateSlideCellRenderer = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
    exports.GroupCellRenderer = groupCellRenderer_1.GroupCellRenderer;
    // rendering
    exports.AutoWidthCalculator = autoWidthCalculator_1.AutoWidthCalculator;
    exports.CellEditorFactory = cellEditorFactory_1.CellEditorFactory;
    exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
    exports.CellRendererFactory = cellRendererFactory_1.CellRendererFactory;
    exports.CellRendererService = cellRendererService_1.CellRendererService;
    exports.RenderedRow = renderedRow_1.RenderedRow;
    exports.RowRenderer = rowRenderer_1.RowRenderer;
    exports.ValueFormatterService = valueFormatterService_1.ValueFormatterService;
    // rowControllers/inMemory
    exports.FilterStage = filterStage_1.FilterStage;
    exports.FlattenStage = flattenStage_1.FlattenStage;
    exports.InMemoryRowModel = inMemoryRowModel_1.InMemoryRowModel;
    exports.SortStage = sortStage_1.SortStage;
    // rowControllers
    exports.FloatingRowModel = floatingRowModel_1.FloatingRowModel;
    exports.PaginationController = paginationController_1.PaginationController;
    exports.VirtualPageRowModel = virtualPageRowModel_1.VirtualPageRowModel;
    // widgets
    exports.PopupService = popupService_1.PopupService;
    exports.MenuItemComponent = menuItemComponent_1.MenuItemComponent;
    exports.Component = component_1.Component;
    exports.MenuList = menuList_1.MenuList;
    // root
    exports.CellNavigationService = cellNavigationService_1.CellNavigationService;
    exports.ColumnChangeEvent = columnChangeEvent_1.ColumnChangeEvent;
    exports.Constants = constants_1.Constants;
    exports.CsvCreator = csvCreator_1.CsvCreator;
    exports.Events = events_1.Events;
    exports.EventService = eventService_1.EventService;
    exports.ExpressionService = expressionService_1.ExpressionService;
    exports.FocusedCellController = focusedCellController_1.FocusedCellController;
    exports.defaultGroupComparator = functions_1.defaultGroupComparator;
    exports.Grid = grid_1.Grid;
    exports.GridApi = gridApi_1.GridApi;
    exports.GridCore = gridCore_1.GridCore;
    exports.GridOptionsWrapper = gridOptionsWrapper_1.GridOptionsWrapper;
    exports.Logger = logger_1.Logger;
    exports.MasterSlaveService = masterSlaveService_1.MasterSlaveService;
    exports.SelectionController = selectionController_1.SelectionController;
    exports.CheckboxSelectionComponent = checkboxSelectionComponent_1.CheckboxSelectionComponent;
    exports.SortController = sortController_1.SortController;
    exports.SvgFactory = svgFactory_1.SvgFactory;
    exports.TemplateService = templateService_1.TemplateService;
    exports.Utils = utils_1.Utils;
    exports.ValueService = valueService_1.ValueService;
}
exports.populateClientExports = populateClientExports;

},{"./cellNavigationService":73,"./columnChangeEvent":75,"./columnController/balancedColumnTreeBuilder":76,"./columnController/columnController":77,"./columnController/columnKeyCreator":78,"./columnController/columnUtils":79,"./columnController/displayedGroupCreator":80,"./columnController/groupInstanceIdCreator":81,"./columnController/pivotService":82,"./components/agGridNg1":83,"./components/agGridWebComponent":84,"./components/componentUtil":85,"./constants":86,"./context/context":87,"./csvCreator":88,"./dragAndDrop/dragAndDropService":89,"./dragAndDrop/dragService":90,"./entities/column":92,"./entities/columnGroup":93,"./entities/gridCell":94,"./entities/gridRow":95,"./entities/originalColumnGroup":96,"./entities/rowNode":97,"./eventService":98,"./events":99,"./expressionService":100,"./filter/filterManager":101,"./filter/numberFilter":102,"./filter/textFilter":103,"./focusedCellController":104,"./functions":105,"./grid":106,"./gridApi":107,"./gridCore":108,"./gridOptionsWrapper":109,"./gridPanel/gridPanel":110,"./gridPanel/mouseEventService":111,"./headerRendering/cssClassApplier":112,"./headerRendering/headerContainer":113,"./headerRendering/headerRenderer":114,"./headerRendering/headerTemplateLoader":115,"./headerRendering/horizontalDragService":116,"./headerRendering/moveColumnController":117,"./headerRendering/renderedHeaderCell":118,"./headerRendering/renderedHeaderGroupCell":119,"./headerRendering/standardMenu":120,"./layout/borderLayout":121,"./layout/tabbedLayout":122,"./layout/verticalStack":123,"./logger":124,"./masterSlaveService":125,"./rendering/autoWidthCalculator":127,"./rendering/cellEditorFactory":128,"./rendering/cellEditors/dateCellEditor":129,"./rendering/cellEditors/popupEditorWrapper":130,"./rendering/cellEditors/popupSelectCellEditor":131,"./rendering/cellEditors/popupTextCellEditor":132,"./rendering/cellEditors/selectCellEditor":133,"./rendering/cellEditors/textCellEditor":134,"./rendering/cellRendererFactory":135,"./rendering/cellRendererService":136,"./rendering/cellRenderers/animateSlideCellRenderer":138,"./rendering/cellRenderers/groupCellRenderer":139,"./rendering/checkboxSelectionComponent":140,"./rendering/renderedRow":142,"./rendering/rowRenderer":143,"./rendering/valueFormatterService":144,"./rowControllers/floatingRowModel":145,"./rowControllers/inMemory/filterStage":146,"./rowControllers/inMemory/flattenStage":147,"./rowControllers/inMemory/inMemoryRowModel":148,"./rowControllers/inMemory/sortStage":149,"./rowControllers/paginationController":150,"./rowControllers/virtualPageRowModel":151,"./selectionController":152,"./sortController":153,"./svgFactory":154,"./templateService":155,"./utils":156,"./valueService":157,"./widgets/component":158,"./widgets/menuItemComponent":159,"./widgets/menuList":160,"./widgets/popupService":161}],75:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var events_1 = require("./events");
var ColumnChangeEvent = (function () {
    function ColumnChangeEvent(type) {
        this.type = type;
    }
    ColumnChangeEvent.prototype.toString = function () {
        var result = 'ColumnChangeEvent {type: ' + this.type;
        if (this.column) {
            result += ', column: ' + this.column.getColId();
        }
        if (this.columnGroup) {
            result += ', columnGroup: ' + this.columnGroup.getColGroupDef() ? this.columnGroup.getColGroupDef().headerName : '(not defined]';
        }
        if (this.toIndex) {
            result += ', toIndex: ' + this.toIndex;
        }
        if (this.visible) {
            result += ', visible: ' + this.visible;
        }
        if (this.pinned) {
            result += ', pinned: ' + this.pinned;
        }
        if (typeof this.finished == 'boolean') {
            result += ', finished: ' + this.finished;
        }
        result += '}';
        return result;
    };
    ColumnChangeEvent.prototype.withPinned = function (pinned) {
        this.pinned = pinned;
        return this;
    };
    ColumnChangeEvent.prototype.withVisible = function (visible) {
        this.visible = visible;
        return this;
    };
    ColumnChangeEvent.prototype.isVisible = function () {
        return this.visible;
    };
    ColumnChangeEvent.prototype.getPinned = function () {
        return this.pinned;
    };
    ColumnChangeEvent.prototype.withColumn = function (column) {
        this.column = column;
        return this;
    };
    ColumnChangeEvent.prototype.withColumns = function (columns) {
        this.columns = columns;
        return this;
    };
    ColumnChangeEvent.prototype.withFinished = function (finished) {
        this.finished = finished;
        return this;
    };
    ColumnChangeEvent.prototype.withColumnGroup = function (columnGroup) {
        this.columnGroup = columnGroup;
        return this;
    };
    ColumnChangeEvent.prototype.withToIndex = function (toIndex) {
        this.toIndex = toIndex;
        return this;
    };
    ColumnChangeEvent.prototype.getToIndex = function () {
        return this.toIndex;
    };
    ColumnChangeEvent.prototype.getType = function () {
        return this.type;
    };
    ColumnChangeEvent.prototype.getColumn = function () {
        return this.column;
    };
    ColumnChangeEvent.prototype.getColumns = function () {
        return this.columns;
    };
    ColumnChangeEvent.prototype.getColumnGroup = function () {
        return this.columnGroup;
    };
    ColumnChangeEvent.prototype.isPinnedPanelVisibilityImpacted = function () {
        return this.type === events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED ||
            this.type === events_1.Events.EVENT_COLUMN_GROUP_OPENED ||
            this.type === events_1.Events.EVENT_COLUMN_VISIBLE ||
            this.type === events_1.Events.EVENT_PIVOT_VALUE_CHANGED ||
            this.type === events_1.Events.EVENT_COLUMN_PINNED;
    };
    ColumnChangeEvent.prototype.isContainerWidthImpacted = function () {
        return this.type === events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED ||
            this.type === events_1.Events.EVENT_COLUMN_GROUP_OPENED ||
            this.type === events_1.Events.EVENT_COLUMN_VISIBLE ||
            this.type === events_1.Events.EVENT_COLUMN_RESIZED ||
            this.type === events_1.Events.EVENT_COLUMN_PINNED ||
            this.type === events_1.Events.EVENT_PIVOT_VALUE_CHANGED ||
            this.type === events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED;
    };
    ColumnChangeEvent.prototype.isIndividualColumnResized = function () {
        return this.type === events_1.Events.EVENT_COLUMN_RESIZED && this.column !== undefined && this.column !== null;
    };
    ColumnChangeEvent.prototype.isFinished = function () {
        return this.finished;
    };
    return ColumnChangeEvent;
})();
exports.ColumnChangeEvent = ColumnChangeEvent;

},{"./events":99}],76:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var gridOptionsWrapper_1 = require('../gridOptionsWrapper');
var logger_1 = require('../logger');
var columnUtils_1 = require('../columnController/columnUtils');
var columnKeyCreator_1 = require("./columnKeyCreator");
var originalColumnGroup_1 = require("../entities/originalColumnGroup");
var column_1 = require("../entities/column");
var context_1 = require("../context/context");
var context_2 = require("../context/context");
var context_3 = require("../context/context");
var context_4 = require("../context/context");
// takes in a list of columns, as specified by the column definitions, and returns column groups
var BalancedColumnTreeBuilder = (function () {
    function BalancedColumnTreeBuilder() {
    }
    BalancedColumnTreeBuilder.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
    };
    BalancedColumnTreeBuilder.prototype.createBalancedColumnGroups = function (abstractColDefs) {
        // column key creator dishes out unique column id's in a deterministic way,
        // so if we have two grids (that cold be master/slave) with same column definitions,
        // then this ensures the two grids use identical id's.
        var columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();
        // create am unbalanced tree that maps the provided definitions
        var unbalancedTree = this.recursivelyCreateColumns(abstractColDefs, 0, columnKeyCreator);
        var treeDept = this.findMaxDept(unbalancedTree, 0);
        this.logger.log('Number of levels for grouped columns is ' + treeDept);
        var balancedTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
        this.columnUtils.deptFirstOriginalTreeSearch(balancedTree, function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                child.calculateExpandable();
            }
        });
        return {
            balancedTree: balancedTree,
            treeDept: treeDept
        };
    };
    BalancedColumnTreeBuilder.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {
        var _this = this;
        var result = [];
        // go through each child, for groups, recurse a level deeper,
        // for columns we need to pad
        unbalancedTree.forEach(function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var originalGroup = child;
                var newChildren = _this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);
                originalGroup.setChildren(newChildren);
                result.push(originalGroup);
            }
            else {
                var newChild = child;
                for (var i = columnDept - 1; i >= currentDept; i--) {
                    var newColId = columnKeyCreator.getUniqueKey(null, null);
                    var paddedGroup = new originalColumnGroup_1.OriginalColumnGroup(null, newColId);
                    paddedGroup.setChildren([newChild]);
                    newChild = paddedGroup;
                }
                result.push(newChild);
            }
        });
        return result;
    };
    BalancedColumnTreeBuilder.prototype.findMaxDept = function (treeChildren, dept) {
        var maxDeptThisLevel = dept;
        for (var i = 0; i < treeChildren.length; i++) {
            var abstractColumn = treeChildren[i];
            if (abstractColumn instanceof originalColumnGroup_1.OriginalColumnGroup) {
                var originalGroup = abstractColumn;
                var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
                if (maxDeptThisLevel < newDept) {
                    maxDeptThisLevel = newDept;
                }
            }
        }
        return maxDeptThisLevel;
    };
    BalancedColumnTreeBuilder.prototype.recursivelyCreateColumns = function (abstractColDefs, level, columnKeyCreator) {
        var _this = this;
        var result = [];
        if (!abstractColDefs) {
            return result;
        }
        abstractColDefs.forEach(function (abstractColDef) {
            _this.checkForDeprecatedItems(abstractColDef);
            if (_this.isColumnGroup(abstractColDef)) {
                var groupColDef = abstractColDef;
                var groupId = columnKeyCreator.getUniqueKey(groupColDef.groupId, null);
                var originalGroup = new originalColumnGroup_1.OriginalColumnGroup(groupColDef, groupId);
                var children = _this.recursivelyCreateColumns(groupColDef.children, level + 1, columnKeyCreator);
                originalGroup.setChildren(children);
                result.push(originalGroup);
            }
            else {
                var colDef = abstractColDef;
                var colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
                var column = new column_1.Column(colDef, colId);
                _this.context.wireBean(column);
                result.push(column);
            }
        });
        return result;
    };
    BalancedColumnTreeBuilder.prototype.checkForDeprecatedItems = function (colDef) {
        if (colDef) {
            var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type
            if (colDefNoType.group !== undefined) {
                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');
            }
            if (colDefNoType.headerGroup !== undefined) {
                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');
            }
            if (colDefNoType.headerGroupShow !== undefined) {
                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');
            }
        }
    };
    // if object has children, we assume it's a group
    BalancedColumnTreeBuilder.prototype.isColumnGroup = function (abstractColDef) {
        return abstractColDef.children !== undefined;
    };
    __decorate([
        context_3.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], BalancedColumnTreeBuilder.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_3.Autowired('columnUtils'), 
        __metadata('design:type', columnUtils_1.ColumnUtils)
    ], BalancedColumnTreeBuilder.prototype, "columnUtils", void 0);
    __decorate([
        context_3.Autowired('context'), 
        __metadata('design:type', context_4.Context)
    ], BalancedColumnTreeBuilder.prototype, "context", void 0);
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], BalancedColumnTreeBuilder.prototype, "setBeans", null);
    BalancedColumnTreeBuilder = __decorate([
        context_1.Bean('balancedColumnTreeBuilder'), 
        __metadata('design:paramtypes', [])
    ], BalancedColumnTreeBuilder);
    return BalancedColumnTreeBuilder;
})();
exports.BalancedColumnTreeBuilder = BalancedColumnTreeBuilder;

},{"../columnController/columnUtils":79,"../context/context":87,"../entities/column":92,"../entities/originalColumnGroup":96,"../gridOptionsWrapper":109,"../logger":124,"./columnKeyCreator":78}],77:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var utils_1 = require("../utils");
var columnGroup_1 = require("../entities/columnGroup");
var column_1 = require("../entities/column");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var expressionService_1 = require("../expressionService");
var balancedColumnTreeBuilder_1 = require("./balancedColumnTreeBuilder");
var displayedGroupCreator_1 = require("./displayedGroupCreator");
var autoWidthCalculator_1 = require("../rendering/autoWidthCalculator");
var eventService_1 = require("../eventService");
var columnUtils_1 = require("./columnUtils");
var logger_1 = require("../logger");
var events_1 = require("../events");
var columnChangeEvent_1 = require("../columnChangeEvent");
var originalColumnGroup_1 = require("../entities/originalColumnGroup");
var groupInstanceIdCreator_1 = require("./groupInstanceIdCreator");
var functions_1 = require("../functions");
var context_1 = require("../context/context");
var gridPanel_1 = require("../gridPanel/gridPanel");
var pivotService_1 = require("./pivotService");
var ColumnApi = (function () {
    function ColumnApi() {
    }
    ColumnApi.prototype.sizeColumnsToFit = function (gridWidth) { this._columnController.sizeColumnsToFit(gridWidth); };
    ColumnApi.prototype.setColumnGroupOpened = function (group, newValue, instanceId) { this._columnController.setColumnGroupOpened(group, newValue, instanceId); };
    ColumnApi.prototype.getColumnGroup = function (name, instanceId) { return this._columnController.getColumnGroup(name, instanceId); };
    ColumnApi.prototype.getDisplayNameForCol = function (column) { return this._columnController.getDisplayNameForCol(column); };
    ColumnApi.prototype.getColumn = function (key) { return this._columnController.getOriginalColumn(key); };
    ColumnApi.prototype.setColumnState = function (columnState) { return this._columnController.setColumnState(columnState); };
    ColumnApi.prototype.getColumnState = function () { return this._columnController.getColumnState(); };
    ColumnApi.prototype.resetColumnState = function () { this._columnController.resetColumnState(); };
    ColumnApi.prototype.isPinning = function () { return this._columnController.isPinningLeft() || this._columnController.isPinningRight(); };
    ColumnApi.prototype.isPinningLeft = function () { return this._columnController.isPinningLeft(); };
    ColumnApi.prototype.isPinningRight = function () { return this._columnController.isPinningRight(); };
    ColumnApi.prototype.getDisplayedColAfter = function (col) { return this._columnController.getDisplayedColAfter(col); };
    ColumnApi.prototype.getDisplayedColBefore = function (col) { return this._columnController.getDisplayedColBefore(col); };
    ColumnApi.prototype.setColumnVisible = function (key, visible) { this._columnController.setColumnVisible(key, visible); };
    ColumnApi.prototype.setColumnsVisible = function (keys, visible) { this._columnController.setColumnsVisible(keys, visible); };
    ColumnApi.prototype.setColumnPinned = function (key, pinned) { this._columnController.setColumnPinned(key, pinned); };
    ColumnApi.prototype.setColumnsPinned = function (keys, pinned) { this._columnController.setColumnsPinned(keys, pinned); };
    ColumnApi.prototype.getAllColumns = function () { return this._columnController.getAllOriginalColumns(); };
    ColumnApi.prototype.getDisplayedLeftColumns = function () { return this._columnController.getDisplayedLeftColumns(); };
    ColumnApi.prototype.getDisplayedCenterColumns = function () { return this._columnController.getDisplayedCenterColumns(); };
    ColumnApi.prototype.getDisplayedRightColumns = function () { return this._columnController.getDisplayedRightColumns(); };
    ColumnApi.prototype.getAllDisplayedColumns = function () { return this._columnController.getAllDisplayedColumns(); };
    ColumnApi.prototype.getRowGroupColumns = function () { return this._columnController.getRowGroupColumns(); };
    ColumnApi.prototype.getValueColumns = function () { return this._columnController.getValueColumns(); };
    ColumnApi.prototype.moveColumn = function (fromIndex, toIndex) { this._columnController.moveColumnByIndex(fromIndex, toIndex); };
    ColumnApi.prototype.moveRowGroupColumn = function (fromIndex, toIndex) { this._columnController.moveRowGroupColumn(fromIndex, toIndex); };
    ColumnApi.prototype.setColumnAggFunction = function (column, aggFunc) { this._columnController.setColumnAggFunction(column, aggFunc); };
    ColumnApi.prototype.setColumnWidth = function (key, newWidth, finished) {
        if (finished === void 0) { finished = true; }
        this._columnController.setColumnWidth(key, newWidth, finished);
    };
    ColumnApi.prototype.removeValueColumn = function (column) { this._columnController.removeValueColumn(column); };
    ColumnApi.prototype.addValueColumn = function (column) { this._columnController.addValueColumn(column); };
    ColumnApi.prototype.setRowGroupColumns = function (colKeys) { this._columnController.setRowGroupColumns(colKeys); };
    ColumnApi.prototype.removeRowGroupColumn = function (colKey) { this._columnController.removeRowGroupColumn(colKey); };
    ColumnApi.prototype.removeRowGroupColumns = function (colKeys) { this._columnController.removeRowGroupColumns(colKeys); };
    ColumnApi.prototype.addRowGroupColumn = function (colKey) { this._columnController.addRowGroupColumn(colKey); };
    ColumnApi.prototype.addRowGroupColumns = function (colKeys) { this._columnController.addRowGroupColumns(colKeys); };
    ColumnApi.prototype.setPivotColumns = function (colKeys) { this._columnController.setPivotColumns(colKeys); };
    ColumnApi.prototype.removePivotColumn = function (colKey) { this._columnController.removePivotColumn(colKey); };
    ColumnApi.prototype.removePivotColumns = function (colKeys) { this._columnController.removePivotColumns(colKeys); };
    ColumnApi.prototype.addPivotColumn = function (colKey) { this._columnController.addPivotColumn(colKey); };
    ColumnApi.prototype.addPivotColumns = function (colKeys) { this._columnController.addPivotColumns(colKeys); };
    ColumnApi.prototype.getLeftDisplayedColumnGroups = function () { return this._columnController.getLeftDisplayedColumnGroups(); };
    ColumnApi.prototype.getCenterDisplayedColumnGroups = function () { return this._columnController.getCenterDisplayedColumnGroups(); };
    ColumnApi.prototype.getRightDisplayedColumnGroups = function () { return this._columnController.getRightDisplayedColumnGroups(); };
    ColumnApi.prototype.getAllDisplayedColumnGroups = function () { return this._columnController.getAllDisplayedColumnGroups(); };
    ColumnApi.prototype.autoSizeColumn = function (key) { return this._columnController.autoSizeColumn(key); };
    ColumnApi.prototype.autoSizeColumns = function (keys) { return this._columnController.autoSizeColumns(keys); };
    ColumnApi.prototype.columnGroupOpened = function (group, newValue) {
        console.error('ag-Grid: columnGroupOpened no longer exists, use setColumnGroupOpened');
        this.setColumnGroupOpened(group, newValue);
    };
    ColumnApi.prototype.hideColumns = function (colIds, hide) {
        console.error('ag-Grid: hideColumns is deprecated, use setColumnsVisible');
        this._columnController.setColumnsVisible(colIds, !hide);
    };
    ColumnApi.prototype.hideColumn = function (colId, hide) {
        console.error('ag-Grid: hideColumn is deprecated, use setColumnVisible');
        this._columnController.setColumnVisible(colId, !hide);
    };
    ColumnApi.prototype.setState = function (columnState) {
        console.error('ag-Grid: setState is deprecated, use setColumnState');
        return this.setColumnState(columnState);
    };
    ColumnApi.prototype.getState = function () {
        console.error('ag-Grid: hideColumn is getState, use getColumnState');
        return this.getColumnState();
    };
    ColumnApi.prototype.resetState = function () {
        console.error('ag-Grid: hideColumn is resetState, use resetColumnState');
        this.resetColumnState();
    };
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', ColumnController)
    ], ColumnApi.prototype, "_columnController", void 0);
    ColumnApi = __decorate([
        context_1.Bean('columnApi'), 
        __metadata('design:paramtypes', [])
    ], ColumnApi);
    return ColumnApi;
})();
exports.ColumnApi = ColumnApi;
var ColumnController = (function () {
    function ColumnController() {
        // header row count, based on user provided columns
        this.originalHeaderRowCount = 0;
        // header row count, either above, or based on pivoting if we are pivoting
        this.gridHeaderRowCount = 0;
        // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above
        // displayed trees, however it also takes into account if the groups are open or not.
        this.displayedLeftColumns = [];
        this.displayedRightColumns = [];
        this.displayedCenterColumns = [];
        this.ready = false;
    }
    ColumnController.prototype.init = function () {
        if (this.gridOptionsWrapper.getColumnDefs()) {
            this.setColumnDefs(this.gridOptionsWrapper.getColumnDefs());
        }
        // this.eventService.addEventListener(Events.EVENT_PIVOT_VALUE_CHANGED, this.onPivotValueChanged.bind(this));
    };
    ColumnController.prototype.isReduce = function () {
        return this.pivotColumns.length > 0;
    };
    ColumnController.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('ColumnController');
    };
    ColumnController.prototype.setFirstRightAndLastLeftPinned = function () {
        var lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[this.displayedLeftColumns.length - 1] : null;
        var firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;
        this.originalColumns.forEach(function (column) {
            column.setLastLeftPinned(column === lastLeft);
            column.setFirstRightPinned(column === firstRight);
        });
    };
    ColumnController.prototype.autoSizeColumns = function (keys) {
        var _this = this;
        this.actionOnColumns(keys, function (column) {
            var requiredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column);
            if (requiredWidth > 0) {
                var newWidth = _this.normaliseColumnWidth(column, requiredWidth);
                column.setActualWidth(newWidth);
            }
        }, function () {
            return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withFinished(true);
        });
    };
    ColumnController.prototype.autoSizeColumn = function (key) {
        this.autoSizeColumns([key]);
    };
    ColumnController.prototype.autoSizeAllColumns = function () {
        var allDisplayedColumns = this.getAllDisplayedColumns();
        this.autoSizeColumns(allDisplayedColumns);
    };
    ColumnController.prototype.getColumnsFromTree = function (rootColumns) {
        var result = [];
        recursiveFindColumns(rootColumns);
        return result;
        function recursiveFindColumns(childColumns) {
            for (var i = 0; i < childColumns.length; i++) {
                var child = childColumns[i];
                if (child instanceof column_1.Column) {
                    result.push(child);
                }
                else if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    recursiveFindColumns(child.getChildren());
                }
            }
        }
    };
    ColumnController.prototype.getAllDisplayedColumnGroups = function () {
        if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {
            return this.displayedLeftColumnTree
                .concat(this.displayedCentreColumnTree)
                .concat(this.displayedRightColumnTree);
        }
        else {
            return null;
        }
    };
    ColumnController.prototype.getOriginalColumnTree = function () {
        return this.originalBalancedTree;
    };
    // + gridPanel -> for resizing the body and setting top margin
    ColumnController.prototype.getHeaderRowCount = function () {
        return this.gridHeaderRowCount;
    };
    // + headerRenderer -> setting pinned body width
    ColumnController.prototype.getLeftDisplayedColumnGroups = function () {
        return this.displayedLeftColumnTree;
    };
    // + headerRenderer -> setting pinned body width
    ColumnController.prototype.getRightDisplayedColumnGroups = function () {
        return this.displayedRightColumnTree;
    };
    // + headerRenderer -> setting pinned body width
    ColumnController.prototype.getCenterDisplayedColumnGroups = function () {
        return this.displayedCentreColumnTree;
    };
    ColumnController.prototype.getDisplayedColumnGroups = function (type) {
        switch (type) {
            case column_1.Column.PINNED_LEFT: return this.getLeftDisplayedColumnGroups();
            case column_1.Column.PINNED_RIGHT: return this.getRightDisplayedColumnGroups();
            default: return this.getCenterDisplayedColumnGroups();
        }
    };
    // gridPanel -> ensureColumnVisible
    ColumnController.prototype.isColumnDisplayed = function (column) {
        return this.getAllDisplayedColumns().indexOf(column) >= 0;
    };
    // + csvCreator
    ColumnController.prototype.getAllDisplayedColumns = function () {
        // order we add the arrays together is important, so the result
        // has the columns left to right, as they appear on the screen.
        return this.displayedLeftColumns
            .concat(this.displayedCenterColumns)
            .concat(this.displayedRightColumns);
    };
    // used by:
    // + angularGrid -> setting pinned body width
    // todo: this needs to be cached
    ColumnController.prototype.getPinnedLeftContainerWidth = function () {
        return this.getWithOfColsInList(this.displayedLeftColumns);
    };
    // todo: this needs to be cached
    ColumnController.prototype.getPinnedRightContainerWidth = function () {
        return this.getWithOfColsInList(this.displayedRightColumns);
    };
    ColumnController.prototype.addRowGroupColumns = function (keys) {
        var _this = this;
        keys.forEach(function (key) {
            var column = _this.getOriginalColumn(key);
            if (column) {
                _this.rowGroupColumns.push(column);
            }
        });
        // because we could be taking out columns, the displayed
        // columns may differ, so need to work out all the columns again.
        // this is why why don't use 'actionOnColumns', as we need to do
        // this before we fire the event
        this.updateModel();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, event);
    };
    ColumnController.prototype.setRowGroupColumns = function (keys) {
        this.rowGroupColumns.length = 0;
        this.addRowGroupColumns(keys);
    };
    ColumnController.prototype.addRowGroupColumn = function (key) {
        this.addRowGroupColumns([key]);
    };
    ColumnController.prototype.removeRowGroupColumns = function (keys) {
        var _this = this;
        keys.forEach(function (key) {
            var column = _this.getOriginalColumn(key);
            if (column) {
                utils_1.Utils.removeFromArray(_this.rowGroupColumns, column);
            }
        });
        this.updateModel();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, event);
    };
    ColumnController.prototype.removeRowGroupColumn = function (key) {
        this.removeRowGroupColumns([key]);
    };
    ColumnController.prototype.addPivotColumns = function (keys) {
        var _this = this;
        keys.forEach(function (key) {
            var column = _this.getOriginalColumn(key);
            if (column) {
                _this.pivotColumns.push(column);
            }
        });
        // as with changing rowGroupColumn, changing the pivot totally changes
        // the columns that are displayed, so we don't use 'actionOnColumns', as 
        // we need to do this before we fire the event
        this.updateModel();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, event);
    };
    ColumnController.prototype.setPivotColumns = function (keys) {
        this.pivotColumns.length = 0;
        this.addPivotColumns(keys);
    };
    ColumnController.prototype.addPivotColumn = function (key) {
        this.addPivotColumns([key]);
    };
    ColumnController.prototype.removePivotColumns = function (keys) {
        var _this = this;
        keys.forEach(function (key) {
            var column = _this.getOriginalColumn(key);
            if (column) {
                utils_1.Utils.removeFromArray(_this.pivotColumns, column);
            }
        });
        this.updateModel();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, event);
    };
    ColumnController.prototype.removePivotColumn = function (key) {
        this.removePivotColumns([key]);
    };
    ColumnController.prototype.addValueColumn = function (column) {
        if (this.originalColumns.indexOf(column) < 0) {
            console.warn('not a valid column: ' + column);
            return;
        }
        if (this.valueColumns.indexOf(column) >= 0) {
            console.warn('column is already a value column');
            return;
        }
        if (!column.getAggFunc()) {
            column.setAggFunc(column_1.Column.AGG_SUM);
        }
        this.valueColumns.push(column);
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, event);
    };
    ColumnController.prototype.removeValueColumn = function (column) {
        if (this.valueColumns.indexOf(column) < 0) {
            console.warn('column not a value');
            return;
        }
        utils_1.Utils.removeFromArray(this.valueColumns, column);
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, event);
    };
    // returns the width we can set to this col, taking into consideration min and max widths
    ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {
        if (newWidth < column.getMinWidth()) {
            newWidth = column.getMinWidth();
        }
        if (column.isGreaterThanMax(newWidth)) {
            newWidth = column.getMaxWidth();
        }
        return newWidth;
    };
    ColumnController.prototype.setColumnWidth = function (key, newWidth, finished) {
        var column = this.getOriginalColumn(key);
        if (!column) {
            return;
        }
        newWidth = this.normaliseColumnWidth(column, newWidth);
        var widthChanged = column.getActualWidth() !== newWidth;
        if (widthChanged) {
            column.setActualWidth(newWidth);
            this.setLeftValues();
        }
        // check for change first, to avoid unnecessary firing of events
        // however we always fire 'finished' events. this is important
        // when groups are resized, as if the group is changing slowly,
        // eg 1 pixel at a time, then each change will fire change events
        // in all the columns in the group, but only one with get the pixel.
        if (finished || widthChanged) {
            var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withColumn(column).withFinished(finished);
            this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_RESIZED, event);
        }
    };
    ColumnController.prototype.setColumnAggFunction = function (column, aggFunc) {
        column.setAggFunc(aggFunc);
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, event);
    };
    ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex) {
        var column = this.rowGroupColumns[fromIndex];
        this.rowGroupColumns.splice(fromIndex, 1);
        this.rowGroupColumns.splice(toIndex, 0, column);
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, event);
    };
    ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex) {
        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {
            console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);
            console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');
            return;
        }
        // we want to pull all the columns out first and put them into an ordered list
        var columnsToMove = this.getGridColumns(columnsToMoveKeys);
        var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);
        if (failedRules) {
            return;
        }
        this.gridPanel.turnOnAnimationForABit();
        utils_1.Utils.moveInArray(this.gridColumns, columnsToMove, toIndex);
        this.updateModel();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_MOVED)
            .withToIndex(toIndex)
            .withColumns(columnsToMove);
        if (columnsToMove.length === 1) {
            event.withColumn(columnsToMove[0]);
        }
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_MOVED, event);
    };
    ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {
        var allColumnsCopy = this.gridColumns.slice();
        utils_1.Utils.moveInArray(allColumnsCopy, columnsToMove, toIndex);
        // look for broken groups, ie stray columns from groups that should be married
        for (var index = 0; index < (allColumnsCopy.length - 1); index++) {
            var thisColumn = allColumnsCopy[index];
            var nextColumn = allColumnsCopy[index + 1];
            // skip hidden columns
            if (!nextColumn.isVisible()) {
                continue;
            }
            var thisPath = this.columnUtils.getOriginalPathForColumn(thisColumn, this.gridBalancedTree);
            var nextPath = this.columnUtils.getOriginalPathForColumn(nextColumn, this.gridBalancedTree);
            if (!nextPath || !thisPath) {
                console.log('next path is missing');
            }
            // start at the top of the path and work down
            for (var dept = 0; dept < thisPath.length; dept++) {
                var thisOriginalGroup = thisPath[dept];
                var nextOriginalGroup = nextPath[dept];
                var lastColInGroup = thisOriginalGroup !== nextOriginalGroup;
                // a runaway is a column from this group that left the group, and the group has it's children marked as married
                var colGroupDef = thisOriginalGroup.getColGroupDef();
                var marryChildren = colGroupDef && colGroupDef.marryChildren;
                var needToCheckForRunaways = lastColInGroup && marryChildren;
                if (needToCheckForRunaways) {
                    for (var tailIndex = index + 1; tailIndex < allColumnsCopy.length; tailIndex++) {
                        var tailColumn = allColumnsCopy[tailIndex];
                        var tailPath = this.columnUtils.getOriginalPathForColumn(tailColumn, this.gridBalancedTree);
                        var tailOriginalGroup = tailPath[dept];
                        if (tailOriginalGroup === thisOriginalGroup) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    };
    ColumnController.prototype.moveColumn = function (key, toIndex) {
        this.moveColumns([key], toIndex);
    };
    ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex) {
        var column = this.originalColumns[fromIndex];
        this.moveColumn(column, toIndex);
    };
    // used by:
    // + angularGrid -> for setting body width
    // + rowController -> setting main row widths (when inserting and resizing)
    // need to cache this
    ColumnController.prototype.getBodyContainerWidth = function () {
        var result = this.getWithOfColsInList(this.displayedCenterColumns);
        return result;
    };
    // + rowController
    ColumnController.prototype.getValueColumns = function () {
        return this.valueColumns ? this.valueColumns : [];
    };
    // + rowController
    ColumnController.prototype.getPivotColumns = function () {
        return this.pivotColumns ? this.pivotColumns : [];
    };
    // + toolPanel
    ColumnController.prototype.getRowGroupColumns = function () {
        return this.rowGroupColumns ? this.rowGroupColumns : [];
    };
    ColumnController.prototype.isColumnRowGrouped = function (column) {
        return this.rowGroupColumns.indexOf(column) >= 0;
    };
    ColumnController.prototype.isColumnPivoted = function (column) {
        return this.pivotColumns.indexOf(column) >= 0;
    };
    // + rowController -> while inserting rows
    ColumnController.prototype.getDisplayedCenterColumns = function () {
        return this.displayedCenterColumns.slice(0);
    };
    // + rowController -> while inserting rows
    ColumnController.prototype.getDisplayedLeftColumns = function () {
        return this.displayedLeftColumns.slice(0);
    };
    ColumnController.prototype.getDisplayedRightColumns = function () {
        return this.displayedRightColumns.slice(0);
    };
    ColumnController.prototype.getDisplayedColumns = function (type) {
        switch (type) {
            case column_1.Column.PINNED_LEFT: return this.getDisplayedLeftColumns();
            case column_1.Column.PINNED_RIGHT: return this.getDisplayedRightColumns();
            default: return this.getDisplayedCenterColumns();
        }
    };
    // used by:
    // + inMemoryRowController -> sorting, building quick filter text
    // + headerRenderer -> sorting (clearing icon)
    ColumnController.prototype.getAllOriginalColumns = function () {
        return this.originalColumns;
    };
    // + moveColumnController
    ColumnController.prototype.getAllGridColumns = function () {
        return this.gridColumns;
    };
    ColumnController.prototype.isEmpty = function () {
        return utils_1.Utils.missingOrEmpty(this.originalColumns);
    };
    ColumnController.prototype.isRowGroupEmpty = function () {
        return utils_1.Utils.missingOrEmpty(this.rowGroupColumns);
    };
    ColumnController.prototype.setColumnVisible = function (key, visible) {
        this.setColumnsVisible([key], visible);
    };
    ColumnController.prototype.setColumnsVisible = function (keys, visible) {
        this.gridPanel.turnOnAnimationForABit();
        this.actionOnColumns(keys, function (column) {
            column.setVisible(visible);
        }, function () {
            return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VISIBLE).withVisible(visible);
        });
    };
    ColumnController.prototype.setColumnPinned = function (key, pinned) {
        this.setColumnsPinned([key], pinned);
    };
    ColumnController.prototype.setColumnsPinned = function (keys, pinned) {
        this.gridPanel.turnOnAnimationForABit();
        var actualPinned;
        if (pinned === true || pinned === column_1.Column.PINNED_LEFT) {
            actualPinned = column_1.Column.PINNED_LEFT;
        }
        else if (pinned === column_1.Column.PINNED_RIGHT) {
            actualPinned = column_1.Column.PINNED_RIGHT;
        }
        else {
            actualPinned = null;
        }
        this.actionOnColumns(keys, function (column) {
            column.setPinned(actualPinned);
        }, function () {
            return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PINNED).withPinned(actualPinned);
        });
    };
    // does an action on a set of columns. provides common functionality for looking up the
    // columns based on key, getting a list of effected columns, and then updated the event
    // with either one column (if it was just one col) or a list of columns
    // used by: autoResize, setVisible, setPinned
    ColumnController.prototype.actionOnColumns = function (keys, action, createEvent) {
        var _this = this;
        if (!keys || keys.length === 0) {
            return;
        }
        var updatedColumns = [];
        keys.forEach(function (key) {
            var column = _this.getGridColumn(key);
            if (!column) {
                return;
            }
            action(column);
            updatedColumns.push(column);
        });
        if (updatedColumns.length === 0) {
            return;
        }
        this.updateModel();
        var event = createEvent();
        event.withColumns(updatedColumns);
        if (updatedColumns.length === 1) {
            event.withColumn(updatedColumns[0]);
        }
        this.eventService.dispatchEvent(event.getType(), event);
    };
    ColumnController.prototype.getDisplayedColBefore = function (col) {
        var allDisplayedColumns = this.getAllDisplayedColumns();
        var oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex > 0) {
            return allDisplayedColumns[oldIndex - 1];
        }
        else {
            return null;
        }
    };
    // used by:
    // + rowRenderer -> for navigation
    ColumnController.prototype.getDisplayedColAfter = function (col) {
        var allDisplayedColumns = this.getAllDisplayedColumns();
        var oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex < (allDisplayedColumns.length - 1)) {
            return allDisplayedColumns[oldIndex + 1];
        }
        else {
            return null;
        }
    };
    ColumnController.prototype.isPinningLeft = function () {
        return this.displayedLeftColumns.length > 0;
    };
    ColumnController.prototype.isPinningRight = function () {
        return this.displayedRightColumns.length > 0;
    };
    ColumnController.prototype.getAllColumnsIncludingAuto = function () {
        var result = this.originalColumns.slice(0);
        if (this.groupAutoColumnActive) {
            result.push(this.groupAutoColumn);
        }
        return result;
    };
    ColumnController.prototype.getColumnState = function () {
        if (!this.gridColumns || this.gridColumns.length < 0) {
            return [];
        }
        var result = [];
        for (var i = 0; i < this.gridColumns.length; i++) {
            var column = this.gridColumns[i];
            var rowGroupIndex = this.rowGroupColumns.indexOf(column);
            var resultItem = {
                colId: column.getColId(),
                hide: !column.isVisible(),
                aggFunc: column.getAggFunc() ? column.getAggFunc() : null,
                width: column.getActualWidth(),
                pinned: column.getPinned(),
                rowGroupIndex: rowGroupIndex >= 0 ? rowGroupIndex : null
            };
            result.push(resultItem);
        }
        return result;
    };
    ColumnController.prototype.resetColumnState = function () {
        // we can't use 'allColumns' as the order might of messed up, so get the original ordered list
        var originalColumns = this.getColumnsFromTree(this.originalBalancedTree);
        var state = [];
        if (originalColumns) {
            originalColumns.forEach(function (column) {
                state.push({
                    colId: column.getColId(),
                    aggFunc: column.getColDef().aggFunc,
                    hide: column.getColDef().hide,
                    pinned: column.getColDef().pinned,
                    rowGroupIndex: column.getColDef().rowGroupIndex,
                    width: column.getColDef().width
                });
            });
        }
        this.setColumnState(state);
    };
    ColumnController.prototype.setColumnState = function (columnState) {
        var _this = this;
        var oldColumnList = this.originalColumns;
        this.originalColumns = [];
        this.rowGroupColumns = [];
        this.valueColumns = [];
        var success = true;
        if (columnState) {
            columnState.forEach(function (stateItem) {
                var oldColumn = utils_1.Utils.find(oldColumnList, 'colId', stateItem.colId);
                if (!oldColumn) {
                    console.warn('ag-grid: column ' + stateItem.colId + ' not found');
                    success = false;
                    return;
                }
                // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true
                oldColumn.setVisible(!stateItem.hide);
                // sets pinned to 'left' or 'right'
                oldColumn.setPinned(stateItem.pinned);
                // if width provided and valid, use it, otherwise stick with the old width
                if (stateItem.width >= _this.gridOptionsWrapper.getMinColWidth()) {
                    oldColumn.setActualWidth(stateItem.width);
                }
                // accept agg func only if valid
                var aggFuncValid = [column_1.Column.AGG_MIN, column_1.Column.AGG_MAX, column_1.Column.AGG_SUM, column_1.Column.AGG_FIRST, column_1.Column.AGG_LAST].indexOf(stateItem.aggFunc) >= 0;
                if (aggFuncValid) {
                    oldColumn.setAggFunc(stateItem.aggFunc);
                    _this.valueColumns.push(oldColumn);
                }
                else {
                    oldColumn.setAggFunc(null);
                }
                // if rowGroup
                if (typeof stateItem.rowGroupIndex === 'number' && stateItem.rowGroupIndex >= 0) {
                    _this.rowGroupColumns.push(oldColumn);
                }
                _this.originalColumns.push(oldColumn);
                oldColumnList.splice(oldColumnList.indexOf(oldColumn), 1);
            });
        }
        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden
        oldColumnList.forEach(function (oldColumn) {
            oldColumn.setVisible(false);
            oldColumn.setAggFunc(null);
            oldColumn.setPinned(null);
            _this.originalColumns.push(oldColumn);
        });
        // sort the row group columns
        this.rowGroupColumns.sort(function (colA, colB) {
            var rowGroupIndexA = -1;
            var rowGroupIndexB = -1;
            for (var i = 0; i < columnState.length; i++) {
                var state = columnState[i];
                if (state.colId === colA.getColId()) {
                    rowGroupIndexA = state.rowGroupIndex;
                }
                if (state.colId === colB.getColId()) {
                    rowGroupIndexB = state.rowGroupIndex;
                }
            }
            return rowGroupIndexA - rowGroupIndexB;
        });
        this.setupGridColumns();
        this.updateModel();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, event);
        return success;
    };
    ColumnController.prototype.getGridColumns = function (keys) {
        return this.getColumns(keys, this.getGridColumn.bind(this));
    };
    ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {
        var foundColumns = [];
        if (keys) {
            keys.forEach(function (key) {
                var column = columnLookupCallback(key);
                if (column) {
                    foundColumns.push(column);
                }
            });
        }
        return foundColumns;
    };
    // used by growGroupPanel
    ColumnController.prototype.getColumnWithValidation = function (key) {
        var column = this.getOriginalColumn(key);
        if (!column) {
            console.warn('ag-Grid: could not find column ' + column);
        }
        return column;
    };
    ColumnController.prototype.getOriginalColumn = function (key) {
        return this.getColumn(key, this.originalColumns);
    };
    ColumnController.prototype.getGridColumn = function (key) {
        return this.getColumn(key, this.gridColumns);
    };
    ColumnController.prototype.getColumn = function (key, columnList) {
        if (!key) {
            return null;
        }
        for (var i = 0; i < columnList.length; i++) {
            if (colMatches(columnList[i])) {
                return columnList[i];
            }
        }
        if (this.groupAutoColumnActive && colMatches(this.groupAutoColumn)) {
            return this.groupAutoColumn;
        }
        function colMatches(column) {
            var columnMatches = column === key;
            var colDefMatches = column.getColDef() === key;
            var idMatches = column.getColId() === key;
            return columnMatches || colDefMatches || idMatches;
        }
        return null;
    };
    ColumnController.prototype.getDisplayNameForCol = function (column) {
        var colDef = column.colDef;
        var headerValueGetter = colDef.headerValueGetter;
        if (headerValueGetter) {
            var params = {
                colDef: colDef,
                api: this.gridOptionsWrapper.getApi(),
                context: this.gridOptionsWrapper.getContext()
            };
            if (typeof headerValueGetter === 'function') {
                // valueGetter is a function, so just call it
                return headerValueGetter(params);
            }
            else if (typeof headerValueGetter === 'string') {
                // valueGetter is an expression, so execute the expression
                return this.expressionService.evaluate(headerValueGetter, params);
            }
            else {
                console.warn('ag-grid: headerValueGetter must be a function or a string');
            }
        }
        else if (colDef.displayName) {
            console.warn("ag-grid: Found displayName " + colDef.displayName + ", please use headerName instead, displayName is deprecated.");
            return colDef.displayName;
        }
        else {
            return colDef.headerName;
        }
    };
    // returns the group with matching colId and instanceId. If instanceId is missing,
    // matches only on the colId.
    ColumnController.prototype.getColumnGroup = function (colId, instanceId) {
        if (!colId) {
            return null;
        }
        if (colId instanceof columnGroup_1.ColumnGroup) {
            return colId;
        }
        var allColumnGroups = this.getAllDisplayedColumnGroups();
        var checkInstanceId = typeof instanceId === 'number';
        var result = null;
        this.columnUtils.deptFirstAllColumnTreeSearch(allColumnGroups, function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                var columnGroup = child;
                var matched;
                if (checkInstanceId) {
                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();
                }
                else {
                    matched = colId === columnGroup.getGroupId();
                }
                if (matched) {
                    result = columnGroup;
                }
            }
        });
        return result;
    };
    ColumnController.prototype.getColumnDept = function () {
        var dept = 0;
        getDept(this.getAllDisplayedColumnGroups(), 1);
        return dept;
        function getDept(children, currentDept) {
            if (dept < currentDept) {
                dept = currentDept;
            }
            if (dept > currentDept) {
                return;
            }
            children.forEach(function (child) {
                if (child instanceof columnGroup_1.ColumnGroup) {
                    var columnGroup = child;
                    getDept(columnGroup.getChildren(), currentDept + 1);
                }
            });
        }
    };
    ColumnController.prototype.setColumnDefs = function (columnDefs) {
        var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(columnDefs);
        this.originalBalancedTree = balancedTreeResult.balancedTree;
        this.originalHeaderRowCount = balancedTreeResult.treeDept + 1;
        this.originalColumns = this.getColumnsFromTree(this.originalBalancedTree);
        this.extractRowGroupColumns();
        this.extractPivotColumns();
        this.createValueColumns();
        this.setupGridColumns();
        this.updateModel();
        this.ready = true;
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, event);
        this.eventService.dispatchEvent(events_1.Events.EVENT_NEW_COLUMNS_LOADED);
    };
    ColumnController.prototype.isReady = function () {
        return this.ready;
    };
    ColumnController.prototype.extractRowGroupColumns = function () {
        var _this = this;
        this.rowGroupColumns = [];
        // pull out the columns
        this.originalColumns.forEach(function (column) {
            if (typeof column.getColDef().rowGroupIndex === 'number') {
                _this.rowGroupColumns.push(column);
            }
        });
        // then sort them
        this.rowGroupColumns.sort(function (colA, colB) {
            return colA.getColDef().rowGroupIndex - colB.getColDef().rowGroupIndex;
        });
    };
    ColumnController.prototype.extractPivotColumns = function () {
        var _this = this;
        this.pivotColumns = [];
        // pull out the columns
        this.originalColumns.forEach(function (column) {
            if (typeof column.getColDef().pivotIndex === 'number') {
                _this.pivotColumns.push(column);
            }
        });
        // then sort them
        this.pivotColumns.sort(function (colA, colB) {
            return colA.getColDef().pivotIndex - colB.getColDef().pivotIndex;
        });
    };
    // called by headerRenderer - when a header is opened or closed
    ColumnController.prototype.setColumnGroupOpened = function (passedGroup, newValue, instanceId) {
        var groupToUse = this.getColumnGroup(passedGroup, instanceId);
        if (!groupToUse) {
            return;
        }
        this.logger.log('columnGroupOpened(' + groupToUse.getGroupId() + ',' + newValue + ')');
        groupToUse.setExpanded(newValue);
        this.gridPanel.turnOnAnimationForABit();
        this.updateGroupsAndDisplayedColumns();
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_GROUP_OPENED).withColumnGroup(groupToUse);
        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_GROUP_OPENED, event);
    };
    // used by updateModel
    ColumnController.prototype.getColumnGroupState = function () {
        var groupState = {};
        this.columnUtils.deptFirstDisplayedColumnTreeSearch(this.getAllDisplayedColumnGroups(), function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                var columnGroup = child;
                var key = columnGroup.getGroupId();
                // if more than one instance of the group, we only record the state of the first item
                if (!groupState.hasOwnProperty(key)) {
                    groupState[key] = columnGroup.isExpanded();
                }
            }
        });
        return groupState;
    };
    // used by updateModel
    ColumnController.prototype.setColumnGroupState = function (groupState) {
        this.columnUtils.deptFirstDisplayedColumnTreeSearch(this.getAllDisplayedColumnGroups(), function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                var columnGroup = child;
                var key = columnGroup.getGroupId();
                var shouldExpandGroup = groupState[key] === true && columnGroup.isExpandable();
                if (shouldExpandGroup) {
                    columnGroup.setExpanded(true);
                }
            }
        });
    };
    ColumnController.prototype.updateModel = function () {
        // save opened / closed state
        var oldGroupState = this.getColumnGroupState();
        this.createGroupAutoColumn();
        var visibleColumns = utils_1.Utils.filter(this.gridColumns, function (column) { return column.isVisible(); });
        if (this.groupAutoColumnActive) {
            visibleColumns.unshift(this.groupAutoColumn);
        }
        this.buildAllGroups(visibleColumns);
        // restore opened / closed state
        this.setColumnGroupState(oldGroupState);
        // this is also called when a group is opened or closed
        this.updateGroupsAndDisplayedColumns();
        this.setFirstRightAndLastLeftPinned();
    };
    ColumnController.prototype.onPivotValueChanged = function () {
        // if we are pivoting, then we need to re-work the pivot columns
        this.setupGridColumns();
        this.updateModel();
        // this.eventService.dispatchEvent(Events.EVENT_PIVOT_VALUE_CHANGED);
        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_PIVOT_VALUE_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_PIVOT_VALUE_CHANGED, event);
    };
    ColumnController.prototype.setupGridColumns = function () {
        var doingPivot = this.pivotColumns.length > 0;
        if (doingPivot) {
            var pivotColumnGroupDefs = this.pivotService.getPivotColumnGroupDefs();
            var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(pivotColumnGroupDefs);
            this.gridBalancedTree = balancedTreeResult.balancedTree;
            this.gridHeaderRowCount = balancedTreeResult.treeDept + 1;
            this.gridColumns = this.getColumnsFromTree(this.gridBalancedTree);
        }
        else {
            this.gridBalancedTree = this.originalBalancedTree.slice();
            this.gridHeaderRowCount = this.originalHeaderRowCount;
            this.gridColumns = this.originalColumns.slice();
        }
    };
    ColumnController.prototype.updateGroupsAndDisplayedColumns = function () {
        this.updateGroups();
        this.updateDisplayedColumnsFromGroups();
    };
    ColumnController.prototype.updateDisplayedColumnsFromGroups = function () {
        this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);
        this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);
        this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);
        this.setLeftValues();
    };
    // sets the left pixel position of each column
    ColumnController.prototype.setLeftValues = function () {
        // go through each list of displayed columns
        var allColumns = this.originalColumns.slice(0);
        [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {
            var left = 0;
            columns.forEach(function (column) {
                column.setLeft(left);
                left += column.getActualWidth();
                utils_1.Utils.removeFromArray(allColumns, column);
            });
        });
        // items left in allColumns are columns not displayed, so remove the left position. this is
        // important for the rows, as if a col is made visible, then taken out, then made visible again,
        // we don't want the animation of the cell floating in from the old position, whatever that was.
        allColumns.forEach(function (column) {
            column.setLeft(null);
        });
    };
    ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {
        displayedColumns.length = 0;
        this.columnUtils.deptFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {
            if (child instanceof column_1.Column) {
                displayedColumns.push(child);
            }
        });
    };
    // called from api
    ColumnController.prototype.sizeColumnsToFit = function (gridWidth) {
        var _this = this;
        // avoid divide by zero
        var allDisplayedColumns = this.getAllDisplayedColumns();
        if (gridWidth <= 0 || allDisplayedColumns.length === 0) {
            return;
        }
        var colsToNotSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
            return column.getColDef().suppressSizeToFit === true;
        });
        var colsToSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
            return column.getColDef().suppressSizeToFit !== true;
        });
        // make a copy of the cols that are going to be resized
        var colsToFireEventFor = colsToSpread.slice(0);
        var finishedResizing = false;
        while (!finishedResizing) {
            finishedResizing = true;
            var availablePixels = gridWidth - getTotalWidth(colsToNotSpread);
            if (availablePixels <= 0) {
                // no width, set everything to minimum
                colsToSpread.forEach(function (column) {
                    column.setMinimum();
                });
            }
            else {
                var scale = availablePixels / getTotalWidth(colsToSpread);
                // we set the pixels for the last col based on what's left, as otherwise
                // we could be a pixel or two short or extra because of rounding errors.
                var pixelsForLastCol = availablePixels;
                // backwards through loop, as we are removing items as we go
                for (var i = colsToSpread.length - 1; i >= 0; i--) {
                    var column = colsToSpread[i];
                    var newWidth = Math.round(column.getActualWidth() * scale);
                    if (newWidth < column.getMinWidth()) {
                        column.setMinimum();
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else if (column.isGreaterThanMax(newWidth)) {
                        column.setActualWidth(column.getMaxWidth());
                        moveToNotSpread(column);
                        finishedResizing = false;
                    }
                    else {
                        var onLastCol = i === 0;
                        if (onLastCol) {
                            column.setActualWidth(pixelsForLastCol);
                        }
                        else {
                            pixelsForLastCol -= newWidth;
                            column.setActualWidth(newWidth);
                        }
                    }
                }
            }
        }
        this.setLeftValues();
        // widths set, refresh the gui
        colsToFireEventFor.forEach(function (column) {
            var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withColumn(column);
            _this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_RESIZED, event);
        });
        function moveToNotSpread(column) {
            utils_1.Utils.removeFromArray(colsToSpread, column);
            colsToNotSpread.push(column);
        }
        function getTotalWidth(columns) {
            var result = 0;
            for (var i = 0; i < columns.length; i++) {
                result += columns[i].getActualWidth();
            }
            return result;
        }
    };
    ColumnController.prototype.buildAllGroups = function (visibleColumns) {
        var leftVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
            return column.getPinned() === 'left';
        });
        var rightVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
            return column.getPinned() === 'right';
        });
        var centerVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
            return column.getPinned() !== 'left' && column.getPinned() !== 'right';
        });
        var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
        this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
        this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
        this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
    };
    ColumnController.prototype.updateGroups = function () {
        var allGroups = this.getAllDisplayedColumnGroups();
        this.columnUtils.deptFirstAllColumnTreeSearch(allGroups, function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                var group = child;
                group.calculateDisplayedColumns();
            }
        });
    };
    ColumnController.prototype.createGroupAutoColumn = function () {
        // see if we need to insert the default grouping column
        var needAGroupColumn = this.rowGroupColumns.length > 0
            && !this.gridOptionsWrapper.isGroupSuppressAutoColumn()
            && !this.gridOptionsWrapper.isGroupUseEntireRow()
            && !this.gridOptionsWrapper.isGroupSuppressRow();
        this.groupAutoColumnActive = needAGroupColumn;
        // lazy create group auto-column
        if (needAGroupColumn && !this.groupAutoColumn) {
            // if one provided by user, use it, otherwise create one
            var autoColDef = this.gridOptionsWrapper.getGroupColumnDef();
            if (!autoColDef) {
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                autoColDef = {
                    headerName: localeTextFunc('group', 'Group'),
                    comparator: functions_1.defaultGroupComparator,
                    valueGetter: function (params) {
                        if (params.node.group) {
                            return params.node.key;
                        }
                        else if (params.data && params.colDef.field) {
                            return params.data[params.colDef.field];
                        }
                        else {
                            return null;
                        }
                    },
                    suppressAggregation: true,
                    suppressRowGroup: true,
                    cellRenderer: 'group'
                };
            }
            // we never allow moving the group column
            autoColDef.suppressMovable = true;
            var colId = 'ag-Grid-AutoColumn';
            this.groupAutoColumn = new column_1.Column(autoColDef, colId);
            this.context.wireBean(this.groupAutoColumn);
        }
    };
    ColumnController.prototype.createValueColumns = function () {
        this.valueColumns = [];
        // override with columns that have the aggFunc specified explicitly
        for (var i = 0; i < this.originalColumns.length; i++) {
            var column = this.originalColumns[i];
            if (column.getColDef().aggFunc) {
                column.setAggFunc(column.getColDef().aggFunc);
                this.valueColumns.push(column);
            }
        }
    };
    ColumnController.prototype.getWithOfColsInList = function (columnList) {
        var result = 0;
        for (var i = 0; i < columnList.length; i++) {
            result += columnList[i].getActualWidth();
        }
        return result;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], ColumnController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'), 
        __metadata('design:type', expressionService_1.ExpressionService)
    ], ColumnController.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('balancedColumnTreeBuilder'), 
        __metadata('design:type', balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder)
    ], ColumnController.prototype, "balancedColumnTreeBuilder", void 0);
    __decorate([
        context_1.Autowired('displayedGroupCreator'), 
        __metadata('design:type', displayedGroupCreator_1.DisplayedGroupCreator)
    ], ColumnController.prototype, "displayedGroupCreator", void 0);
    __decorate([
        context_1.Autowired('autoWidthCalculator'), 
        __metadata('design:type', autoWidthCalculator_1.AutoWidthCalculator)
    ], ColumnController.prototype, "autoWidthCalculator", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], ColumnController.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnUtils'), 
        __metadata('design:type', columnUtils_1.ColumnUtils)
    ], ColumnController.prototype, "columnUtils", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], ColumnController.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], ColumnController.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('pivotService'), 
        __metadata('design:type', pivotService_1.PivotService)
    ], ColumnController.prototype, "pivotService", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], ColumnController.prototype, "init", null);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], ColumnController.prototype, "setBeans", null);
    ColumnController = __decorate([
        context_1.Bean('columnController'), 
        __metadata('design:paramtypes', [])
    ], ColumnController);
    return ColumnController;
})();
exports.ColumnController = ColumnController;

},{"../columnChangeEvent":75,"../context/context":87,"../entities/column":92,"../entities/columnGroup":93,"../entities/originalColumnGroup":96,"../eventService":98,"../events":99,"../expressionService":100,"../functions":105,"../gridOptionsWrapper":109,"../gridPanel/gridPanel":110,"../logger":124,"../rendering/autoWidthCalculator":127,"../utils":156,"./balancedColumnTreeBuilder":76,"./columnUtils":79,"./displayedGroupCreator":80,"./groupInstanceIdCreator":81,"./pivotService":82}],78:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
// class returns a unique id to use for the column. it checks the existing columns, and if the requested
// id is already taken, it will start appending numbers until it gets a unique id.
// eg, if the col field is 'name', it will try ids: {name, name_1, name_2...}
// if no field or id provided in the col, it will try the ids of natural numbers
var ColumnKeyCreator = (function () {
    function ColumnKeyCreator() {
        this.existingKeys = [];
    }
    ColumnKeyCreator.prototype.getUniqueKey = function (colId, colField) {
        var count = 0;
        while (true) {
            var idToTry;
            if (colId) {
                idToTry = colId;
                if (count !== 0) {
                    idToTry += '_' + count;
                }
            }
            else if (colField) {
                idToTry = colField;
                if (count !== 0) {
                    idToTry += '_' + count;
                }
            }
            else {
                idToTry = '' + count;
            }
            if (this.existingKeys.indexOf(idToTry) < 0) {
                this.existingKeys.push(idToTry);
                return idToTry;
            }
            count++;
        }
    };
    return ColumnKeyCreator;
})();
exports.ColumnKeyCreator = ColumnKeyCreator;

},{}],79:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var columnGroup_1 = require("../entities/columnGroup");
var originalColumnGroup_1 = require("../entities/originalColumnGroup");
var context_1 = require("../context/context");
var context_2 = require("../context/context");
// takes in a list of columns, as specified by the column definitions, and returns column groups
var ColumnUtils = (function () {
    function ColumnUtils() {
    }
    ColumnUtils.prototype.calculateColInitialWidth = function (colDef) {
        if (!colDef.width) {
            // if no width defined in colDef, use default
            return this.gridOptionsWrapper.getColWidth();
        }
        else if (colDef.width < this.gridOptionsWrapper.getMinColWidth()) {
            // if width in col def to small, set to min width
            return this.gridOptionsWrapper.getMinColWidth();
        }
        else {
            // otherwise use the provided width
            return colDef.width;
        }
    };
    ColumnUtils.prototype.getOriginalPathForColumn = function (column, originalBalancedTree) {
        var result = [];
        var found = false;
        recursePath(originalBalancedTree, 0);
        // we should always find the path, but in case there is a bug somewhere, returning null
        // will make it fail rather than provide a 'hard to track down' bug
        if (found) {
            return result;
        }
        else {
            return null;
        }
        function recursePath(balancedColumnTree, dept) {
            for (var i = 0; i < balancedColumnTree.length; i++) {
                if (found) {
                    // quit the search, so 'result' is kept with the found result
                    return;
                }
                var node = balancedColumnTree[i];
                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    var nextNode = node;
                    recursePath(nextNode.getChildren(), dept + 1);
                    result[dept] = node;
                }
                else {
                    if (node === column) {
                        found = true;
                    }
                }
            }
        }
    };
    /*    public getPathForColumn(column: Column, allDisplayedColumnGroups: ColumnGroupChild[]): ColumnGroup[] {
            var result: ColumnGroup[] = [];
            var found = false;
    
            recursePath(allDisplayedColumnGroups, 0);
    
            // we should always find the path, but in case there is a bug somewhere, returning null
            // will make it fail rather than provide a 'hard to track down' bug
            if (found) {
                return result;
            } else {
                return null;
            }
    
            function recursePath(balancedColumnTree: ColumnGroupChild[], dept: number): void {
    
                for (var i = 0; i<balancedColumnTree.length; i++) {
                    if (found) {
                        // quit the search, so 'result' is kept with the found result
                        return;
                    }
                    var node = balancedColumnTree[i];
                    if (node instanceof ColumnGroup) {
                        var nextNode = <ColumnGroup> node;
                        recursePath(nextNode.getChildren(), dept+1);
                        result[dept] = node;
                    } else {
                        if (node === column) {
                            found = true;
                        }
                    }
                }
            }
        }*/
    ColumnUtils.prototype.deptFirstOriginalTreeSearch = function (tree, callback) {
        var _this = this;
        if (!tree) {
            return;
        }
        tree.forEach(function (child) {
            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                _this.deptFirstOriginalTreeSearch(child.getChildren(), callback);
            }
            callback(child);
        });
    };
    ColumnUtils.prototype.deptFirstAllColumnTreeSearch = function (tree, callback) {
        var _this = this;
        if (!tree) {
            return;
        }
        tree.forEach(function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                _this.deptFirstAllColumnTreeSearch(child.getChildren(), callback);
            }
            callback(child);
        });
    };
    ColumnUtils.prototype.deptFirstDisplayedColumnTreeSearch = function (tree, callback) {
        var _this = this;
        if (!tree) {
            return;
        }
        tree.forEach(function (child) {
            if (child instanceof columnGroup_1.ColumnGroup) {
                _this.deptFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);
            }
            callback(child);
        });
    };
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], ColumnUtils.prototype, "gridOptionsWrapper", void 0);
    ColumnUtils = __decorate([
        context_1.Bean('columnUtils'), 
        __metadata('design:paramtypes', [])
    ], ColumnUtils);
    return ColumnUtils;
})();
exports.ColumnUtils = ColumnUtils;

},{"../context/context":87,"../entities/columnGroup":93,"../entities/originalColumnGroup":96,"../gridOptionsWrapper":109}],80:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var columnUtils_1 = require("./columnUtils");
var columnGroup_1 = require("../entities/columnGroup");
var originalColumnGroup_1 = require("../entities/originalColumnGroup");
var context_1 = require("../context/context");
var context_2 = require("../context/context");
// takes in a list of columns, as specified by the column definitions, and returns column groups
var DisplayedGroupCreator = (function () {
    function DisplayedGroupCreator() {
    }
    DisplayedGroupCreator.prototype.createDisplayedGroups = function (sortedVisibleColumns, balancedColumnTree, groupInstanceIdCreator) {
        var _this = this;
        var result = [];
        var previousRealPath;
        var previousOriginalPath;
        // go through each column, then do a bottom up comparison to the previous column, and start
        // to share groups if they converge at any point.
        sortedVisibleColumns.forEach(function (currentColumn) {
            var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);
            var currentRealPath = [];
            var firstColumn = !previousOriginalPath;
            for (var i = 0; i < currentOriginalPath.length; i++) {
                if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {
                    // new group needed
                    var originalGroup = currentOriginalPath[i];
                    var groupId = originalGroup.getGroupId();
                    var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
                    var newGroup = new columnGroup_1.ColumnGroup(originalGroup, groupId, instanceId);
                    currentRealPath[i] = newGroup;
                    // if top level, add to result, otherwise add to parent
                    if (i == 0) {
                        result.push(newGroup);
                    }
                    else {
                        currentRealPath[i - 1].addChild(newGroup);
                    }
                }
                else {
                    // reuse old group
                    currentRealPath[i] = previousRealPath[i];
                }
            }
            var noColumnGroups = currentRealPath.length === 0;
            if (noColumnGroups) {
                // if we are not grouping, then the result of the above is an empty
                // path (no groups), and we just add the column to the root list.
                result.push(currentColumn);
            }
            else {
                var leafGroup = currentRealPath[currentRealPath.length - 1];
                leafGroup.addChild(currentColumn);
            }
            previousRealPath = currentRealPath;
            previousOriginalPath = currentOriginalPath;
        });
        return result;
    };
    DisplayedGroupCreator.prototype.createFakePath = function (balancedColumnTree) {
        var result = [];
        var currentChildren = balancedColumnTree;
        // this while look does search on the balanced tree, so our result is the right length
        var index = 0;
        while (currentChildren && currentChildren[0] && currentChildren[0] instanceof originalColumnGroup_1.OriginalColumnGroup) {
            // putting in a deterministic fake id, in case the API in the future needs to reference the col
            result.push(new originalColumnGroup_1.OriginalColumnGroup(null, 'FAKE_PATH_' + index));
            currentChildren = currentChildren[0].getChildren();
            index++;
        }
        return result;
    };
    DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {
        var result = [];
        var found = false;
        recursePath(balancedColumnTree, 0);
        // it's possible we didn't find a path. this happens if the column is generated
        // by the grid, in that the definition didn't come from the client. in this case,
        // we create a fake original path.
        if (found) {
            return result;
        }
        else {
            return this.createFakePath(balancedColumnTree);
        }
        function recursePath(balancedColumnTree, dept) {
            for (var i = 0; i < balancedColumnTree.length; i++) {
                if (found) {
                    // quit the search, so 'result' is kept with the found result
                    return;
                }
                var node = balancedColumnTree[i];
                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    var nextNode = node;
                    recursePath(nextNode.getChildren(), dept + 1);
                    result[dept] = node;
                }
                else {
                    if (node === column) {
                        found = true;
                    }
                }
            }
        }
    };
    __decorate([
        context_2.Autowired('columnUtils'), 
        __metadata('design:type', columnUtils_1.ColumnUtils)
    ], DisplayedGroupCreator.prototype, "columnUtils", void 0);
    DisplayedGroupCreator = __decorate([
        context_1.Bean('displayedGroupCreator'), 
        __metadata('design:paramtypes', [])
    ], DisplayedGroupCreator);
    return DisplayedGroupCreator;
})();
exports.DisplayedGroupCreator = DisplayedGroupCreator;

},{"../context/context":87,"../entities/columnGroup":93,"../entities/originalColumnGroup":96,"./columnUtils":79}],81:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
// class returns unique instance id's for columns.
// eg, the following calls (in this order) will result in:
//
// getInstanceIdForKey('country') => 0
// getInstanceIdForKey('country') => 1
// getInstanceIdForKey('country') => 2
// getInstanceIdForKey('country') => 3
// getInstanceIdForKey('age') => 0
// getInstanceIdForKey('age') => 1
// getInstanceIdForKey('country') => 4
var GroupInstanceIdCreator = (function () {
    function GroupInstanceIdCreator() {
        // this map contains keys to numbers, so we remember what the last call was
        this.existingIds = {};
    }
    GroupInstanceIdCreator.prototype.getInstanceIdForKey = function (key) {
        var lastResult = this.existingIds[key];
        var result;
        if (typeof lastResult !== 'number') {
            // first time this key
            result = 0;
        }
        else {
            result = lastResult + 1;
        }
        this.existingIds[key] = result;
        return result;
    };
    return GroupInstanceIdCreator;
})();
exports.GroupInstanceIdCreator = GroupInstanceIdCreator;

},{}],82:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var valueService_1 = require("../valueService");
var columnController_1 = require("./columnController");
var utils_1 = require("../utils");
var eventService_1 = require("../eventService");
var PivotService = (function () {
    function PivotService() {
    }
    PivotService.prototype.mapRowNode = function (rowNode) {
        var pivotColumns = this.columnController.getPivotColumns();
        if (pivotColumns.length === 0) {
            rowNode.childrenMapped = null;
            return;
        }
        rowNode.childrenMapped = this.mapChildren(rowNode.childrenAfterFilter, pivotColumns, 0, this.uniqueValues);
    };
    PivotService.prototype.getUniqueValues = function () {
        return this.uniqueValues;
    };
    PivotService.prototype.mapChildren = function (children, pivotColumns, pivotIndex, uniqueValues) {
        var _this = this;
        var mappedChildren = {};
        var pivotColumn = pivotColumns[pivotIndex];
        // map the children out based on the pivot column
        children.forEach(function (child) {
            var key = _this.valueService.getValue(pivotColumn, child);
            if (utils_1.Utils.missing(key)) {
                key = '';
            }
            if (!uniqueValues[key]) {
                uniqueValues[key] = {};
            }
            if (!mappedChildren[key]) {
                mappedChildren[key] = [];
            }
            mappedChildren[key].push(child);
        });
        // if it's the last pivot column, return as is, otherwise go one level further in the map
        if (pivotIndex === pivotColumns.length - 1) {
            return mappedChildren;
        }
        else {
            var result = {};
            utils_1.Utils.iterateObject(mappedChildren, function (key, value) {
                result[key] = _this.mapChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);
            });
            return result;
        }
    };
    PivotService.prototype.execute = function (rootNode) {
        this.uniqueValues = {};
        var that = this;
        function findLeafGroups(rowNode) {
            if (rowNode.leafGroup) {
                that.mapRowNode(rowNode);
            }
            else {
                rowNode.childrenAfterFilter.forEach(function (child) {
                    findLeafGroups(child);
                });
            }
        }
        findLeafGroups(rootNode);
        this.createPivotColumnDefs();
        this.columnController.onPivotValueChanged();
    };
    PivotService.prototype.getPivotColumnGroupDefs = function () {
        return this.pivotColumnGroupDefs;
    };
    PivotService.prototype.getPivotColumnDefs = function () {
        return this.pivotColumnDefs;
    };
    PivotService.prototype.createPivotColumnDefs = function () {
        this.pivotColumnGroupDefs = [];
        this.pivotColumnDefs = [];
        var that = this;
        var pivotColumns = this.columnController.getPivotColumns();
        var levelsDeep = pivotColumns.length;
        var columnIdSequence = 0;
        recursivelyAddGroup(this.pivotColumnGroupDefs, 1, this.uniqueValues, []);
        function recursivelyAddGroup(parentChildren, index, uniqueValues, keys) {
            // var column = pivotColumns[index];
            utils_1.Utils.iterateObject(uniqueValues, function (key, value) {
                var newKeys = keys.slice(0);
                newKeys.push(key);
                var createGroup = index !== levelsDeep;
                if (createGroup) {
                    var groupDef = {
                        children: [],
                        headerName: key
                    };
                    parentChildren.push(groupDef);
                    recursivelyAddGroup(groupDef.children, index + 1, value, newKeys);
                }
                else {
                    var valueColumns = that.columnController.getValueColumns();
                    if (valueColumns.length === 1) {
                        var colDef = createColDef(valueColumns[0], key, newKeys);
                        parentChildren.push(colDef);
                        that.pivotColumnDefs.push(colDef);
                    }
                    else {
                        var valueGroup = {
                            children: [],
                            headerName: key
                        };
                        parentChildren.push(valueGroup);
                        valueColumns.forEach(function (valueColumn) {
                            var colDef = createColDef(valueColumn, valueColumn.getColDef().headerName, newKeys);
                            valueGroup.children.push(colDef);
                            that.pivotColumnDefs.push(colDef);
                        });
                    }
                }
            });
        }
        function createColDef(valueColumn, headerName, pivotKeys) {
            var colDef = {};
            if (valueColumn) {
                var colDefToCopy = valueColumn.getColDef();
                utils_1.Utils.assign(colDef, colDefToCopy);
            }
            colDef.valueGetter = null;
            colDef.headerName = headerName;
            colDef.colId = 'pivot_' + columnIdSequence++;
            colDef.keys = pivotKeys;
            colDef.valueColumn = valueColumn;
            return colDef;
        }
    };
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], PivotService.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], PivotService.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], PivotService.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], PivotService.prototype, "eventService", void 0);
    PivotService = __decorate([
        context_1.Bean('pivotService'), 
        __metadata('design:paramtypes', [])
    ], PivotService);
    return PivotService;
})();
exports.PivotService = PivotService;

},{"../context/context":87,"../eventService":98,"../utils":156,"../valueService":157,"./columnController":77}],83:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var grid_1 = require("../grid");
function initialiseAgGridWithAngular1(angular) {
    var angularModule = angular.module("agGrid", []);
    angularModule.directive("agGrid", function () {
        return {
            restrict: "A",
            controller: ['$element', '$scope', '$compile', '$attrs', AngularDirectiveController],
            scope: true
        };
    });
}
exports.initialiseAgGridWithAngular1 = initialiseAgGridWithAngular1;
function AngularDirectiveController($element, $scope, $compile, $attrs) {
    var gridOptions;
    var quickFilterOnScope;
    var keyOfGridInScope = $attrs.agGrid;
    quickFilterOnScope = keyOfGridInScope + '.quickFilterText';
    gridOptions = $scope.$eval(keyOfGridInScope);
    if (!gridOptions) {
        console.warn("WARNING - grid options for ag-Grid not found. Please ensure the attribute ag-grid points to a valid object on the scope");
        return;
    }
    var eGridDiv = $element[0];
    var grid = new grid_1.Grid(eGridDiv, gridOptions, null, $scope, $compile, quickFilterOnScope);
    $scope.$on("$destroy", function () {
        grid.destroy();
    });
}

},{"../grid":106}],84:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var componentUtil_1 = require("./componentUtil");
var grid_1 = require("../grid");
var registered = false;
function initialiseAgGridWithWebComponents() {
    // only register to WebComponents once
    if (registered) {
        return;
    }
    registered = true;
    if (typeof document === 'undefined' || !document.registerElement) {
        console.error('ag-Grid: unable to find document.registerElement() function, unable to initialise ag-Grid as a Web Component');
    }
    // i don't think this type of extension is possible in TypeScript, so back to
    // plain Javascript to create this object
    var AgileGridProto = Object.create(HTMLElement.prototype);
    // wrap each property with a get and set method, so we can track when changes are done
    componentUtil_1.ComponentUtil.ALL_PROPERTIES.forEach(function (key) {
        Object.defineProperty(AgileGridProto, key, {
            set: function (v) {
                this.__agGridSetProperty(key, v);
            },
            get: function () {
                return this.__agGridGetProperty(key);
            }
        });
    });
    AgileGridProto.__agGridSetProperty = function (key, value) {
        if (!this.__attributes) {
            this.__attributes = {};
        }
        this.__attributes[key] = value;
        // keeping this consistent with the ng2 onChange, so I can reuse the handling code
        var changeObject = {};
        changeObject[key] = { currentValue: value };
        this.onChange(changeObject);
    };
    AgileGridProto.onChange = function (changes) {
        if (this._initialised) {
            componentUtil_1.ComponentUtil.processOnChange(changes, this._gridOptions, this.api);
        }
    };
    AgileGridProto.__agGridGetProperty = function (key) {
        if (!this.__attributes) {
            this.__attributes = {};
        }
        return this.__attributes[key];
    };
    AgileGridProto.setGridOptions = function (options) {
        var globalEventListener = this.globalEventListener.bind(this);
        this._gridOptions = componentUtil_1.ComponentUtil.copyAttributesToGridOptions(options, this);
        this._agGrid = new grid_1.Grid(this, this._gridOptions, globalEventListener);
        this.api = options.api;
        this.columnApi = options.columnApi;
        this._initialised = true;
    };
    // copies all the attributes into this object
    AgileGridProto.createdCallback = function () {
        for (var i = 0; i < this.attributes.length; i++) {
            var attribute = this.attributes[i];
            this.setPropertyFromAttribute(attribute);
        }
    };
    AgileGridProto.setPropertyFromAttribute = function (attribute) {
        var name = toCamelCase(attribute.nodeName);
        var value = attribute.nodeValue;
        if (componentUtil_1.ComponentUtil.ALL_PROPERTIES.indexOf(name) >= 0) {
            this[name] = value;
        }
    };
    AgileGridProto.attachedCallback = function (params) { };
    AgileGridProto.detachedCallback = function (params) { };
    AgileGridProto.attributeChangedCallback = function (attributeName) {
        var attribute = this.attributes[attributeName];
        this.setPropertyFromAttribute(attribute);
    };
    AgileGridProto.globalEventListener = function (eventType, event) {
        var eventLowerCase = eventType.toLowerCase();
        var browserEvent = new Event(eventLowerCase);
        var browserEventNoType = browserEvent;
        browserEventNoType.agGridDetails = event;
        this.dispatchEvent(browserEvent);
        var callbackMethod = 'on' + eventLowerCase;
        if (typeof this[callbackMethod] === 'function') {
            this[callbackMethod](browserEvent);
        }
    };
    // finally, register
    document.registerElement('ag-grid', { prototype: AgileGridProto });
}
exports.initialiseAgGridWithWebComponents = initialiseAgGridWithWebComponents;
function toCamelCase(myString) {
    if (typeof myString === 'string') {
        var result = myString.replace(/-([a-z])/g, function (g) {
            return g[1].toUpperCase();
        });
        return result;
    }
    else {
        return myString;
    }
}

},{"../grid":106,"./componentUtil":85}],85:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var events_1 = require("../events");
var utils_1 = require("../utils");
var ComponentUtil = (function () {
    function ComponentUtil() {
    }
    ComponentUtil.getEventCallbacks = function () {
        if (!ComponentUtil.EVENT_CALLBACKS) {
            ComponentUtil.EVENT_CALLBACKS = [];
            ComponentUtil.EVENTS.forEach(function (eventName) {
                ComponentUtil.EVENT_CALLBACKS.push(ComponentUtil.getCallbackForEvent(eventName));
            });
        }
        return ComponentUtil.EVENT_CALLBACKS;
    };
    ComponentUtil.copyAttributesToGridOptions = function (gridOptions, component) {
        checkForDeprecated(component);
        // create empty grid options if none were passed
        if (typeof gridOptions !== 'object') {
            gridOptions = {};
        }
        // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
        var pGridOptions = gridOptions;
        // add in all the simple properties
        ComponentUtil.ARRAY_PROPERTIES
            .concat(ComponentUtil.STRING_PROPERTIES)
            .concat(ComponentUtil.OBJECT_PROPERTIES)
            .concat(ComponentUtil.FUNCTION_PROPERTIES)
            .forEach(function (key) {
            if (typeof (component)[key] !== 'undefined') {
                pGridOptions[key] = component[key];
            }
        });
        ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
            if (typeof (component)[key] !== 'undefined') {
                pGridOptions[key] = ComponentUtil.toBoolean(component[key]);
            }
        });
        ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
            if (typeof (component)[key] !== 'undefined') {
                pGridOptions[key] = ComponentUtil.toNumber(component[key]);
            }
        });
        ComponentUtil.getEventCallbacks().forEach(function (funcName) {
            if (typeof (component)[funcName] !== 'undefined') {
                pGridOptions[funcName] = component[funcName];
            }
        });
        return gridOptions;
    };
    ComponentUtil.getCallbackForEvent = function (eventName) {
        if (!eventName || eventName.length < 2) {
            return eventName;
        }
        else {
            return 'on' + eventName[0].toUpperCase() + eventName.substr(1);
        }
    };
    // change this method, the caller should know if it's initialised or not, plus 'initialised'
    // is not relevant for all component types.
    // maybe pass in the api and columnApi instead???
    ComponentUtil.processOnChange = function (changes, gridOptions, api) {
        //if (!component._initialised || !changes) { return; }
        if (!changes) {
            return;
        }
        checkForDeprecated(changes);
        // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
        var pGridOptions = gridOptions;
        // check if any change for the simple types, and if so, then just copy in the new value
        ComponentUtil.ARRAY_PROPERTIES
            .concat(ComponentUtil.OBJECT_PROPERTIES)
            .concat(ComponentUtil.STRING_PROPERTIES)
            .forEach(function (key) {
            if (changes[key]) {
                pGridOptions[key] = changes[key].currentValue;
            }
        });
        ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
            if (changes[key]) {
                pGridOptions[key] = ComponentUtil.toBoolean(changes[key].currentValue);
            }
        });
        ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
            if (changes[key]) {
                pGridOptions[key] = ComponentUtil.toNumber(changes[key].currentValue);
            }
        });
        ComponentUtil.getEventCallbacks().forEach(function (funcName) {
            if (changes[funcName]) {
                pGridOptions[funcName] = changes[funcName].currentValue;
            }
        });
        if (changes.showToolPanel) {
            api.showToolPanel(changes.showToolPanel.currentValue);
        }
        if (changes.quickFilterText) {
            api.setQuickFilter(changes.quickFilterText.currentValue);
        }
        if (changes.rowData) {
            api.setRowData(changes.rowData.currentValue);
        }
        if (changes.floatingTopRowData) {
            api.setFloatingTopRowData(changes.floatingTopRowData.currentValue);
        }
        if (changes.floatingBottomRowData) {
            api.setFloatingBottomRowData(changes.floatingBottomRowData.currentValue);
        }
        if (changes.columnDefs) {
            api.setColumnDefs(changes.columnDefs.currentValue);
        }
        if (changes.datasource) {
            api.setDatasource(changes.datasource.currentValue);
        }
        if (changes.headerHeight) {
            api.setHeaderHeight(changes.headerHeight.currentValue);
        }
    };
    ComponentUtil.toBoolean = function (value) {
        if (typeof value === 'boolean') {
            return value;
        }
        else if (typeof value === 'string') {
            // for boolean, compare to empty String to allow attributes appearing with
            // not value to be treated as 'true'
            return value.toUpperCase() === 'TRUE' || value == '';
        }
        else {
            return false;
        }
    };
    ComponentUtil.toNumber = function (value) {
        if (typeof value === 'number') {
            return value;
        }
        else if (typeof value === 'string') {
            return Number(value);
        }
        else {
            return undefined;
        }
    };
    // all the events are populated in here AFTER this class (at the bottom of the file).
    ComponentUtil.EVENTS = [];
    ComponentUtil.STRING_PROPERTIES = [
        'sortingOrder', 'rowClass', 'rowSelection', 'overlayLoadingTemplate',
        'overlayNoRowsTemplate', 'headerCellTemplate', 'quickFilterText', 'rowModelType'];
    ComponentUtil.OBJECT_PROPERTIES = [
        'rowStyle', 'context', 'groupColumnDef', 'localeText', 'icons', 'datasource', 'viewportDatasource',
        'groupRowRendererParams'
    ];
    ComponentUtil.ARRAY_PROPERTIES = [
        'slaveGrids', 'rowData', 'floatingTopRowData', 'floatingBottomRowData', 'columnDefs'
    ];
    ComponentUtil.NUMBER_PROPERTIES = [
        'rowHeight', 'rowBuffer', 'colWidth', 'headerHeight', 'groupDefaultExpanded',
        'minColWidth', 'maxColWidth', 'viewportRowModelPageSize', 'viewportRowModelBufferSize'
    ];
    ComponentUtil.BOOLEAN_PROPERTIES = [
        'toolPanelSuppressGroups', 'toolPanelSuppressValues',
        'suppressRowClickSelection', 'suppressCellSelection', 'suppressHorizontalScroll', 'debug',
        'enableColResize', 'enableCellExpressions', 'enableSorting', 'enableServerSideSorting',
        'enableFilter', 'enableServerSideFilter', 'angularCompileRows', 'angularCompileFilters',
        'angularCompileHeaders', 'groupSuppressAutoColumn', 'groupSelectsChildren',
        'groupIncludeFooter', 'groupUseEntireRow', 'groupSuppressRow', 'groupSuppressBlankHeader', 'forPrint',
        'suppressMenuHide', 'rowDeselection', 'unSortIcon', 'suppressMultiSort', 'suppressScrollLag',
        'singleClickEdit', 'suppressLoadingOverlay', 'suppressNoRowsOverlay', 'suppressAutoSize',
        'suppressParentsInRowNodes', 'showToolPanel', 'suppressColumnMoveAnimation', 'suppressMovableColumns',
        'suppressFieldDotNotation', 'enableRangeSelection', 'suppressEnterprise', 'rowGroupPanelShow',
        'suppressContextMenu', 'suppressMenuFilterPanel', 'suppressMenuMainPanel', 'suppressMenuColumnPanel',
        'enableStatusBar', 'rememberGroupStateWhenNewData', 'enableCellChangeFlash', 'suppressDragLeaveHidesColumns',
        'suppressMiddleClickScrolls', 'suppressPreventDefaultOnMouseWheel'
    ];
    ComponentUtil.FUNCTION_PROPERTIES = ['headerCellRenderer', 'localeTextFunc', 'groupRowInnerRenderer',
        'groupRowRenderer', 'isScrollLag', 'isExternalFilterPresent', 'getRowHeight',
        'doesExternalFilterPass', 'getRowClass', 'getRowStyle', 'getHeaderCellTemplate', 'traverseNode',
        'getContextMenuItems', 'getMainMenuItems', 'processRowPostCreate', 'processCellForClipboard',
        'getNodeChildDetails', 'groupRowAggNodes'];
    ComponentUtil.ALL_PROPERTIES = ComponentUtil.ARRAY_PROPERTIES
        .concat(ComponentUtil.OBJECT_PROPERTIES)
        .concat(ComponentUtil.STRING_PROPERTIES)
        .concat(ComponentUtil.NUMBER_PROPERTIES)
        .concat(ComponentUtil.FUNCTION_PROPERTIES)
        .concat(ComponentUtil.BOOLEAN_PROPERTIES);
    return ComponentUtil;
})();
exports.ComponentUtil = ComponentUtil;
utils_1.Utils.iterateObject(events_1.Events, function (key, value) {
    ComponentUtil.EVENTS.push(value);
});
function checkForDeprecated(changes) {
    if (changes.ready || changes.onReady) {
        console.warn('ag-grid: as of v3.3 ready event is now called gridReady, so the callback should be onGridReady');
    }
    if (changes.rowDeselected || changes.onRowDeselected) {
        console.warn('ag-grid: as of v3.4 rowDeselected no longer exists. Please check the docs.');
    }
}

},{"../events":99,"../utils":156}],86:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Constants = (function () {
    function Constants() {
    }
    Constants.STEP_EVERYTHING = 0;
    Constants.STEP_FILTER = 1;
    Constants.STEP_SORT = 2;
    Constants.STEP_MAP = 3;
    Constants.STEP_AGGREGATE = 4;
    Constants.STEP_PIVOT = 5;
    Constants.ROW_BUFFER_SIZE = 5;
    Constants.KEY_BACKSPACE = 8;
    Constants.KEY_TAB = 9;
    Constants.KEY_ENTER = 13;
    Constants.KEY_SHIFT = 16;
    Constants.KEY_ESCAPE = 27;
    Constants.KEY_SPACE = 32;
    Constants.KEY_LEFT = 37;
    Constants.KEY_UP = 38;
    Constants.KEY_RIGHT = 39;
    Constants.KEY_DOWN = 40;
    Constants.KEY_DELETE = 46;
    Constants.KEY_A = 65;
    Constants.KEY_C = 67;
    Constants.KEY_V = 86;
    Constants.KEY_D = 68;
    Constants.KEY_F2 = 113;
    Constants.ROW_MODEL_TYPE_PAGINATION = 'pagination';
    Constants.ROW_MODEL_TYPE_VIRTUAL = 'virtual';
    Constants.ROW_MODEL_TYPE_VIEWPORT = 'viewport';
    Constants.ROW_MODEL_TYPE_NORMAL = 'normal';
    Constants.ALWAYS = 'always';
    Constants.ONLY_WHEN_GROUPING = 'onlyWhenGrouping';
    Constants.FLOATING_TOP = 'top';
    Constants.FLOATING_BOTTOM = 'bottom';
    return Constants;
})();
exports.Constants = Constants;

},{}],87:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require("../utils");
var logger_1 = require("../logger");
var Context = (function () {
    function Context(params) {
        this.beans = {};
        this.destroyed = false;
        if (!params || !params.beans) {
            return;
        }
        this.contextParams = params;
        this.logger = new logger_1.Logger('Context', this.contextParams.debug);
        this.logger.log('>> creating ag-Application Context');
        this.createBeans();
        var beans = utils_1.Utils.mapObject(this.beans, function (beanEntry) { return beanEntry.beanInstance; });
        this.wireBeans(beans);
        this.logger.log('>> ag-Application Context ready - component is alive');
    }
    Context.prototype.wireBean = function (bean) {
        this.wireBeans([bean]);
    };
    Context.prototype.wireBeans = function (beans) {
        this.autoWireBeans(beans);
        this.methodWireBeans(beans);
        this.postConstruct(beans);
    };
    Context.prototype.createBeans = function () {
        var _this = this;
        // register all normal beans
        this.contextParams.beans.forEach(this.createBeanEntry.bind(this));
        // register override beans, these will overwrite beans above of same name
        if (this.contextParams.overrideBeans) {
            this.contextParams.overrideBeans.forEach(this.createBeanEntry.bind(this));
        }
        // instantiate all beans - overridden beans will be left out
        utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
            var constructorParamsMeta;
            if (beanEntry.bean.prototype.__agBeanMetaData
                && beanEntry.bean.prototype.__agBeanMetaData.autowireMethods
                && beanEntry.bean.prototype.__agBeanMetaData.autowireMethods.agConstructor) {
                constructorParamsMeta = beanEntry.bean.prototype.__agBeanMetaData.autowireMethods.agConstructor;
            }
            var constructorParams = _this.getBeansForParameters(constructorParamsMeta, beanEntry.beanName);
            var newInstance = applyToConstructor(beanEntry.bean, constructorParams);
            beanEntry.beanInstance = newInstance;
            _this.logger.log('bean ' + _this.getBeanName(newInstance) + ' created');
        });
    };
    Context.prototype.createBeanEntry = function (Bean) {
        var metaData = Bean.prototype.__agBeanMetaData;
        if (!metaData) {
            var beanName;
            if (Bean.prototype.constructor) {
                beanName = Bean.prototype.constructor.name;
            }
            else {
                beanName = '' + Bean;
            }
            console.error('context item ' + beanName + ' is not a bean');
            return;
        }
        var beanEntry = {
            bean: Bean,
            beanInstance: null,
            beanName: metaData.beanName
        };
        this.beans[metaData.beanName] = beanEntry;
    };
    Context.prototype.autoWireBeans = function (beans) {
        var _this = this;
        beans.forEach(function (bean) { return _this.autoWireBean(bean); });
    };
    Context.prototype.methodWireBeans = function (beans) {
        var _this = this;
        beans.forEach(function (bean) { return _this.methodWireBean(bean); });
    };
    Context.prototype.autoWireBean = function (bean) {
        var _this = this;
        if (!bean
            || !bean.__agBeanMetaData
            || !bean.__agBeanMetaData.agClassAttributes) {
            return;
        }
        var attributes = bean.__agBeanMetaData.agClassAttributes;
        if (!attributes) {
            return;
        }
        var beanName = this.getBeanName(bean);
        attributes.forEach(function (attribute) {
            var otherBean = _this.lookupBeanInstance(beanName, attribute.beanName, attribute.optional);
            bean[attribute.attributeName] = otherBean;
        });
    };
    Context.prototype.getBeanName = function (bean) {
        var constructorString = bean.constructor.toString();
        var beanName = constructorString.substring(9, constructorString.indexOf('('));
        return beanName;
    };
    Context.prototype.methodWireBean = function (bean) {
        var _this = this;
        var autowiredMethods;
        if (bean.__agBeanMetaData) {
            autowiredMethods = bean.__agBeanMetaData.autowireMethods;
        }
        utils_1.Utils.iterateObject(autowiredMethods, function (methodName, wireParams) {
            // skip constructor, as this is dealt with elsewhere
            if (methodName === 'agConstructor') {
                return;
            }
            var beanName = _this.getBeanName(bean);
            var initParams = _this.getBeansForParameters(wireParams, beanName);
            bean[methodName].apply(bean, initParams);
        });
    };
    Context.prototype.getBeansForParameters = function (parameters, beanName) {
        var _this = this;
        var beansList = [];
        if (parameters) {
            utils_1.Utils.iterateObject(parameters, function (paramIndex, otherBeanName) {
                var otherBean = _this.lookupBeanInstance(beanName, otherBeanName);
                beansList[Number(paramIndex)] = otherBean;
            });
        }
        return beansList;
    };
    Context.prototype.lookupBeanInstance = function (wiringBean, beanName, optional) {
        if (optional === void 0) { optional = false; }
        if (beanName === 'context') {
            return this;
        }
        else if (this.contextParams.seed && this.contextParams.seed.hasOwnProperty(beanName)) {
            return this.contextParams.seed[beanName];
        }
        else {
            var beanEntry = this.beans[beanName];
            if (beanEntry) {
                return beanEntry.beanInstance;
            }
            if (!optional) {
                console.error('ag-Grid: unable to find bean reference ' + beanName + ' while initialising ' + wiringBean);
            }
            return null;
        }
    };
    Context.prototype.postConstruct = function (beans) {
        beans.forEach(function (bean) {
            // try calling init methods
            if (bean.__agBeanMetaData && bean.__agBeanMetaData.postConstructMethods) {
                bean.__agBeanMetaData.postConstructMethods.forEach(function (methodName) { return bean[methodName](); });
            }
        });
    };
    Context.prototype.getBean = function (name) {
        return this.lookupBeanInstance('getBean', name, true);
    };
    Context.prototype.destroy = function () {
        // should only be able to destroy once
        if (this.destroyed) {
            return;
        }
        this.logger.log('>> Shutting down ag-Application Context');
        // try calling destroy methods
        utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
            var bean = beanEntry.beanInstance;
            if (bean.__agBeanMetaData && bean.__agBeanMetaData.preDestroyMethods) {
                bean.__agBeanMetaData.preDestroyMethods.forEach(function (methodName) { return bean[methodName](); });
            }
        });
        this.destroyed = true;
        this.logger.log('>> ag-Application Context shut down - component is dead');
    };
    return Context;
})();
exports.Context = Context;
// taken from: http://stackoverflow.com/questions/3362471/how-can-i-call-a-javascript-constructor-using-call-or-apply
// allows calling 'apply' on a constructor
function applyToConstructor(constructor, argArray) {
    var args = [null].concat(argArray);
    var factoryFunction = constructor.bind.apply(constructor, args);
    return new factoryFunction();
}
function PostConstruct(target, methodName, descriptor) {
    var props = getOrCreateProps(target);
    if (!props.postConstructMethods) {
        props.postConstructMethods = [];
    }
    props.postConstructMethods.push(methodName);
}
exports.PostConstruct = PostConstruct;
function PreDestroy(target, methodName, descriptor) {
    var props = getOrCreateProps(target);
    if (!props.preDestroyMethods) {
        props.preDestroyMethods = [];
    }
    props.preDestroyMethods.push(methodName);
}
exports.PreDestroy = PreDestroy;
function Bean(beanName) {
    return function (classConstructor) {
        var props = getOrCreateProps(classConstructor.prototype);
        props.beanName = beanName;
    };
}
exports.Bean = Bean;
function Autowired(name) {
    return autowiredFunc.bind(this, name, false);
}
exports.Autowired = Autowired;
function Optional(name) {
    return autowiredFunc.bind(this, name, true);
}
exports.Optional = Optional;
function autowiredFunc(name, optional, classPrototype, methodOrAttributeName, index) {
    if (name === null) {
        console.error('ag-Grid: Autowired name should not be null');
        return;
    }
    if (typeof index === 'number') {
        console.error('ag-Grid: Autowired should be on an attribute');
        return;
    }
    // it's an attribute on the class
    var props = getOrCreateProps(classPrototype);
    if (!props.agClassAttributes) {
        props.agClassAttributes = [];
    }
    props.agClassAttributes.push({
        attributeName: methodOrAttributeName,
        beanName: name,
        optional: optional
    });
}
function Qualifier(name) {
    return function (classPrototype, methodOrAttributeName, index) {
        var props;
        if (typeof index === 'number') {
            // it's a parameter on a method
            var methodName;
            if (methodOrAttributeName) {
                props = getOrCreateProps(classPrototype);
                methodName = methodOrAttributeName;
            }
            else {
                props = getOrCreateProps(classPrototype.prototype);
                methodName = 'agConstructor';
            }
            if (!props.autowireMethods) {
                props.autowireMethods = {};
            }
            if (!props.autowireMethods[methodName]) {
                props.autowireMethods[methodName] = {};
            }
            props.autowireMethods[methodName][index] = name;
        }
    };
}
exports.Qualifier = Qualifier;
function getOrCreateProps(target) {
    var props = target.__agBeanMetaData;
    if (!props) {
        props = {};
        target.__agBeanMetaData = props;
    }
    return props;
}

},{"../logger":124,"../utils":156}],88:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var columnController_1 = require("./columnController/columnController");
var valueService_1 = require("./valueService");
var context_1 = require("./context/context");
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var constants_1 = require("./constants");
var LINE_SEPARATOR = '\r\n';
var CsvCreator = (function () {
    function CsvCreator() {
    }
    CsvCreator.prototype.exportDataAsCsv = function (params) {
        var csvString = this.getDataAsCsv(params);
        var fileNamePresent = params && params.fileName && params.fileName.length !== 0;
        var fileName = fileNamePresent ? params.fileName : 'export.csv';
        // for Excel, we need \ufeff at the start
        // http://stackoverflow.com/questions/17879198/adding-utf-8-bom-to-string-blob
        var blobObject = new Blob(["\ufeff", csvString], {
            type: "text/csv;charset=utf-8;"
        });
        // Internet Explorer
        if (window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blobObject, fileName);
        }
        else {
            // Chrome
            var downloadLink = document.createElement("a");
            downloadLink.href = window.URL.createObjectURL(blobObject);
            downloadLink.download = fileName;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }
    };
    CsvCreator.prototype.getDataAsCsv = function (params) {
        var _this = this;
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
            console.log('ag-Grid: getDataAsCsv is only available for standard row model');
            return '';
        }
        var inMemoryRowModel = this.rowModel;
        var result = '';
        var skipGroups = params && params.skipGroups;
        var skipHeader = params && params.skipHeader;
        var skipFooters = params && params.skipFooters;
        var includeCustomHeader = params && params.customHeader;
        var includeCustomFooter = params && params.customFooter;
        var allColumns = params && params.allColumns;
        var onlySelected = params && params.onlySelected;
        var columnSeparator = (params && params.columnSeparator) || ',';
        var suppressQuotes = params && params.suppressQuotes;
        var processCellCallback = params && params.processCellCallback;
        var columnsToExport;
        if (allColumns) {
            columnsToExport = this.columnController.getAllOriginalColumns();
        }
        else {
            columnsToExport = this.columnController.getAllDisplayedColumns();
        }
        if (!columnsToExport || columnsToExport.length === 0) {
            return '';
        }
        if (includeCustomHeader) {
            result += params.customHeader;
        }
        // first pass, put in the header names of the cols
        if (!skipHeader) {
            columnsToExport.forEach(function (column, index) {
                var nameForCol = _this.getHeaderName(params.processHeaderCallback, column);
                if (nameForCol === null || nameForCol === undefined) {
                    nameForCol = '';
                }
                if (index != 0) {
                    result += columnSeparator;
                }
                result += _this.putInQuotes(nameForCol, suppressQuotes);
            });
            result += LINE_SEPARATOR;
        }
        inMemoryRowModel.forEachNodeAfterFilterAndSort(function (node) {
            if (skipGroups && node.group) {
                return;
            }
            if (skipFooters && node.footer) {
                return;
            }
            if (onlySelected && !node.isSelected()) {
                return;
            }
            columnsToExport.forEach(function (column, index) {
                var valueForCell;
                if (node.group && index === 0) {
                    valueForCell = _this.createValueForGroupNode(node);
                }
                else {
                    valueForCell = _this.valueService.getValue(column, node);
                }
                valueForCell = _this.processCell(node, column, valueForCell, processCellCallback);
                if (valueForCell === null || valueForCell === undefined) {
                    valueForCell = '';
                }
                if (index != 0) {
                    result += columnSeparator;
                }
                result += _this.putInQuotes(valueForCell, suppressQuotes);
            });
            result += LINE_SEPARATOR;
        });
        if (includeCustomFooter) {
            result += params.customFooter;
        }
        return result;
    };
    CsvCreator.prototype.getHeaderName = function (callback, column) {
        if (callback) {
            return callback({
                column: column,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext()
            });
        }
        else {
            return this.columnController.getDisplayNameForCol(column);
        }
    };
    CsvCreator.prototype.processCell = function (rowNode, column, value, processCellCallback) {
        if (processCellCallback) {
            return processCellCallback({
                column: column,
                node: rowNode,
                value: value,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext()
            });
        }
        else {
            return value;
        }
    };
    CsvCreator.prototype.createValueForGroupNode = function (node) {
        var keys = [node.key];
        while (node.parent) {
            node = node.parent;
            keys.push(node.key);
        }
        return keys.reverse().join(' -> ');
    };
    CsvCreator.prototype.putInQuotes = function (value, suppressQuotes) {
        if (suppressQuotes) {
            return value;
        }
        if (value === null || value === undefined) {
            return '""';
        }
        var stringValue;
        if (typeof value === 'string') {
            stringValue = value;
        }
        else if (typeof value.toString === 'function') {
            stringValue = value.toString();
        }
        else {
            console.warn('unknown value type during csv conversion');
            stringValue = '';
        }
        // replace each " with "" (ie two sets of double quotes is how to do double quotes in csv)
        var valueEscaped = stringValue.replace(/"/g, "\"\"");
        return '"' + valueEscaped + '"';
    };
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], CsvCreator.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], CsvCreator.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], CsvCreator.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], CsvCreator.prototype, "gridOptionsWrapper", void 0);
    CsvCreator = __decorate([
        context_1.Bean('csvCreator'), 
        __metadata('design:paramtypes', [])
    ], CsvCreator);
    return CsvCreator;
})();
exports.CsvCreator = CsvCreator;

},{"./columnController/columnController":77,"./constants":86,"./context/context":87,"./gridOptionsWrapper":109,"./valueService":157}],89:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var context_1 = require("../context/context");
var logger_1 = require("../logger");
var context_2 = require("../context/context");
var utils_1 = require('../utils');
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var context_3 = require("../context/context");
var svgFactory_1 = require("../svgFactory");
var dragService_1 = require("./dragService");
var columnController_1 = require("../columnController/columnController");
var svgFactory = svgFactory_1.SvgFactory.getInstance();
var DragAndDropService = (function () {
    function DragAndDropService() {
        this.dropTargets = [];
    }
    DragAndDropService.prototype.init = function () {
        this.ePinnedIcon = utils_1.Utils.createIcon('columnMovePin', this.gridOptionsWrapper, null, svgFactory.createPinIcon);
        this.ePlusIcon = utils_1.Utils.createIcon('columnMoveAdd', this.gridOptionsWrapper, null, svgFactory.createPlusIcon);
        this.eHiddenIcon = utils_1.Utils.createIcon('columnMoveHide', this.gridOptionsWrapper, null, svgFactory.createColumnHiddenIcon);
        this.eMoveIcon = utils_1.Utils.createIcon('columnMoveMove', this.gridOptionsWrapper, null, svgFactory.createMoveIcon);
        this.eLeftIcon = utils_1.Utils.createIcon('columnMoveLeft', this.gridOptionsWrapper, null, svgFactory.createLeftIcon);
        this.eRightIcon = utils_1.Utils.createIcon('columnMoveRight', this.gridOptionsWrapper, null, svgFactory.createRightIcon);
        this.eGroupIcon = utils_1.Utils.createIcon('columnMoveGroup', this.gridOptionsWrapper, null, svgFactory.createGroupIcon);
    };
    DragAndDropService.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('OldToolPanelDragAndDropService');
        this.eBody = document.querySelector('body');
        if (!this.eBody) {
            console.warn('ag-Grid: could not find document body, it is needed for dragging columns');
        }
    };
    // we do not need to clean up drag sources, as we are just adding a listener to the element.
    // when the element is disposed, the drag source is also disposed, even though this service
    // remains. this is a bit different to normal 'addListener' methods
    DragAndDropService.prototype.addDragSource = function (dragSource) {
        this.dragService.addDragSource({
            eElement: dragSource.eElement,
            onDragStart: this.onDragStart.bind(this, dragSource),
            onDragStop: this.onDragStop.bind(this),
            onDragging: this.onDragging.bind(this)
        });
    };
    DragAndDropService.prototype.nudge = function () {
        if (this.dragging) {
            this.onDragging(this.eventLastTime);
        }
    };
    DragAndDropService.prototype.onDragStart = function (dragSource, mouseEvent) {
        this.dragging = true;
        this.dragSource = dragSource;
        this.eventLastTime = mouseEvent;
        this.dragSource.dragItem.forEach(function (column) { return column.setMoving(true); });
        this.dragItem = this.dragSource.dragItem;
        this.lastDropTarget = this.dragSource.dragSourceDropTarget;
        this.createGhost();
    };
    DragAndDropService.prototype.onDragStop = function (mouseEvent) {
        this.eventLastTime = null;
        this.dragging = false;
        this.dragItem.forEach(function (column) { return column.setMoving(false); });
        if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
            var draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null);
            this.lastDropTarget.onDragStop(draggingEvent);
        }
        this.lastDropTarget = null;
        this.dragItem = null;
        this.removeGhost();
    };
    DragAndDropService.prototype.onDragging = function (mouseEvent) {
        var direction = this.workOutDirection(mouseEvent);
        this.eventLastTime = mouseEvent;
        this.positionGhost(mouseEvent);
        // check if mouseEvent intersects with any of the drop targets
        var dropTarget = utils_1.Utils.find(this.dropTargets, this.isMouseOnDropTarget.bind(this, mouseEvent));
        if (dropTarget !== this.lastDropTarget) {
            this.leaveLastTargetIfExists(mouseEvent, direction);
            this.enterDragTargetIfExists(dropTarget, mouseEvent, direction);
            this.lastDropTarget = dropTarget;
        }
        else if (dropTarget) {
            var draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, direction);
            dropTarget.onDragging(draggingEvent);
        }
    };
    DragAndDropService.prototype.enterDragTargetIfExists = function (dropTarget, mouseEvent, direction) {
        if (!dropTarget) {
            return;
        }
        var dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, direction);
        dropTarget.onDragEnter(dragEnterEvent);
        this.setGhostIcon(dropTarget.iconName);
    };
    DragAndDropService.prototype.leaveLastTargetIfExists = function (mouseEvent, direction) {
        if (!this.lastDropTarget) {
            return;
        }
        var dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, direction);
        this.lastDropTarget.onDragLeave(dragLeaveEvent);
        this.setGhostIcon(null);
    };
    // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
    DragAndDropService.prototype.isMouseOnDropTarget = function (mouseEvent, dropTarget) {
        var ePrimaryAndSecondaryContainers = [dropTarget.eContainer];
        if (dropTarget.eSecondaryContainers) {
            ePrimaryAndSecondaryContainers = ePrimaryAndSecondaryContainers.concat(dropTarget.eSecondaryContainers);
        }
        var gotMatch = false;
        ePrimaryAndSecondaryContainers.forEach(function (eContainer) {
            if (!eContainer) {
                return;
            } // secondary can be missing
            var rect = eContainer.getBoundingClientRect();
            // if element is not visible, then width and height are zero
            if (rect.width === 0 || rect.height === 0) {
                return;
            }
            var horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX <= rect.right;
            var verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom;
            //console.log(`rect.width = ${rect.width} || rect.height = ${rect.height} ## verticalFit = ${verticalFit}, horizontalFit = ${horizontalFit}, `);
            if (horizontalFit && verticalFit) {
                gotMatch = true;
            }
        });
        return gotMatch;
    };
    DragAndDropService.prototype.addDropTarget = function (dropTarget) {
        this.dropTargets.push(dropTarget);
    };
    DragAndDropService.prototype.workOutDirection = function (event) {
        var direction;
        if (this.eventLastTime.clientX > event.clientX) {
            direction = DragAndDropService.DIRECTION_LEFT;
        }
        else if (this.eventLastTime.clientX < event.clientX) {
            direction = DragAndDropService.DIRECTION_RIGHT;
        }
        else {
            direction = null;
        }
        return direction;
    };
    DragAndDropService.prototype.createDropTargetEvent = function (dropTarget, event, direction) {
        // localise x and y to the target component
        var rect = dropTarget.eContainer.getBoundingClientRect();
        var x = event.clientX - rect.left;
        var y = event.clientY - rect.top;
        var dropTargetEvent = {
            event: event,
            x: x,
            y: y,
            direction: direction,
            dragSource: this.dragSource
        };
        return dropTargetEvent;
    };
    DragAndDropService.prototype.positionGhost = function (event) {
        var ghostRect = this.eGhost.getBoundingClientRect();
        var ghostHeight = ghostRect.height;
        // for some reason, without the '-2', it still overlapped by 1 or 2 pixels, which
        // then brought in scrollbars to the browser. no idea why, but putting in -2 here
        // works around it which is good enough for me.
        var browserWidth = utils_1.Utils.getBodyWidth() - 2;
        var browserHeight = utils_1.Utils.getBodyHeight() - 2;
        // put ghost vertically in middle of cursor
        var top = event.pageY - (ghostHeight / 2);
        // horizontally, place cursor just right of icon
        var left = event.pageX - 30;
        // check ghost is not positioned outside of the browser
        if (browserWidth > 0) {
            if ((left + this.eGhost.clientWidth) > browserWidth) {
                left = browserWidth - this.eGhost.clientWidth;
            }
        }
        if (left < 0) {
            left = 0;
        }
        if (browserHeight > 0) {
            if ((top + this.eGhost.clientHeight) > browserHeight) {
                top = browserHeight - this.eGhost.clientHeight;
            }
        }
        if (top < 0) {
            top = 0;
        }
        this.eGhost.style.left = left + 'px';
        this.eGhost.style.top = top + 'px';
    };
    DragAndDropService.prototype.removeGhost = function () {
        if (this.eGhost) {
            this.eBody.removeChild(this.eGhost);
        }
        this.eGhost = null;
    };
    DragAndDropService.prototype.createGhost = function () {
        this.eGhost = utils_1.Utils.loadTemplate(DragAndDropService.GHOST_TEMPLATE);
        this.eGhostIcon = this.eGhost.querySelector('.ag-dnd-ghost-icon');
        if (this.lastDropTarget) {
            this.setGhostIcon(this.lastDropTarget.iconName);
        }
        var eText = this.eGhost.querySelector('.ag-dnd-ghost-label');
        eText.innerHTML = this.dragSource.dragItemName;
        this.eGhost.style.height = this.gridOptionsWrapper.getHeaderHeight() + 'px';
        this.eGhost.style.top = '20px';
        this.eGhost.style.left = '20px';
        this.eBody.appendChild(this.eGhost);
    };
    /*
    // took this out as it wasn't making sense when dragging from the side panel, as it was possible to drag
       columns that were not visible - which is fine, as you are selecting from all columns here. what should be
       done is we check what columns to include in the drag depending on what started to drag - but that is to
       much coding for now, so just hardcoding the width to 200px for now.
        private getActualWidth(columns: Column[]): number {
            var totalColWidth = 0;
    
            // we only include displayed columns so hidden columns do not add space as this would look weird,
            // if for example moving a group with 5 cols, but only 1 displayed, we want ghost to be just the width
            // of the 1 displayed column
            var allDisplayedColumns = this.columnController.getAllDisplayedColumns();
            var displayedColumns = _.filter(columns, column => allDisplayedColumns.indexOf(column) >= 0 );
    
            displayedColumns.forEach( column => totalColWidth += column.getActualWidth() );
    
            return totalColWidth;
        }
    */
    DragAndDropService.prototype.setGhostIcon = function (iconName, shake) {
        if (shake === void 0) { shake = false; }
        utils_1.Utils.removeAllChildren(this.eGhostIcon);
        var eIcon;
        switch (iconName) {
            case DragAndDropService.ICON_ADD:
                eIcon = this.ePlusIcon;
                break;
            case DragAndDropService.ICON_PINNED:
                eIcon = this.ePinnedIcon;
                break;
            case DragAndDropService.ICON_MOVE:
                eIcon = this.eMoveIcon;
                break;
            case DragAndDropService.ICON_LEFT:
                eIcon = this.eLeftIcon;
                break;
            case DragAndDropService.ICON_RIGHT:
                eIcon = this.eRightIcon;
                break;
            case DragAndDropService.ICON_GROUP:
                eIcon = this.eGroupIcon;
                break;
            default:
                eIcon = this.eHiddenIcon;
                break;
        }
        this.eGhostIcon.appendChild(eIcon);
        utils_1.Utils.addOrRemoveCssClass(this.eGhostIcon, 'ag-shake-left-to-right', shake);
    };
    DragAndDropService.DIRECTION_LEFT = 'left';
    DragAndDropService.DIRECTION_RIGHT = 'right';
    DragAndDropService.ICON_PINNED = 'pinned';
    DragAndDropService.ICON_ADD = 'add';
    DragAndDropService.ICON_MOVE = 'move';
    DragAndDropService.ICON_LEFT = 'left';
    DragAndDropService.ICON_RIGHT = 'right';
    DragAndDropService.ICON_GROUP = 'group';
    DragAndDropService.GHOST_TEMPLATE = '<div class="ag-dnd-ghost">' +
        '  <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>' +
        '  <div class="ag-dnd-ghost-label">' +
        '  </div>' +
        '</div>';
    __decorate([
        context_3.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], DragAndDropService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_3.Autowired('dragService'), 
        __metadata('design:type', dragService_1.DragService)
    ], DragAndDropService.prototype, "dragService", void 0);
    __decorate([
        context_3.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], DragAndDropService.prototype, "columnController", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], DragAndDropService.prototype, "init", null);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], DragAndDropService.prototype, "setBeans", null);
    DragAndDropService = __decorate([
        context_2.Bean('dragAndDropService'), 
        __metadata('design:paramtypes', [])
    ], DragAndDropService);
    return DragAndDropService;
})();
exports.DragAndDropService = DragAndDropService;

},{"../columnController/columnController":77,"../context/context":87,"../gridOptionsWrapper":109,"../logger":124,"../svgFactory":154,"../utils":156,"./dragService":90}],90:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var context_2 = require("../context/context");
var logger_1 = require("../logger");
var context_3 = require("../context/context");
var utils_1 = require('../utils');
/** Adds drag listening onto an element. In ag-Grid this is used twice, first is resizing columns,
 * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */
var DragService = (function () {
    function DragService() {
        this.onMouseUpListener = this.onMouseUp.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.destroyFunctions = [];
    }
    DragService.prototype.init = function () {
        this.logger = this.loggerFactory.create('DragService');
    };
    DragService.prototype.destroy = function () {
        this.destroyFunctions.forEach(function (func) { return func(); });
    };
    DragService.prototype.addDragSource = function (params) {
        var listener = this.onMouseDown.bind(this, params);
        params.eElement.addEventListener('mousedown', listener);
        this.destroyFunctions.push(function () { return params.eElement.removeEventListener('mousedown', listener); });
    };
    // gets called whenever mouse down on any drag source
    DragService.prototype.onMouseDown = function (params, mouseEvent) {
        // only interested in left button clicks
        if (mouseEvent.button !== 0) {
            return;
        }
        this.currentDragParams = params;
        this.dragging = false;
        this.eventLastTime = mouseEvent;
        this.dragStartEvent = mouseEvent;
        // we temporally add these listeners, for the duration of the drag, they
        // are removed in mouseup handling.
        document.addEventListener('mousemove', this.onMouseMoveListener);
        document.addEventListener('mouseup', this.onMouseUpListener);
        // see if we want to start dragging straight away
        if (params.dragStartPixels === 0) {
            this.onMouseMove(mouseEvent);
        }
    };
    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
    DragService.prototype.isEventNearStartEvent = function (event) {
        // by default, we wait 4 pixels before starting the drag
        var requiredPixelDiff = utils_1.Utils.exists(this.currentDragParams.dragStartPixels) ? this.currentDragParams.dragStartPixels : 4;
        if (requiredPixelDiff === 0) {
            return false;
        }
        var diffX = Math.abs(event.clientX - this.dragStartEvent.clientX);
        var diffY = Math.abs(event.clientY - this.dragStartEvent.clientY);
        return Math.max(diffX, diffY) <= requiredPixelDiff;
    };
    // only gets called after a mouse down - as this is only added after mouseDown
    // and is removed when mouseUp happens
    DragService.prototype.onMouseMove = function (mouseEvent) {
        if (!this.dragging) {
            // if mouse hasn't travelled from the start position enough, do nothing
            var toEarlyToDrag = !this.dragging && this.isEventNearStartEvent(mouseEvent);
            if (toEarlyToDrag) {
                return;
            }
            else {
                this.dragging = true;
                this.currentDragParams.onDragStart(this.dragStartEvent);
            }
        }
        this.currentDragParams.onDragging(mouseEvent);
    };
    DragService.prototype.onMouseUp = function (mouseEvent) {
        document.removeEventListener('mouseup', this.onMouseUpListener);
        document.removeEventListener('mousemove', this.onMouseMoveListener);
        if (this.dragging) {
            this.currentDragParams.onDragStop(mouseEvent);
        }
        this.dragStartEvent = null;
        this.eventLastTime = null;
        this.dragging = false;
    };
    __decorate([
        context_2.Autowired('loggerFactory'), 
        __metadata('design:type', logger_1.LoggerFactory)
    ], DragService.prototype, "loggerFactory", void 0);
    __decorate([
        context_3.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], DragService.prototype, "init", null);
    __decorate([
        context_1.PreDestroy, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], DragService.prototype, "destroy", null);
    DragService = __decorate([
        context_1.Bean('dragService'), 
        __metadata('design:paramtypes', [])
    ], DragService);
    return DragService;
})();
exports.DragService = DragService;

},{"../context/context":87,"../logger":124,"../utils":156}],91:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var utils_1 = require('../utils');
var logger_1 = require("../logger");
var context_1 = require("../context/context");
var context_2 = require("../context/context");
/** Functionality for internal DnD functionality between GUI widgets. Eg this service is used to drag columns
 * from the 'available columns' list and putting them into the 'grouped columns' in the tool panel.
 * This service is NOT used by the column headers for resizing and moving, that is a different use case. */
var OldToolPanelDragAndDropService = (function () {
    function OldToolPanelDragAndDropService() {
        this.destroyFunctions = [];
    }
    OldToolPanelDragAndDropService.prototype.agWire = function (loggerFactory) {
        this.logger = loggerFactory.create('OldToolPanelDragAndDropService');
        // need to clean this up, add to 'finished' logic in grid
        var mouseUpListener = this.stopDragging.bind(this);
        document.addEventListener('mouseup', mouseUpListener);
        this.destroyFunctions.push(function () { document.removeEventListener('mouseup', mouseUpListener); });
    };
    OldToolPanelDragAndDropService.prototype.destroy = function () {
        this.destroyFunctions.forEach(function (func) { return func(); });
        document.removeEventListener('mouseup', this.mouseUpEventListener);
    };
    OldToolPanelDragAndDropService.prototype.stopDragging = function () {
        if (this.dragItem) {
            this.setDragCssClasses(this.dragItem.eDragSource, false);
            this.dragItem = null;
        }
    };
    OldToolPanelDragAndDropService.prototype.setDragCssClasses = function (eListItem, dragging) {
        utils_1.Utils.addOrRemoveCssClass(eListItem, 'ag-dragging', dragging);
        utils_1.Utils.addOrRemoveCssClass(eListItem, 'ag-not-dragging', !dragging);
    };
    OldToolPanelDragAndDropService.prototype.addDragSource = function (eDragSource, dragSourceCallback) {
        this.setDragCssClasses(eDragSource, false);
        eDragSource.addEventListener('mousedown', this.onMouseDownDragSource.bind(this, eDragSource, dragSourceCallback));
    };
    OldToolPanelDragAndDropService.prototype.onMouseDownDragSource = function (eDragSource, dragSourceCallback) {
        if (this.dragItem) {
            this.stopDragging();
        }
        var data;
        if (dragSourceCallback.getData) {
            data = dragSourceCallback.getData();
        }
        var containerId;
        if (dragSourceCallback.getContainerId) {
            containerId = dragSourceCallback.getContainerId();
        }
        this.dragItem = {
            eDragSource: eDragSource,
            data: data,
            containerId: containerId
        };
        this.setDragCssClasses(this.dragItem.eDragSource, true);
    };
    OldToolPanelDragAndDropService.prototype.addDropTarget = function (eDropTarget, dropTargetCallback) {
        var _this = this;
        var mouseIn = false;
        var acceptDrag = false;
        eDropTarget.addEventListener('mouseover', function () {
            if (!mouseIn) {
                mouseIn = true;
                if (_this.dragItem) {
                    acceptDrag = dropTargetCallback.acceptDrag(_this.dragItem);
                }
                else {
                    acceptDrag = false;
                }
            }
        });
        eDropTarget.addEventListener('mouseout', function () {
            if (acceptDrag) {
                dropTargetCallback.noDrop();
            }
            mouseIn = false;
            acceptDrag = false;
        });
        eDropTarget.addEventListener('mouseup', function () {
            // dragItem should never be null, checking just in case
            if (acceptDrag && _this.dragItem) {
                dropTargetCallback.drop(_this.dragItem);
            }
        });
    };
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], OldToolPanelDragAndDropService.prototype, "agWire", null);
    __decorate([
        context_1.PreDestroy, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], OldToolPanelDragAndDropService.prototype, "destroy", null);
    OldToolPanelDragAndDropService = __decorate([
        context_1.Bean('oldToolPanelDragAndDropService'), 
        __metadata('design:paramtypes', [])
    ], OldToolPanelDragAndDropService);
    return OldToolPanelDragAndDropService;
})();
exports.OldToolPanelDragAndDropService = OldToolPanelDragAndDropService;

},{"../context/context":87,"../logger":124,"../utils":156}],92:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var eventService_1 = require("../eventService");
var utils_1 = require("../utils");
var context_1 = require("../context/context");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var columnUtils_1 = require("../columnController/columnUtils");
// Wrapper around a user provide column definition. The grid treats the column definition as ready only.
// This class contains all the runtime information about a column, plus some logic (the definition has no logic).
// This class implements both interfaces ColumnGroupChild and OriginalColumnGroupChild as the class can
// appear as a child of either the original tree or the displayed tree. However the relevant group classes
// for each type only implements one, as each group can only appear in it's associated tree (eg OriginalColumnGroup
// can only appear in OriginalColumn tree).
var Column = (function () {
    function Column(colDef, colId) {
        this.moving = false;
        this.filterActive = false;
        this.eventService = new eventService_1.EventService();
        this.colDef = colDef;
        this.visible = !colDef.hide;
        this.sort = colDef.sort;
        this.sortedAt = colDef.sortedAt;
        this.colId = colId;
    }
    // this is done after constructor as it uses gridOptionsWrapper
    Column.prototype.initialise = function () {
        this.setPinned(this.colDef.pinned);
        var minColWidth = this.gridOptionsWrapper.getMinColWidth();
        var maxColWidth = this.gridOptionsWrapper.getMaxColWidth();
        if (this.colDef.minWidth) {
            this.minWidth = this.colDef.minWidth;
        }
        else {
            this.minWidth = minColWidth;
        }
        if (this.colDef.maxWidth) {
            this.maxWidth = this.colDef.maxWidth;
        }
        else {
            this.maxWidth = maxColWidth;
        }
        this.actualWidth = this.columnUtils.calculateColInitialWidth(this.colDef);
        var suppressDotNotation = this.gridOptionsWrapper.isSuppressFieldDotNotation();
        this.fieldContainsDots = utils_1.Utils.exists(this.colDef.field) && this.colDef.field.indexOf('.') >= 0 && !suppressDotNotation;
        this.validate();
    };
    Column.prototype.isFieldContainsDots = function () {
        return this.fieldContainsDots;
    };
    Column.prototype.validate = function () {
        if (!this.gridOptionsWrapper.isEnterprise()) {
            if (utils_1.Utils.exists(this.colDef.aggFunc)) {
                console.warn('ag-Grid: aggFunc is only valid in ag-Grid-Enterprise');
            }
            if (utils_1.Utils.exists(this.colDef.rowGroupIndex)) {
                console.warn('ag-Grid: rowGroupIndex is only valid in ag-Grid-Enterprise');
            }
        }
    };
    Column.prototype.addEventListener = function (eventType, listener) {
        this.eventService.addEventListener(eventType, listener);
    };
    Column.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    Column.prototype.isCellEditable = function (rowNode) {
        // if boolean set, then just use it
        if (typeof this.colDef.editable === 'boolean') {
            return this.colDef.editable;
        }
        // if function, then call the function to find out
        if (typeof this.colDef.editable === 'function') {
            var params = {
                node: rowNode,
                column: this,
                colDef: this.colDef,
                context: this.gridOptionsWrapper.getContext(),
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi()
            };
            var editableFunc = this.colDef.editable;
            return editableFunc(params);
        }
        return false;
    };
    Column.prototype.setMoving = function (moving) {
        this.moving = moving;
        this.eventService.dispatchEvent(Column.EVENT_MOVING_CHANGED);
    };
    Column.prototype.isMoving = function () {
        return this.moving;
    };
    Column.prototype.getSort = function () {
        return this.sort;
    };
    Column.prototype.setSort = function (sort) {
        if (this.sort !== sort) {
            this.sort = sort;
            this.eventService.dispatchEvent(Column.EVENT_SORT_CHANGED);
        }
    };
    Column.prototype.isSortAscending = function () {
        return this.sort === Column.SORT_ASC;
    };
    Column.prototype.isSortDescending = function () {
        return this.sort === Column.SORT_DESC;
    };
    Column.prototype.isSortNone = function () {
        return utils_1.Utils.missing(this.sort);
    };
    Column.prototype.getSortedAt = function () {
        return this.sortedAt;
    };
    Column.prototype.setSortedAt = function (sortedAt) {
        this.sortedAt = sortedAt;
    };
    Column.prototype.setAggFunc = function (aggFunc) {
        this.aggFunc = aggFunc;
    };
    Column.prototype.getAggFunc = function () {
        return this.aggFunc;
    };
    Column.prototype.getLeft = function () {
        return this.left;
    };
    Column.prototype.getRight = function () {
        return this.left + this.actualWidth;
    };
    Column.prototype.setLeft = function (left) {
        if (this.left !== left) {
            this.left = left;
            this.eventService.dispatchEvent(Column.EVENT_LEFT_CHANGED);
        }
    };
    Column.prototype.isFilterActive = function () {
        return this.filterActive;
    };
    Column.prototype.setFilterActive = function (active) {
        if (this.filterActive !== active) {
            this.filterActive = active;
            this.eventService.dispatchEvent(Column.EVENT_FILTER_ACTIVE_CHANGED);
        }
    };
    Column.prototype.setPinned = function (pinned) {
        // pinning is not allowed when doing 'forPrint'
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        if (pinned === true || pinned === Column.PINNED_LEFT) {
            this.pinned = Column.PINNED_LEFT;
        }
        else if (pinned === Column.PINNED_RIGHT) {
            this.pinned = Column.PINNED_RIGHT;
        }
        else {
            this.pinned = null;
        }
    };
    Column.prototype.setFirstRightPinned = function (firstRightPinned) {
        if (this.firstRightPinned !== firstRightPinned) {
            this.firstRightPinned = firstRightPinned;
            this.eventService.dispatchEvent(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED);
        }
    };
    Column.prototype.setLastLeftPinned = function (lastLeftPinned) {
        if (this.lastLeftPinned !== lastLeftPinned) {
            this.lastLeftPinned = lastLeftPinned;
            this.eventService.dispatchEvent(Column.EVENT_LAST_LEFT_PINNED_CHANGED);
        }
    };
    Column.prototype.isFirstRightPinned = function () {
        return this.firstRightPinned;
    };
    Column.prototype.isLastLeftPinned = function () {
        return this.lastLeftPinned;
    };
    Column.prototype.isPinned = function () {
        return this.pinned === Column.PINNED_LEFT || this.pinned === Column.PINNED_RIGHT;
    };
    Column.prototype.isPinnedLeft = function () {
        return this.pinned === Column.PINNED_LEFT;
    };
    Column.prototype.isPinnedRight = function () {
        return this.pinned === Column.PINNED_RIGHT;
    };
    Column.prototype.getPinned = function () {
        return this.pinned;
    };
    Column.prototype.setVisible = function (visible) {
        var newValue = visible === true;
        if (this.visible !== newValue) {
            this.visible = newValue;
            this.eventService.dispatchEvent(Column.EVENT_VISIBLE_CHANGED);
        }
    };
    Column.prototype.isVisible = function () {
        return this.visible;
    };
    Column.prototype.getColDef = function () {
        return this.colDef;
    };
    Column.prototype.getColumnGroupShow = function () {
        return this.colDef.columnGroupShow;
    };
    Column.prototype.getColId = function () {
        return this.colId;
    };
    Column.prototype.getId = function () {
        return this.getColId();
    };
    Column.prototype.getDefinition = function () {
        return this.colDef;
    };
    Column.prototype.getActualWidth = function () {
        return this.actualWidth;
    };
    Column.prototype.setActualWidth = function (actualWidth) {
        if (this.actualWidth !== actualWidth) {
            this.actualWidth = actualWidth;
            this.eventService.dispatchEvent(Column.EVENT_WIDTH_CHANGED);
        }
    };
    Column.prototype.isGreaterThanMax = function (width) {
        if (this.maxWidth) {
            return width > this.maxWidth;
        }
        else {
            return false;
        }
    };
    Column.prototype.getMinWidth = function () {
        return this.minWidth;
    };
    Column.prototype.getMaxWidth = function () {
        return this.maxWidth;
    };
    Column.prototype.setMinimum = function () {
        this.setActualWidth(this.minWidth);
    };
    // + renderedHeaderCell - for making header cell transparent when moving
    Column.EVENT_MOVING_CHANGED = 'movingChanged';
    // + renderedCell - changing left position
    Column.EVENT_LEFT_CHANGED = 'leftChanged';
    // + renderedCell - changing width
    Column.EVENT_WIDTH_CHANGED = 'widthChanged';
    // + renderedCell - for changing pinned classes
    Column.EVENT_LAST_LEFT_PINNED_CHANGED = 'lastLeftPinnedChanged';
    Column.EVENT_FIRST_RIGHT_PINNED_CHANGED = 'firstRightPinnedChanged';
    // + renderedColumn - for changing visibility icon
    Column.EVENT_VISIBLE_CHANGED = 'visibleChanged';
    // + renderedHeaderCell - marks the header with filter icon
    Column.EVENT_FILTER_ACTIVE_CHANGED = 'filterChanged';
    // + renderedHeaderCell - marks the header with sort icon
    Column.EVENT_SORT_CHANGED = 'filterChanged';
    Column.PINNED_RIGHT = 'right';
    Column.PINNED_LEFT = 'left';
    Column.AGG_SUM = 'sum';
    Column.AGG_MIN = 'min';
    Column.AGG_MAX = 'max';
    Column.AGG_FIRST = 'first';
    Column.AGG_LAST = 'last';
    Column.SORT_ASC = 'asc';
    Column.SORT_DESC = 'desc';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], Column.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnUtils'), 
        __metadata('design:type', columnUtils_1.ColumnUtils)
    ], Column.prototype, "columnUtils", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], Column.prototype, "initialise", null);
    return Column;
})();
exports.Column = Column;

},{"../columnController/columnUtils":79,"../context/context":87,"../eventService":98,"../gridOptionsWrapper":109,"../utils":156}],93:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var column_1 = require("./column");
var eventService_1 = require("../eventService");
var ColumnGroup = (function () {
    function ColumnGroup(originalColumnGroup, groupId, instanceId) {
        // depends on the open/closed state of the group, only displaying columns are stored here
        this.displayedChildren = [];
        this.moving = false;
        this.eventService = new eventService_1.EventService();
        this.groupId = groupId;
        this.instanceId = instanceId;
        this.originalColumnGroup = originalColumnGroup;
    }
    // returns header name if it exists, otherwise null. if will not exist if
    // this group is a padding group, as they don't have colGroupDef's
    ColumnGroup.prototype.getHeaderName = function () {
        if (this.originalColumnGroup.getColGroupDef()) {
            return this.originalColumnGroup.getColGroupDef().headerName;
        }
        else {
            return null;
        }
    };
    ColumnGroup.prototype.addEventListener = function (eventType, listener) {
        this.eventService.addEventListener(eventType, listener);
    };
    ColumnGroup.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    ColumnGroup.prototype.setMoving = function (moving) {
        this.getDisplayedLeafColumns().forEach(function (column) { return column.setMoving(moving); });
    };
    ColumnGroup.prototype.isMoving = function () {
        return this.moving;
    };
    ColumnGroup.prototype.getGroupId = function () {
        return this.groupId;
    };
    ColumnGroup.prototype.getInstanceId = function () {
        return this.instanceId;
    };
    ColumnGroup.prototype.isChildInThisGroupDeepSearch = function (wantedChild) {
        var result = false;
        this.children.forEach(function (foundChild) {
            if (wantedChild === foundChild) {
                result = true;
            }
            if (foundChild instanceof ColumnGroup) {
                if (foundChild.isChildInThisGroupDeepSearch(wantedChild)) {
                    result = true;
                }
            }
        });
        return result;
    };
    ColumnGroup.prototype.getActualWidth = function () {
        var groupActualWidth = 0;
        if (this.displayedChildren) {
            this.displayedChildren.forEach(function (child) {
                groupActualWidth += child.getActualWidth();
            });
        }
        return groupActualWidth;
    };
    ColumnGroup.prototype.getMinWidth = function () {
        var result = 0;
        this.displayedChildren.forEach(function (groupChild) {
            result += groupChild.getMinWidth();
        });
        return result;
    };
    ColumnGroup.prototype.addChild = function (child) {
        if (!this.children) {
            this.children = [];
        }
        this.children.push(child);
    };
    ColumnGroup.prototype.getDisplayedChildren = function () {
        return this.displayedChildren;
    };
    ColumnGroup.prototype.getLeafColumns = function () {
        var result = [];
        this.addLeafColumns(result);
        return result;
    };
    ColumnGroup.prototype.getDisplayedLeafColumns = function () {
        var result = [];
        this.addDisplayedLeafColumns(result);
        return result;
    };
    // why two methods here doing the same thing?
    ColumnGroup.prototype.getDefinition = function () {
        return this.originalColumnGroup.getColGroupDef();
    };
    ColumnGroup.prototype.getColGroupDef = function () {
        return this.originalColumnGroup.getColGroupDef();
    };
    ColumnGroup.prototype.isExpandable = function () {
        return this.originalColumnGroup.isExpandable();
    };
    ColumnGroup.prototype.isExpanded = function () {
        return this.originalColumnGroup.isExpanded();
    };
    ColumnGroup.prototype.setExpanded = function (expanded) {
        this.originalColumnGroup.setExpanded(expanded);
    };
    ColumnGroup.prototype.addDisplayedLeafColumns = function (leafColumns) {
        this.displayedChildren.forEach(function (child) {
            if (child instanceof column_1.Column) {
                leafColumns.push(child);
            }
            else if (child instanceof ColumnGroup) {
                child.addDisplayedLeafColumns(leafColumns);
            }
        });
    };
    ColumnGroup.prototype.addLeafColumns = function (leafColumns) {
        this.children.forEach(function (child) {
            if (child instanceof column_1.Column) {
                leafColumns.push(child);
            }
            else if (child instanceof ColumnGroup) {
                child.addLeafColumns(leafColumns);
            }
        });
    };
    ColumnGroup.prototype.getChildren = function () {
        return this.children;
    };
    ColumnGroup.prototype.getColumnGroupShow = function () {
        return this.originalColumnGroup.getColumnGroupShow();
    };
    ColumnGroup.prototype.getOriginalColumnGroup = function () {
        return this.originalColumnGroup;
    };
    ColumnGroup.prototype.calculateDisplayedColumns = function () {
        // clear out last time we calculated
        this.displayedChildren = [];
        // it not expandable, everything is visible
        if (!this.originalColumnGroup.isExpandable()) {
            this.displayedChildren = this.children;
            return;
        }
        // and calculate again
        for (var i = 0, j = this.children.length; i < j; i++) {
            var abstractColumn = this.children[i];
            var headerGroupShow = abstractColumn.getColumnGroupShow();
            switch (headerGroupShow) {
                case ColumnGroup.HEADER_GROUP_SHOW_OPEN:
                    // when set to open, only show col if group is open
                    if (this.originalColumnGroup.isExpanded()) {
                        this.displayedChildren.push(abstractColumn);
                    }
                    break;
                case ColumnGroup.HEADER_GROUP_SHOW_CLOSED:
                    // when set to open, only show col if group is open
                    if (!this.originalColumnGroup.isExpanded()) {
                        this.displayedChildren.push(abstractColumn);
                    }
                    break;
                default:
                    // default is always show the column
                    this.displayedChildren.push(abstractColumn);
                    break;
            }
        }
    };
    ColumnGroup.HEADER_GROUP_SHOW_OPEN = 'open';
    ColumnGroup.HEADER_GROUP_SHOW_CLOSED = 'closed';
    return ColumnGroup;
})();
exports.ColumnGroup = ColumnGroup;

},{"../eventService":98,"./column":92}],94:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require("../utils");
var gridRow_1 = require("./gridRow");
var GridCell = (function () {
    function GridCell(rowIndex, floating, column) {
        this.rowIndex = rowIndex;
        this.column = column;
        this.floating = utils_1.Utils.makeNull(floating);
    }
    GridCell.prototype.getGridRow = function () {
        return new gridRow_1.GridRow(this.rowIndex, this.floating);
    };
    GridCell.prototype.toString = function () {
        return "rowIndex = " + this.rowIndex + ", floating = " + this.floating + ", column = " + (this.column ? this.column.getId() : null);
    };
    GridCell.prototype.createId = function () {
        return this.rowIndex + "." + this.floating + "." + this.column.getId();
    };
    return GridCell;
})();
exports.GridCell = GridCell;

},{"../utils":156,"./gridRow":95}],95:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var constants_1 = require("../constants");
var utils_1 = require('../utils');
var gridCell_1 = require("./gridCell");
var GridRow = (function () {
    function GridRow(rowIndex, floating) {
        this.rowIndex = rowIndex;
        this.floating = utils_1.Utils.makeNull(floating);
    }
    GridRow.prototype.isFloatingTop = function () {
        return this.floating === constants_1.Constants.FLOATING_TOP;
    };
    GridRow.prototype.isFloatingBottom = function () {
        return this.floating === constants_1.Constants.FLOATING_BOTTOM;
    };
    GridRow.prototype.isNotFloating = function () {
        return !this.isFloatingBottom() && !this.isFloatingTop();
    };
    GridRow.prototype.equals = function (otherSelection) {
        return this.rowIndex === otherSelection.rowIndex
            && this.floating === otherSelection.floating;
    };
    GridRow.prototype.toString = function () {
        return "rowIndex = " + this.rowIndex + ", floating = " + this.floating;
    };
    GridRow.prototype.getGridCell = function (column) {
        return new gridCell_1.GridCell(this.rowIndex, this.floating, column);
    };
    // tests if this row selection is before the other row selection
    GridRow.prototype.before = function (otherSelection) {
        var otherFloating = otherSelection.floating;
        switch (this.floating) {
            case constants_1.Constants.FLOATING_TOP:
                // we we are floating top, and other isn't, then we are always before
                if (otherFloating !== constants_1.Constants.FLOATING_TOP) {
                    return true;
                }
                break;
            case constants_1.Constants.FLOATING_BOTTOM:
                // if we are floating bottom, and the other isn't, then we are never before
                if (otherFloating !== constants_1.Constants.FLOATING_BOTTOM) {
                    return false;
                }
                break;
            default:
                // if we are not floating, but the other one is floating...
                if (utils_1.Utils.exists(otherFloating)) {
                    if (otherFloating === constants_1.Constants.FLOATING_TOP) {
                        // we are not floating, other is floating top, we are first
                        return false;
                    }
                    else {
                        // we are not floating, other is floating bottom, we are always first
                        return true;
                    }
                }
                break;
        }
        return this.rowIndex <= otherSelection.rowIndex;
    };
    return GridRow;
})();
exports.GridRow = GridRow;

},{"../constants":86,"../utils":156,"./gridCell":94}],96:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var columnGroup_1 = require("./columnGroup");
var column_1 = require("./column");
var OriginalColumnGroup = (function () {
    function OriginalColumnGroup(colGroupDef, groupId) {
        this.expandable = false;
        this.expanded = false;
        this.colGroupDef = colGroupDef;
        this.groupId = groupId;
    }
    OriginalColumnGroup.prototype.setExpanded = function (expanded) {
        this.expanded = expanded;
    };
    OriginalColumnGroup.prototype.isExpandable = function () {
        return this.expandable;
    };
    OriginalColumnGroup.prototype.isExpanded = function () {
        return this.expanded;
    };
    OriginalColumnGroup.prototype.getGroupId = function () {
        return this.groupId;
    };
    OriginalColumnGroup.prototype.getId = function () {
        return this.getGroupId();
    };
    OriginalColumnGroup.prototype.setChildren = function (children) {
        this.children = children;
    };
    OriginalColumnGroup.prototype.getChildren = function () {
        return this.children;
    };
    OriginalColumnGroup.prototype.getColGroupDef = function () {
        return this.colGroupDef;
    };
    OriginalColumnGroup.prototype.getLeafColumns = function () {
        var result = [];
        this.addLeafColumns(result);
        return result;
    };
    OriginalColumnGroup.prototype.addLeafColumns = function (leafColumns) {
        this.children.forEach(function (child) {
            if (child instanceof column_1.Column) {
                leafColumns.push(child);
            }
            else if (child instanceof OriginalColumnGroup) {
                child.addLeafColumns(leafColumns);
            }
        });
    };
    OriginalColumnGroup.prototype.getColumnGroupShow = function () {
        if (this.colGroupDef) {
            return this.colGroupDef.columnGroupShow;
        }
        else {
            // if there is no col def, then this must be a padding
            // group, which means we have exactly only child. we then
            // take the value from the child and push it up, making
            // this group 'invisible'.
            return this.children[0].getColumnGroupShow();
        }
    };
    // need to check that this group has at least one col showing when both expanded and contracted.
    // if not, then we don't allow expanding and contracting on this group
    OriginalColumnGroup.prototype.calculateExpandable = function () {
        // want to make sure the group doesn't disappear when it's open
        var atLeastOneShowingWhenOpen = false;
        // want to make sure the group doesn't disappear when it's closed
        var atLeastOneShowingWhenClosed = false;
        // want to make sure the group has something to show / hide
        var atLeastOneChangeable = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var abstractColumn = this.children[i];
            // if the abstractColumn is a grid generated group, there will be no colDef
            var headerGroupShow = abstractColumn.getColumnGroupShow();
            if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_OPEN) {
                atLeastOneShowingWhenOpen = true;
                atLeastOneChangeable = true;
            }
            else if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_CLOSED) {
                atLeastOneShowingWhenClosed = true;
                atLeastOneChangeable = true;
            }
            else {
                atLeastOneShowingWhenOpen = true;
                atLeastOneShowingWhenClosed = true;
            }
        }
        this.expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
    };
    return OriginalColumnGroup;
})();
exports.OriginalColumnGroup = OriginalColumnGroup;

},{"./column":92,"./columnGroup":93}],97:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var eventService_1 = require("../eventService");
var events_1 = require("../events");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var selectionController_1 = require("../selectionController");
var valueService_1 = require("../valueService");
var columnController_1 = require("../columnController/columnController");
var context_1 = require("../context/context");
var constants_1 = require("../constants");
var RowNode = (function () {
    function RowNode() {
        /** Children mapped by the pivot columns */
        this.childrenMapped = {};
        this.selected = false;
    }
    RowNode.prototype.setData = function (data) {
        var oldData = this.data;
        this.data = data;
        var event = { oldData: oldData, newData: data };
        this.dispatchLocalEvent(RowNode.EVENT_DATA_CHANGED, event);
    };
    RowNode.prototype.dispatchLocalEvent = function (eventName, event) {
        if (this.eventService) {
            this.eventService.dispatchEvent(eventName, event);
        }
    };
    // we also allow editing the value via the editors. when it is done via
    // the editors, no 'cell changed' event gets fired, as it's assumed that
    // the cell knows about the change given it's in charge of the editing.
    // this method is for the client to call, so the cell listens for the change
    // event, and also flashes the cell when the change occurs.
    RowNode.prototype.setDataValue = function (colKey, newValue) {
        var column = this.columnController.getOriginalColumn(colKey);
        this.valueService.setValue(this, column, newValue);
        var event = { column: column, newValue: newValue };
        this.dispatchLocalEvent(RowNode.EVENT_CELL_CHANGED, event);
    };
    RowNode.prototype.resetQuickFilterAggregateText = function () {
        this.quickFilterAggregateText = null;
    };
    RowNode.prototype.isSelected = function () {
        // for footers, we just return what our sibling selected state is, as cannot select a footer
        if (this.footer) {
            return this.sibling.isSelected();
        }
        return this.selected;
    };
    RowNode.prototype.deptFirstSearch = function (callback) {
        if (this.childrenAfterGroup) {
            this.childrenAfterGroup.forEach(function (child) { return child.deptFirstSearch(callback); });
        }
        callback(this);
    };
    // + rowController.updateGroupsInSelection()
    RowNode.prototype.calculateSelectedFromChildren = function () {
        var atLeastOneSelected = false;
        var atLeastOneDeSelected = false;
        var atLeastOneMixed = false;
        var newSelectedValue;
        if (this.childrenAfterGroup) {
            for (var i = 0; i < this.childrenAfterGroup.length; i++) {
                var childState = this.childrenAfterGroup[i].isSelected();
                switch (childState) {
                    case true:
                        atLeastOneSelected = true;
                        break;
                    case false:
                        atLeastOneDeSelected = true;
                        break;
                    default:
                        atLeastOneMixed = true;
                        break;
                }
            }
        }
        if (atLeastOneMixed) {
            newSelectedValue = undefined;
        }
        else if (atLeastOneSelected && !atLeastOneDeSelected) {
            newSelectedValue = true;
        }
        else if (!atLeastOneSelected && atLeastOneDeSelected) {
            newSelectedValue = false;
        }
        else {
            newSelectedValue = undefined;
        }
        this.selectThisNode(newSelectedValue);
    };
    RowNode.prototype.calculateSelectedFromChildrenBubbleUp = function () {
        this.calculateSelectedFromChildren();
        if (this.parent) {
            this.parent.calculateSelectedFromChildren();
        }
    };
    RowNode.prototype.setSelectedInitialValue = function (selected) {
        this.selected = selected;
    };
    /** Returns true if this row is selected */
    RowNode.prototype.setSelected = function (newValue, clearSelection, tailingNodeInSequence) {
        if (clearSelection === void 0) { clearSelection = false; }
        if (tailingNodeInSequence === void 0) { tailingNodeInSequence = false; }
        this.setSelectedParams({
            newValue: newValue,
            clearSelection: clearSelection,
            tailingNodeInSequence: tailingNodeInSequence,
            rangeSelect: false
        });
    };
    // to make calling code more readable, this is the same method as setSelected except it takes names parameters
    RowNode.prototype.setSelectedParams = function (params) {
        var newValue = params.newValue === true;
        var clearSelection = params.clearSelection === true;
        var tailingNodeInSequence = params.tailingNodeInSequence === true;
        var rangeSelect = params.rangeSelect === true;
        if (this.floating) {
            console.log('ag-Grid: cannot select floating rows');
            return;
        }
        // if we are a footer, we don't do selection, just pass the info
        // to the sibling (the parent of the group)
        if (this.footer) {
            this.sibling.setSelectedParams(params);
            return;
        }
        if (rangeSelect) {
            var rowModelNormal = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
            var newRowClicked = this.selectionController.getLastSelectedNode() !== this;
            var allowMultiSelect = this.gridOptionsWrapper.isRowSelectionMulti();
            if (rowModelNormal && newRowClicked && allowMultiSelect) {
                this.doRowRangeSelection();
                return;
            }
        }
        this.selectThisNode(newValue);
        var groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
        if (groupSelectsChildren && this.group) {
            this.selectChildNodes(newValue);
        }
        // clear other nodes if not doing multi select
        var actionWasOnThisNode = !tailingNodeInSequence;
        if (actionWasOnThisNode) {
            if (newValue && (clearSelection || !this.gridOptionsWrapper.isRowSelectionMulti())) {
                this.selectionController.clearOtherNodes(this);
            }
            if (groupSelectsChildren && this.parent) {
                this.parent.calculateSelectedFromChildrenBubbleUp();
            }
            // this is the very end of the 'action node', so we are finished all the updates,
            // include any parent / child changes that this method caused
            this.mainEventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
            // so if use next does shift-select, we know where to start the selection from
            if (newValue) {
                this.selectionController.setLastSelectedNode(this);
            }
        }
    };
    // selects all rows between this node and the last selected node (or the top if this is the first selection).
    // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
    // holding down 'shift'.
    RowNode.prototype.doRowRangeSelection = function () {
        var _this = this;
        var lastSelectedNode = this.selectionController.getLastSelectedNode();
        // if lastSelectedNode is missing, we start at the firstrow
        var firstRowHit = !lastSelectedNode;
        var lastRowHit = false;
        var lastRow;
        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
        var inMemoryRowModel = this.rowModel;
        inMemoryRowModel.forEachNodeAfterFilterAndSort(function (rowNode) {
            var lookingForLastRow = firstRowHit && !lastRowHit;
            // check if we need to flip the select switch
            if (!firstRowHit) {
                if (rowNode === lastSelectedNode || rowNode === _this) {
                    firstRowHit = true;
                }
            }
            var skipThisGroupNode = rowNode.group && groupsSelectChildren;
            if (!skipThisGroupNode) {
                var inRange = firstRowHit && !lastRowHit;
                var childOfLastRow = rowNode.isParentOfNode(lastRow);
                rowNode.selectThisNode(inRange || childOfLastRow);
            }
            if (lookingForLastRow) {
                if (rowNode === lastSelectedNode || rowNode === _this) {
                    lastRowHit = true;
                    if (rowNode === lastSelectedNode) {
                        lastRow = lastSelectedNode;
                    }
                    else {
                        lastRow = _this;
                    }
                }
            }
        });
        if (groupsSelectChildren) {
            this.calculatedSelectedForAllGroupNodes();
        }
    };
    RowNode.prototype.isParentOfNode = function (potentialParent) {
        var parentNode = this.parent;
        while (parentNode) {
            if (parentNode === potentialParent) {
                return true;
            }
            parentNode = parentNode.parent;
        }
        return false;
    };
    RowNode.prototype.calculatedSelectedForAllGroupNodes = function () {
        // we have to make sure we do this dept first, as parent nodes
        // will have dependencies on the children having correct values
        var inMemoryRowModel = this.rowModel;
        inMemoryRowModel.getTopLevelNodes().forEach(function (topLevelNode) {
            if (topLevelNode.group) {
                topLevelNode.deptFirstSearch(function (childNode) {
                    if (childNode.group) {
                        childNode.calculateSelectedFromChildren();
                    }
                });
                topLevelNode.calculateSelectedFromChildren();
            }
        });
    };
    RowNode.prototype.selectThisNode = function (newValue) {
        if (this.selected !== newValue) {
            this.selected = newValue;
            if (this.eventService) {
                this.dispatchLocalEvent(RowNode.EVENT_ROW_SELECTED);
            }
            var event = { node: this };
            this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_SELECTED, event);
        }
    };
    RowNode.prototype.selectChildNodes = function (newValue) {
        for (var i = 0; i < this.childrenAfterGroup.length; i++) {
            this.childrenAfterGroup[i].setSelectedParams({
                newValue: newValue,
                clearSelection: false,
                tailingNodeInSequence: true
            });
        }
    };
    RowNode.prototype.addEventListener = function (eventType, listener) {
        if (!this.eventService) {
            this.eventService = new eventService_1.EventService();
        }
        this.eventService.addEventListener(eventType, listener);
    };
    RowNode.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    RowNode.prototype.onMouseEnter = function () {
        this.dispatchLocalEvent(RowNode.EVENT_MOUSE_ENTER);
    };
    RowNode.prototype.onMouseLeave = function () {
        this.dispatchLocalEvent(RowNode.EVENT_MOUSE_LEAVE);
    };
    RowNode.EVENT_ROW_SELECTED = 'rowSelected';
    RowNode.EVENT_DATA_CHANGED = 'dataChanged';
    RowNode.EVENT_CELL_CHANGED = 'cellChanged';
    RowNode.EVENT_MOUSE_ENTER = 'mouseEnter';
    RowNode.EVENT_MOUSE_LEAVE = 'mouseLeave';
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], RowNode.prototype, "mainEventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], RowNode.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], RowNode.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], RowNode.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], RowNode.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], RowNode.prototype, "rowModel", void 0);
    return RowNode;
})();
exports.RowNode = RowNode;

},{"../columnController/columnController":77,"../constants":86,"../context/context":87,"../eventService":98,"../events":99,"../gridOptionsWrapper":109,"../selectionController":152,"../valueService":157}],98:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var logger_1 = require("./logger");
var utils_1 = require('./utils');
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var EventService = (function () {
    function EventService() {
        this.allListeners = {};
        this.globalListeners = [];
    }
    EventService.prototype.agWire = function (loggerFactory, globalEventListener) {
        if (globalEventListener === void 0) { globalEventListener = null; }
        this.logger = loggerFactory.create('EventService');
        if (globalEventListener) {
            this.addGlobalListener(globalEventListener);
        }
    };
    EventService.prototype.getListenerList = function (eventType) {
        var listenerList = this.allListeners[eventType];
        if (!listenerList) {
            listenerList = [];
            this.allListeners[eventType] = listenerList;
        }
        return listenerList;
    };
    EventService.prototype.addEventListener = function (eventType, listener) {
        var listenerList = this.getListenerList(eventType);
        if (listenerList.indexOf(listener) < 0) {
            listenerList.push(listener);
        }
    };
    // for some events, it's important that the model gets to hear about them before the view,
    // as the model may need to update before the view works on the info. if you register
    // via this method, you get notified before the view parts
    EventService.prototype.addModalPriorityEventListener = function (eventType, listener) {
        this.addEventListener(eventType + EventService.PRIORITY, listener);
    };
    EventService.prototype.addGlobalListener = function (listener) {
        this.globalListeners.push(listener);
    };
    EventService.prototype.removeEventListener = function (eventType, listener) {
        var listenerList = this.getListenerList(eventType);
        utils_1.Utils.removeFromArray(listenerList, listener);
    };
    EventService.prototype.removeGlobalListener = function (listener) {
        utils_1.Utils.removeFromArray(this.globalListeners, listener);
    };
    // why do we pass the type here? the type is in ColumnChangeEvent, so unless the
    // type is not in other types of events???
    EventService.prototype.dispatchEvent = function (eventType, event) {
        if (!event) {
            event = {};
        }
        //this.logger.log('dispatching: ' + event);
        // this allows the columnController to get events before anyone else
        var p1ListenerList = this.getListenerList(eventType + EventService.PRIORITY);
        p1ListenerList.forEach(function (listener) {
            listener(event);
        });
        var listenerList = this.getListenerList(eventType);
        listenerList.forEach(function (listener) {
            listener(event);
        });
        this.globalListeners.forEach(function (listener) {
            listener(eventType, event);
        });
    };
    EventService.PRIORITY = '-P1';
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')),
        __param(1, context_2.Qualifier('globalEventListener')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory, Function]), 
        __metadata('design:returntype', void 0)
    ], EventService.prototype, "agWire", null);
    EventService = __decorate([
        context_1.Bean('eventService'), 
        __metadata('design:paramtypes', [])
    ], EventService);
    return EventService;
})();
exports.EventService = EventService;

},{"./context/context":87,"./logger":124,"./utils":156}],99:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Events = (function () {
    function Events() {
    }
    /** A new set of columns has been entered, everything has potentially changed. */
    Events.EVENT_COLUMN_EVERYTHING_CHANGED = 'columnEverythingChanged';
    Events.EVENT_NEW_COLUMNS_LOADED = 'newColumnsLoaded';
    /** A row group column was added, removed or order changed. */
    Events.EVENT_COLUMN_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
    /** A pivot column was added, removed or order changed. */
    Events.EVENT_COLUMN_PIVOT_CHANGED = 'columnPivotChanged';
    /** A pivot column was added, removed or order changed. */
    Events.EVENT_PIVOT_VALUE_CHANGED = 'pivotValueChanged';
    /** A value column was added, removed or agg function was changed. */
    Events.EVENT_COLUMN_VALUE_CHANGED = 'columnValueChanged';
    /** A column was moved */
    Events.EVENT_COLUMN_MOVED = 'columnMoved';
    /** One or more columns was shown / hidden */
    Events.EVENT_COLUMN_VISIBLE = 'columnVisible';
    /** One or more columns was pinned / unpinned*/
    Events.EVENT_COLUMN_PINNED = 'columnPinned';
    /** A column group was opened / closed */
    Events.EVENT_COLUMN_GROUP_OPENED = 'columnGroupOpened';
    /** One or more columns was resized. If just one, the column in the event is set. */
    Events.EVENT_COLUMN_RESIZED = 'columnResized';
    /** A row group was opened / closed */
    Events.EVENT_ROW_GROUP_OPENED = 'rowGroupOpened';
    Events.EVENT_ROW_DATA_CHANGED = 'rowDataChanged';
    Events.EVENT_FLOATING_ROW_DATA_CHANGED = 'floatingRowDataChanged';
    Events.EVENT_RANGE_SELECTION_CHANGED = 'rangeSelectionChanged';
    Events.EVENT_FLASH_CELLS = 'clipboardPaste';
    Events.EVENT_HEADER_HEIGHT_CHANGED = 'headerHeightChanged';
    Events.EVENT_MODEL_UPDATED = 'modelUpdated';
    Events.EVENT_CELL_CLICKED = 'cellClicked';
    Events.EVENT_CELL_DOUBLE_CLICKED = 'cellDoubleClicked';
    Events.EVENT_CELL_CONTEXT_MENU = 'cellContextMenu';
    Events.EVENT_CELL_VALUE_CHANGED = 'cellValueChanged';
    Events.EVENT_CELL_FOCUSED = 'cellFocused';
    Events.EVENT_ROW_SELECTED = 'rowSelected';
    Events.EVENT_SELECTION_CHANGED = 'selectionChanged';
    Events.EVENT_BEFORE_FILTER_CHANGED = 'beforeFilterChanged';
    Events.EVENT_FILTER_CHANGED = 'filterChanged';
    Events.EVENT_AFTER_FILTER_CHANGED = 'afterFilterChanged';
    Events.EVENT_FILTER_MODIFIED = 'filterModified';
    Events.EVENT_BEFORE_SORT_CHANGED = 'beforeSortChanged';
    Events.EVENT_SORT_CHANGED = 'sortChanged';
    Events.EVENT_AFTER_SORT_CHANGED = 'afterSortChanged';
    Events.EVENT_VIRTUAL_ROW_REMOVED = 'virtualRowRemoved';
    Events.EVENT_ROW_CLICKED = 'rowClicked';
    Events.EVENT_ROW_DOUBLE_CLICKED = 'rowDoubleClicked';
    Events.EVENT_GRID_READY = 'gridReady';
    Events.EVENT_GRID_SIZE_CHANGED = 'gridSizeChanged';
    Events.EVENT_VIEWPORT_CHANGED = 'viewportChanged';
    return Events;
})();
exports.Events = Events;

},{}],100:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var logger_1 = require("./logger");
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var ExpressionService = (function () {
    function ExpressionService() {
        this.expressionToFunctionCache = {};
    }
    ExpressionService.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('ExpressionService');
    };
    ExpressionService.prototype.evaluate = function (expression, params) {
        try {
            var javaScriptFunction = this.createExpressionFunction(expression);
            var result = javaScriptFunction(params.value, params.context, params.node, params.data, params.colDef, params.rowIndex, params.api, params.getValue);
            return result;
        }
        catch (e) {
            // the expression failed, which can happen, as it's the client that
            // provides the expression. so print a nice message
            this.logger.log('Processing of the expression failed');
            this.logger.log('Expression = ' + expression);
            this.logger.log('Exception = ' + e);
            return null;
        }
    };
    ExpressionService.prototype.createExpressionFunction = function (expression) {
        // check cache first
        if (this.expressionToFunctionCache[expression]) {
            return this.expressionToFunctionCache[expression];
        }
        // if not found in cache, return the function
        var functionBody = this.createFunctionBody(expression);
        var theFunction = new Function('x, ctx, node, data, colDef, rowIndex, api, getValue', functionBody);
        // store in cache
        this.expressionToFunctionCache[expression] = theFunction;
        return theFunction;
    };
    ExpressionService.prototype.createFunctionBody = function (expression) {
        // if the expression has the 'return' word in it, then use as is,
        // if not, then wrap it with return and ';' to make a function
        if (expression.indexOf('return') >= 0) {
            return expression;
        }
        else {
            return 'return ' + expression + ';';
        }
    };
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], ExpressionService.prototype, "setBeans", null);
    ExpressionService = __decorate([
        context_1.Bean('expressionService'), 
        __metadata('design:paramtypes', [])
    ], ExpressionService);
    return ExpressionService;
})();
exports.ExpressionService = ExpressionService;

},{"./context/context":87,"./logger":124}],101:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var popupService_1 = require("../widgets/popupService");
var valueService_1 = require("../valueService");
var columnController_1 = require("../columnController/columnController");
var textFilter_1 = require("./textFilter");
var numberFilter_1 = require("./numberFilter");
var context_1 = require("../context/context");
var eventService_1 = require("../eventService");
var events_1 = require("../events");
var FilterManager = (function () {
    function FilterManager() {
        this.allFilters = {};
        this.quickFilter = null;
        this.availableFilters = {
            'text': textFilter_1.TextFilter,
            'number': numberFilter_1.NumberFilter
        };
    }
    FilterManager.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.onNewRowsLoaded.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));
        this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText());
    };
    FilterManager.prototype.registerFilter = function (key, Filter) {
        this.availableFilters[key] = Filter;
    };
    FilterManager.prototype.setFilterModel = function (model) {
        var _this = this;
        if (model) {
            // mark the filters as we set them, so any active filters left over we stop
            var modelKeys = Object.keys(model);
            utils_1.Utils.iterateObject(this.allFilters, function (colId, filterWrapper) {
                utils_1.Utils.removeFromArray(modelKeys, colId);
                var newModel = model[colId];
                _this.setModelOnFilterWrapper(filterWrapper.filter, newModel);
            });
            // at this point, processedFields contains data for which we don't have a filter working yet
            utils_1.Utils.iterateArray(modelKeys, function (colId) {
                var column = _this.columnController.getOriginalColumn(colId);
                if (!column) {
                    console.warn('Warning ag-grid setFilterModel - no column found for colId ' + colId);
                    return;
                }
                var filterWrapper = _this.getOrCreateFilterWrapper(column);
                _this.setModelOnFilterWrapper(filterWrapper.filter, model[colId]);
            });
        }
        else {
            utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                _this.setModelOnFilterWrapper(filterWrapper.filter, null);
            });
        }
        this.onFilterChanged();
    };
    FilterManager.prototype.setModelOnFilterWrapper = function (filter, newModel) {
        // because user can provide filters, we provide useful error checking and messages
        if (typeof filter.getApi !== 'function') {
            console.warn('Warning ag-grid - filter missing getApi method, which is needed for getFilterModel');
            return;
        }
        var filterApi = filter.getApi();
        if (typeof filterApi.setModel !== 'function') {
            console.warn('Warning ag-grid - filter API missing setModel method, which is needed for setFilterModel');
            return;
        }
        filterApi.setModel(newModel);
    };
    FilterManager.prototype.getFilterModel = function () {
        var result = {};
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            // because user can provide filters, we provide useful error checking and messages
            if (typeof filterWrapper.filter.getApi !== 'function') {
                console.warn('Warning ag-grid - filter missing getApi method, which is needed for getFilterModel');
                return;
            }
            var filterApi = filterWrapper.filter.getApi();
            if (typeof filterApi.getModel !== 'function') {
                console.warn('Warning ag-grid - filter API missing getModel method, which is needed for getFilterModel');
                return;
            }
            var model = filterApi.getModel();
            if (utils_1.Utils.exists(model)) {
                result[key] = model;
            }
        });
        return result;
    };
    // returns true if any advanced filter (ie not quick filter) active
    FilterManager.prototype.isAdvancedFilterPresent = function () {
        var atLeastOneActive = false;
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            if (!filterWrapper.filter.isFilterActive) {
                console.error('Filter is missing method isFilterActive');
            }
            if (filterWrapper.filter.isFilterActive()) {
                atLeastOneActive = true;
                filterWrapper.column.setFilterActive(true);
            }
            else {
                filterWrapper.column.setFilterActive(false);
            }
        });
        return atLeastOneActive;
    };
    // returns true if quickFilter or advancedFilter
    FilterManager.prototype.isAnyFilterPresent = function () {
        return this.isQuickFilterPresent() || this.advancedFilterPresent || this.externalFilterPresent;
    };
    FilterManager.prototype.doesFilterPass = function (node, filterToSkip) {
        var data = node.data;
        var colKeys = Object.keys(this.allFilters);
        for (var i = 0, l = colKeys.length; i < l; i++) {
            var colId = colKeys[i];
            var filterWrapper = this.allFilters[colId];
            // if no filter, always pass
            if (filterWrapper === undefined) {
                continue;
            }
            if (filterWrapper.filter === filterToSkip) {
                continue;
            }
            // don't bother with filters that are not active
            if (!filterWrapper.filter.isFilterActive()) {
                continue;
            }
            if (!filterWrapper.filter.doesFilterPass) {
                console.error('Filter is missing method doesFilterPass');
            }
            var params = {
                node: node,
                data: data
            };
            if (!filterWrapper.filter.doesFilterPass(params)) {
                return false;
            }
        }
        // all filters passed
        return true;
    };
    FilterManager.prototype.parseQuickFilter = function (newFilter) {
        if (utils_1.Utils.missing(newFilter) || newFilter === "") {
            return null;
        }
        if (this.gridOptionsWrapper.isRowModelVirtual()) {
            console.warn('ag-grid: cannot do quick filtering when doing virtual paging');
            return null;
        }
        return newFilter.toUpperCase();
    };
    // returns true if it has changed (not just same value again)
    FilterManager.prototype.setQuickFilter = function (newFilter) {
        var parsedFilter = this.parseQuickFilter(newFilter);
        if (this.quickFilter !== parsedFilter) {
            this.quickFilter = parsedFilter;
            this.onFilterChanged();
        }
    };
    FilterManager.prototype.onFilterChanged = function () {
        this.eventService.dispatchEvent(events_1.Events.EVENT_BEFORE_FILTER_CHANGED);
        this.advancedFilterPresent = this.isAdvancedFilterPresent();
        this.externalFilterPresent = this.gridOptionsWrapper.isExternalFilterPresent();
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            if (filterWrapper.filter.onAnyFilterChanged) {
                filterWrapper.filter.onAnyFilterChanged();
            }
        });
        this.eventService.dispatchEvent(events_1.Events.EVENT_FILTER_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_AFTER_FILTER_CHANGED);
    };
    FilterManager.prototype.isQuickFilterPresent = function () {
        return this.quickFilter !== null;
    };
    FilterManager.prototype.doesRowPassOtherFilters = function (filterToSkip, node) {
        return this.doesRowPassFilter(node, filterToSkip);
    };
    FilterManager.prototype.doesRowPassFilter = function (node, filterToSkip) {
        //first up, check quick filter
        if (this.isQuickFilterPresent()) {
            if (!node.quickFilterAggregateText) {
                this.aggregateRowForQuickFilter(node);
            }
            if (node.quickFilterAggregateText.indexOf(this.quickFilter) < 0) {
                //quick filter fails, so skip item
                return false;
            }
        }
        //secondly, give the client a chance to reject this row
        if (this.externalFilterPresent) {
            if (!this.gridOptionsWrapper.doesExternalFilterPass(node)) {
                return false;
            }
        }
        //lastly, check our internal advanced filter
        if (this.advancedFilterPresent) {
            if (!this.doesFilterPass(node, filterToSkip)) {
                return false;
            }
        }
        //got this far, all filters pass
        return true;
    };
    FilterManager.prototype.aggregateRowForQuickFilter = function (node) {
        var aggregatedText = '';
        var that = this;
        this.columnController.getAllOriginalColumns().forEach(function (column) {
            var value = that.valueService.getValue(column, node);
            if (value && value !== '') {
                aggregatedText = aggregatedText + value.toString().toUpperCase() + "_";
            }
        });
        node.quickFilterAggregateText = aggregatedText;
    };
    FilterManager.prototype.onNewRowsLoaded = function () {
        var that = this;
        Object.keys(this.allFilters).forEach(function (field) {
            var filter = that.allFilters[field].filter;
            if (filter.onNewRowsLoaded) {
                filter.onNewRowsLoaded();
            }
        });
    };
    FilterManager.prototype.createValueGetter = function (column) {
        var that = this;
        return function valueGetter(node) {
            return that.valueService.getValue(column, node);
        };
    };
    FilterManager.prototype.getFilterApi = function (column) {
        var filterWrapper = this.getOrCreateFilterWrapper(column);
        if (filterWrapper) {
            if (typeof filterWrapper.filter.getApi === 'function') {
                return filterWrapper.filter.getApi();
            }
        }
    };
    FilterManager.prototype.getOrCreateFilterWrapper = function (column) {
        var filterWrapper = this.allFilters[column.getColId()];
        if (!filterWrapper) {
            filterWrapper = this.createFilterWrapper(column);
            this.allFilters[column.getColId()] = filterWrapper;
        }
        return filterWrapper;
    };
    // destroys the filter, so it not longer takes par
    FilterManager.prototype.destroyFilter = function (column) {
        var filterWrapper = this.allFilters[column.getColId()];
        if (filterWrapper) {
            if (filterWrapper.destroy) {
                filterWrapper.destroy();
            }
            delete this.allFilters[column.getColId()];
            this.onFilterChanged();
            filterWrapper.column.setFilterActive(false);
        }
    };
    FilterManager.prototype.createFilterWrapper = function (column) {
        var _this = this;
        var colDef = column.getColDef();
        var filterWrapper = {
            column: column,
            filter: null,
            scope: null,
            gui: null
        };
        if (typeof colDef.filter === 'function') {
            // if user provided a filter, just use it
            // first up, create child scope if needed
            if (this.gridOptionsWrapper.isAngularCompileFilters()) {
                filterWrapper.scope = this.$scope.$new();
                filterWrapper.scope.context = this.gridOptionsWrapper.getContext();
            }
            // now create filter (had to cast to any to get 'new' working)
            this.assertMethodHasNoParameters(colDef.filter);
            filterWrapper.filter = new colDef.filter();
        }
        else if (utils_1.Utils.missing(colDef.filter) || typeof colDef.filter === 'string') {
            var Filter = this.getFilterFromCache(colDef.filter);
            filterWrapper.filter = new Filter();
        }
        else {
            console.error('ag-Grid: colDef.filter should be function or a string');
        }
        this.context.wireBean(filterWrapper.filter);
        var filterChangedCallback = this.onFilterChanged.bind(this);
        var filterModifiedCallback = function () { return _this.eventService.dispatchEvent(events_1.Events.EVENT_FILTER_MODIFIED); };
        var doesRowPassOtherFilters = this.doesRowPassOtherFilters.bind(this, filterWrapper.filter);
        var filterParams = colDef.filterParams;
        var params = {
            column: column,
            colDef: colDef,
            rowModel: this.rowModel,
            filterChangedCallback: filterChangedCallback,
            filterModifiedCallback: filterModifiedCallback,
            filterParams: filterParams,
            localeTextFunc: this.gridOptionsWrapper.getLocaleTextFunc(),
            valueGetter: this.createValueGetter(column),
            doesRowPassOtherFilter: doesRowPassOtherFilters,
            context: this.gridOptionsWrapper.getContext(),
            $scope: filterWrapper.scope
        };
        if (!filterWrapper.filter.init) {
            throw 'Filter is missing method init';
        }
        filterWrapper.filter.init(params);
        if (!filterWrapper.filter.getGui) {
            throw 'Filter is missing method getGui';
        }
        var eFilterGui = document.createElement('div');
        eFilterGui.className = 'ag-filter';
        var guiFromFilter = filterWrapper.filter.getGui();
        if (utils_1.Utils.isNodeOrElement(guiFromFilter)) {
            //a dom node or element was returned, so add child
            eFilterGui.appendChild(guiFromFilter);
        }
        else {
            //otherwise assume it was html, so just insert
            var eTextSpan = document.createElement('span');
            eTextSpan.innerHTML = guiFromFilter;
            eFilterGui.appendChild(eTextSpan);
        }
        if (filterWrapper.scope) {
            filterWrapper.gui = this.$compile(eFilterGui)(filterWrapper.scope)[0];
        }
        else {
            filterWrapper.gui = eFilterGui;
        }
        return filterWrapper;
    };
    FilterManager.prototype.getFilterFromCache = function (filterType) {
        var defaultFilterType = this.enterprise ? 'set' : 'text';
        var defaultFilter = this.availableFilters[defaultFilterType];
        if (utils_1.Utils.missing(filterType)) {
            return defaultFilter;
        }
        if (!this.enterprise && filterType === 'set') {
            console.warn('ag-Grid: Set filter is only available in Enterprise ag-Grid');
            filterType = 'text';
        }
        if (this.availableFilters[filterType]) {
            return this.availableFilters[filterType];
        }
        else {
            console.error('ag-Grid: Could not find filter type ' + filterType);
            return this.availableFilters[defaultFilter];
        }
    };
    FilterManager.prototype.onNewColumnsLoaded = function () {
        this.destroy();
    };
    FilterManager.prototype.destroy = function () {
        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
            if (filterWrapper.filter.destroy) {
                filterWrapper.filter.destroy();
                filterWrapper.column.setFilterActive(false);
            }
        });
        this.allFilters = {};
    };
    FilterManager.prototype.assertMethodHasNoParameters = function (theMethod) {
        var getRowsParams = utils_1.Utils.getFunctionParameters(theMethod);
        if (getRowsParams.length > 0) {
            console.warn('ag-grid: It looks like your filter is of the old type and expecting parameters in the constructor.');
            console.warn('ag-grid: From ag-grid 1.14, the constructor should take no parameters and init() used instead.');
        }
    };
    __decorate([
        context_1.Autowired('$compile'), 
        __metadata('design:type', Object)
    ], FilterManager.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('$scope'), 
        __metadata('design:type', Object)
    ], FilterManager.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], FilterManager.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridCore'), 
        __metadata('design:type', Object)
    ], FilterManager.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], FilterManager.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], FilterManager.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], FilterManager.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], FilterManager.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], FilterManager.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('enterprise'), 
        __metadata('design:type', Boolean)
    ], FilterManager.prototype, "enterprise", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], FilterManager.prototype, "context", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], FilterManager.prototype, "init", null);
    __decorate([
        context_1.PreDestroy, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], FilterManager.prototype, "destroy", null);
    FilterManager = __decorate([
        context_1.Bean('filterManager'), 
        __metadata('design:paramtypes', [])
    ], FilterManager);
    return FilterManager;
})();
exports.FilterManager = FilterManager;

},{"../columnController/columnController":77,"../context/context":87,"../eventService":98,"../events":99,"../gridOptionsWrapper":109,"../utils":156,"../valueService":157,"../widgets/popupService":161,"./numberFilter":102,"./textFilter":103}],102:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('../utils');
var template = '<div>' +
    '<div>' +
    '<select class="ag-filter-select" id="filterType">' +
    '<option value="1">[EQUALS]</option>' +
    '<option value="2">[NOT EQUAL]</option>' +
    '<option value="3">[LESS THAN]</option>' +
    '<option value="4">[LESS THAN OR EQUAL]</option>' +
    '<option value="5">[GREATER THAN]</option>' +
    '<option value="6">[GREATER THAN OR EQUAL]</option>' +
    '</select>' +
    '</div>' +
    '<div>' +
    '<input class="ag-filter-filter" id="filterText" type="text" placeholder="[FILTER...]"/>' +
    '</div>' +
    '<div class="ag-filter-apply-panel" id="applyPanel">' +
    '<button type="button" id="applyButton">[APPLY FILTER]</button>' +
    '</div>' +
    '</div>';
var EQUALS = 1;
var NOT_EQUAL = 2;
var LESS_THAN = 3;
var LESS_THAN_OR_EQUAL = 4;
var GREATER_THAN = 5;
var GREATER_THAN_OR_EQUAL = 6;
var NumberFilter = (function () {
    function NumberFilter() {
    }
    NumberFilter.prototype.init = function (params) {
        this.filterParams = params.filterParams;
        this.applyActive = this.filterParams && this.filterParams.apply === true;
        this.filterChangedCallback = params.filterChangedCallback;
        this.filterModifiedCallback = params.filterModifiedCallback;
        this.localeTextFunc = params.localeTextFunc;
        this.valueGetter = params.valueGetter;
        this.createGui();
        this.filterNumber = null;
        this.filterType = EQUALS;
        this.createApi();
    };
    NumberFilter.prototype.onNewRowsLoaded = function () {
        var keepSelection = this.filterParams && this.filterParams.newRowsAction === 'keep';
        if (!keepSelection) {
            this.api.setType(EQUALS);
            this.api.setFilter(null);
        }
    };
    NumberFilter.prototype.afterGuiAttached = function () {
        this.eFilterTextField.focus();
    };
    NumberFilter.prototype.doesFilterPass = function (node) {
        if (this.filterNumber === null) {
            return true;
        }
        var value = this.valueGetter(node);
        if (!value && value !== 0) {
            return false;
        }
        var valueAsNumber;
        if (typeof value === 'number') {
            valueAsNumber = value;
        }
        else {
            valueAsNumber = parseFloat(value);
        }
        switch (this.filterType) {
            case EQUALS:
                return valueAsNumber === this.filterNumber;
            case LESS_THAN:
                return valueAsNumber < this.filterNumber;
            case GREATER_THAN:
                return valueAsNumber > this.filterNumber;
            case LESS_THAN_OR_EQUAL:
                return valueAsNumber <= this.filterNumber;
            case GREATER_THAN_OR_EQUAL:
                return valueAsNumber >= this.filterNumber;
            case NOT_EQUAL:
                return valueAsNumber != this.filterNumber;
            default:
                // should never happen
                console.warn('invalid filter type ' + this.filterType);
                return false;
        }
    };
    NumberFilter.prototype.getGui = function () {
        return this.eGui;
    };
    NumberFilter.prototype.isFilterActive = function () {
        return this.filterNumber !== null;
    };
    NumberFilter.prototype.createTemplate = function () {
        return template
            .replace('[FILTER...]', this.localeTextFunc('filterOoo', 'Filter...'))
            .replace('[EQUALS]', this.localeTextFunc('equals', 'Equals'))
            .replace('[LESS THAN]', this.localeTextFunc('lessThan', 'Less than'))
            .replace('[GREATER THAN]', this.localeTextFunc('greaterThan', 'Greater than'))
            .replace('[LESS THAN OR EQUAL]', this.localeTextFunc('lessThanOrEqual', 'Less than or equal'))
            .replace('[GREATER THAN OR EQUAL]', this.localeTextFunc('greaterThanOrEqual', 'Greater than or equal'))
            .replace('[NOT EQUAL]', this.localeTextFunc('notEqual', 'Not equal'))
            .replace('[APPLY FILTER]', this.localeTextFunc('applyFilter', 'Apply Filter'));
    };
    NumberFilter.prototype.createGui = function () {
        this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
        this.eFilterTextField = this.eGui.querySelector("#filterText");
        this.eTypeSelect = this.eGui.querySelector("#filterType");
        utils_1.Utils.addChangeListener(this.eFilterTextField, this.onFilterChanged.bind(this));
        this.eTypeSelect.addEventListener("change", this.onTypeChanged.bind(this));
        this.setupApply();
    };
    NumberFilter.prototype.setupApply = function () {
        var _this = this;
        if (this.applyActive) {
            this.eApplyButton = this.eGui.querySelector('#applyButton');
            this.eApplyButton.addEventListener('click', function () {
                _this.filterChangedCallback();
            });
        }
        else {
            utils_1.Utils.removeElement(this.eGui, '#applyPanel');
        }
    };
    NumberFilter.prototype.onTypeChanged = function () {
        this.filterType = parseInt(this.eTypeSelect.value);
        this.filterChanged();
    };
    NumberFilter.prototype.filterChanged = function () {
        this.filterModifiedCallback();
        if (!this.applyActive) {
            this.filterChangedCallback();
        }
    };
    NumberFilter.prototype.onFilterChanged = function () {
        var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
        if (filterText && filterText.trim() === '') {
            filterText = null;
        }
        var newFilter;
        if (filterText !== null && filterText !== undefined) {
            newFilter = parseFloat(filterText);
        }
        else {
            newFilter = null;
        }
        if (this.filterNumber !== newFilter) {
            this.filterNumber = newFilter;
            this.filterChanged();
        }
    };
    NumberFilter.prototype.createApi = function () {
        var that = this;
        this.api = {
            EQUALS: EQUALS,
            NOT_EQUAL: NOT_EQUAL,
            LESS_THAN: LESS_THAN,
            GREATER_THAN: GREATER_THAN,
            LESS_THAN_OR_EQUAL: LESS_THAN_OR_EQUAL,
            GREATER_THAN_OR_EQUAL: GREATER_THAN_OR_EQUAL,
            setType: function (type) {
                that.filterType = type;
                that.eTypeSelect.value = type;
            },
            setFilter: function (filter) {
                filter = utils_1.Utils.makeNull(filter);
                if (filter !== null && !(typeof filter === 'number')) {
                    filter = parseFloat(filter);
                }
                that.filterNumber = filter;
                that.eFilterTextField.value = filter;
            },
            getType: function () {
                return that.filterType;
            },
            getFilter: function () {
                return that.filterNumber;
            },
            getModel: function () {
                if (that.isFilterActive()) {
                    return {
                        type: that.filterType,
                        filter: that.filterNumber
                    };
                }
                else {
                    return null;
                }
            },
            setModel: function (dataModel) {
                if (dataModel) {
                    this.setType(dataModel.type);
                    this.setFilter(dataModel.filter);
                }
                else {
                    this.setFilter(null);
                }
            }
        };
    };
    NumberFilter.prototype.getApi = function () {
        return this.api;
    };
    return NumberFilter;
})();
exports.NumberFilter = NumberFilter;

},{"../utils":156}],103:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('../utils');
var template = '<div>' +
    '<div>' +
    '<select class="ag-filter-select" id="filterType">' +
    '<option value="1">[CONTAINS]</option>' +
    '<option value="2">[EQUALS]</option>' +
    '<option value="3">[NOT EQUALS]</option>' +
    '<option value="4">[STARTS WITH]</option>' +
    '<option value="5">[ENDS WITH]</option>' +
    '</select>' +
    '</div>' +
    '<div>' +
    '<input class="ag-filter-filter" id="filterText" type="text" placeholder="[FILTER...]"/>' +
    '</div>' +
    '<div class="ag-filter-apply-panel" id="applyPanel">' +
    '<button type="button" id="applyButton">[APPLY FILTER]</button>' +
    '</div>' +
    '</div>';
var CONTAINS = 1;
var EQUALS = 2;
var NOT_EQUALS = 3;
var STARTS_WITH = 4;
var ENDS_WITH = 5;
var TextFilter = (function () {
    function TextFilter() {
    }
    TextFilter.prototype.init = function (params) {
        this.filterParams = params.filterParams;
        this.applyActive = this.filterParams && this.filterParams.apply === true;
        this.filterChangedCallback = params.filterChangedCallback;
        this.filterModifiedCallback = params.filterModifiedCallback;
        this.localeTextFunc = params.localeTextFunc;
        this.valueGetter = params.valueGetter;
        this.createGui();
        this.filterText = null;
        this.filterType = CONTAINS;
        this.createApi();
    };
    TextFilter.prototype.onNewRowsLoaded = function () {
        var keepSelection = this.filterParams && this.filterParams.newRowsAction === 'keep';
        if (!keepSelection) {
            this.api.setType(CONTAINS);
            this.api.setFilter(null);
        }
    };
    TextFilter.prototype.afterGuiAttached = function () {
        this.eFilterTextField.focus();
    };
    TextFilter.prototype.doesFilterPass = function (node) {
        if (!this.filterText) {
            return true;
        }
        var value = this.valueGetter(node);
        if (!value) {
            return false;
        }
        var valueLowerCase = value.toString().toLowerCase();
        switch (this.filterType) {
            case CONTAINS:
                return valueLowerCase.indexOf(this.filterText) >= 0;
            case EQUALS:
                return valueLowerCase === this.filterText;
            case NOT_EQUALS:
                return valueLowerCase != this.filterText;
            case STARTS_WITH:
                return valueLowerCase.indexOf(this.filterText) === 0;
            case ENDS_WITH:
                var index = valueLowerCase.lastIndexOf(this.filterText);
                return index >= 0 && index === (valueLowerCase.length - this.filterText.length);
            default:
                // should never happen
                console.warn('invalid filter type ' + this.filterType);
                return false;
        }
    };
    TextFilter.prototype.getGui = function () {
        return this.eGui;
    };
    TextFilter.prototype.isFilterActive = function () {
        return this.filterText !== null;
    };
    TextFilter.prototype.createTemplate = function () {
        return template
            .replace('[FILTER...]', this.localeTextFunc('filterOoo', 'Filter...'))
            .replace('[EQUALS]', this.localeTextFunc('equals', 'Equals'))
            .replace('[NOT EQUALS]', this.localeTextFunc('notEquals', 'Not equals'))
            .replace('[CONTAINS]', this.localeTextFunc('contains', 'Contains'))
            .replace('[STARTS WITH]', this.localeTextFunc('startsWith', 'Starts with'))
            .replace('[ENDS WITH]', this.localeTextFunc('endsWith', 'Ends with'))
            .replace('[APPLY FILTER]', this.localeTextFunc('applyFilter', 'Apply Filter'));
    };
    TextFilter.prototype.createGui = function () {
        this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
        this.eFilterTextField = this.eGui.querySelector("#filterText");
        this.eTypeSelect = this.eGui.querySelector("#filterType");
        utils_1.Utils.addChangeListener(this.eFilterTextField, this.onFilterChanged.bind(this));
        this.eTypeSelect.addEventListener("change", this.onTypeChanged.bind(this));
        this.setupApply();
    };
    TextFilter.prototype.setupApply = function () {
        var _this = this;
        if (this.applyActive) {
            this.eApplyButton = this.eGui.querySelector('#applyButton');
            this.eApplyButton.addEventListener('click', function () {
                _this.filterChangedCallback();
            });
        }
        else {
            utils_1.Utils.removeElement(this.eGui, '#applyPanel');
        }
    };
    TextFilter.prototype.onTypeChanged = function () {
        this.filterType = parseInt(this.eTypeSelect.value);
        this.filterChanged();
    };
    TextFilter.prototype.onFilterChanged = function () {
        var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
        if (filterText && filterText.trim() === '') {
            filterText = null;
        }
        var newFilterText;
        if (filterText !== null && filterText !== undefined) {
            newFilterText = filterText.toLowerCase();
        }
        else {
            newFilterText = null;
        }
        if (this.filterText !== newFilterText) {
            this.filterText = newFilterText;
            this.filterChanged();
        }
    };
    TextFilter.prototype.filterChanged = function () {
        this.filterModifiedCallback();
        if (!this.applyActive) {
            this.filterChangedCallback();
        }
    };
    TextFilter.prototype.createApi = function () {
        var that = this;
        this.api = {
            EQUALS: EQUALS,
            NOT_EQUALS: NOT_EQUALS,
            CONTAINS: CONTAINS,
            STARTS_WITH: STARTS_WITH,
            ENDS_WITH: ENDS_WITH,
            setType: function (type) {
                that.filterType = type;
                that.eTypeSelect.value = type;
            },
            setFilter: function (filter) {
                filter = utils_1.Utils.makeNull(filter);
                if (filter) {
                    that.filterText = filter.toLowerCase();
                    that.eFilterTextField.value = filter;
                }
                else {
                    that.filterText = null;
                    that.eFilterTextField.value = null;
                }
            },
            getType: function () {
                return that.filterType;
            },
            getFilter: function () {
                return that.filterText;
            },
            getModel: function () {
                if (that.isFilterActive()) {
                    return {
                        type: that.filterType,
                        filter: that.filterText
                    };
                }
                else {
                    return null;
                }
            },
            setModel: function (dataModel) {
                if (dataModel) {
                    this.setType(dataModel.type);
                    this.setFilter(dataModel.filter);
                }
                else {
                    this.setFilter(null);
                }
            }
        };
    };
    TextFilter.prototype.getApi = function () {
        return this.api;
    };
    return TextFilter;
})();
exports.TextFilter = TextFilter;

},{"../utils":156}],104:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("./context/context");
var eventService_1 = require("./eventService");
var events_1 = require("./events");
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var columnController_1 = require("./columnController/columnController");
var utils_1 = require("./utils");
var gridCell_1 = require("./entities/gridCell");
var constants_1 = require("./constants");
var FocusedCellController = (function () {
    function FocusedCellController() {
    }
    FocusedCellController.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearFocusedCell.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.clearFocusedCell.bind(this));
        //this.eventService.addEventListener(Events.EVENT_COLUMN_VISIBLE, this.clearFocusedCell.bind(this));
    };
    FocusedCellController.prototype.clearFocusedCell = function () {
        this.focusedCell = null;
        this.onCellFocused(false);
    };
    FocusedCellController.prototype.getFocusedCell = function () {
        return this.focusedCell;
    };
    // we check if the browser is focusing something, and if it is, and
    // it's the cell we think is focused, then return the cell. so this
    // methods returns the cell if a) we think it has focus and b) the
    // browser thinks it has focus. this then returns nothign if we
    // first focus a cell, then second click outside the grid, as then the
    // grid cell will still be focused as far as the grid is conerned,
    // however the browser focus will have moved somewhere else.
    FocusedCellController.prototype.getFocusCellIfBrowserFocused = function () {
        if (!this.focusedCell) {
            return null;
        }
        var browserFocusedCell = this.getGridCellForDomElement(document.activeElement);
        if (!browserFocusedCell) {
            return null;
        }
        var gridFocusId = this.focusedCell.createId();
        var browserFocusId = browserFocusedCell.createId();
        if (gridFocusId === browserFocusId) {
            return this.focusedCell;
        }
        else {
            return null;
        }
    };
    FocusedCellController.prototype.getGridCellForDomElement = function (eBrowserCell) {
        if (!eBrowserCell) {
            return null;
        }
        var column = null;
        var row = null;
        var floating = null;
        var that = this;
        while (eBrowserCell) {
            checkRow(eBrowserCell);
            checkColumn(eBrowserCell);
            eBrowserCell = eBrowserCell.parentNode;
        }
        if (utils_1.Utils.exists(column) && utils_1.Utils.exists(row)) {
            var gridCell = new gridCell_1.GridCell(row, floating, column);
            return gridCell;
        }
        else {
            return null;
        }
        function checkRow(eTarget) {
            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
            var rowId = utils_1.Utils.getElementAttribute(eTarget, 'row');
            if (utils_1.Utils.exists(rowId) && utils_1.Utils.containsClass(eTarget, 'ag-row')) {
                if (rowId.indexOf('ft') === 0) {
                    floating = constants_1.Constants.FLOATING_TOP;
                    rowId = rowId.substr(3);
                }
                else if (rowId.indexOf('fb') === 0) {
                    floating = constants_1.Constants.FLOATING_BOTTOM;
                    rowId = rowId.substr(3);
                }
                else {
                    floating = null;
                }
                row = parseInt(rowId);
            }
        }
        function checkColumn(eTarget) {
            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
            var colId = utils_1.Utils.getElementAttribute(eTarget, 'colid');
            if (utils_1.Utils.exists(colId) && utils_1.Utils.containsClass(eTarget, 'ag-cell')) {
                var foundColumn = that.columnController.getOriginalColumn(colId);
                if (foundColumn) {
                    column = foundColumn;
                }
            }
        }
    };
    FocusedCellController.prototype.setFocusedCell = function (rowIndex, colKey, floating, forceBrowserFocus) {
        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }
        if (this.gridOptionsWrapper.isSuppressCellSelection()) {
            return;
        }
        var column = utils_1.Utils.makeNull(this.columnController.getOriginalColumn(colKey));
        this.focusedCell = new gridCell_1.GridCell(rowIndex, utils_1.Utils.makeNull(floating), column);
        this.onCellFocused(forceBrowserFocus);
    };
    FocusedCellController.prototype.isCellFocused = function (gridCell) {
        if (utils_1.Utils.missing(this.focusedCell)) {
            return false;
        }
        return this.focusedCell.column === gridCell.column && this.isRowFocused(gridCell.rowIndex, gridCell.floating);
    };
    FocusedCellController.prototype.isRowFocused = function (rowIndex, floating) {
        if (utils_1.Utils.missing(this.focusedCell)) {
            return false;
        }
        var floatingOrNull = utils_1.Utils.makeNull(floating);
        return this.focusedCell.rowIndex === rowIndex && this.focusedCell.floating === floatingOrNull;
    };
    FocusedCellController.prototype.onCellFocused = function (forceBrowserFocus) {
        var event = {
            rowIndex: null,
            column: null,
            floating: null,
            forceBrowserFocus: forceBrowserFocus
        };
        if (this.focusedCell) {
            event.rowIndex = this.focusedCell.rowIndex;
            event.column = this.focusedCell.column;
            event.floating = this.focusedCell.floating;
        }
        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_FOCUSED, event);
    };
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], FocusedCellController.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], FocusedCellController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], FocusedCellController.prototype, "columnController", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], FocusedCellController.prototype, "init", null);
    FocusedCellController = __decorate([
        context_1.Bean('focusedCellController'), 
        __metadata('design:paramtypes', [])
    ], FocusedCellController);
    return FocusedCellController;
})();
exports.FocusedCellController = FocusedCellController;

},{"./columnController/columnController":77,"./constants":86,"./context/context":87,"./entities/gridCell":94,"./eventService":98,"./events":99,"./gridOptionsWrapper":109,"./utils":156}],105:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('./utils');
function defaultGroupComparator(valueA, valueB, nodeA, nodeB) {
    var nodeAIsGroup = utils_1.Utils.exists(nodeA) && nodeA.group;
    var nodeBIsGroup = utils_1.Utils.exists(nodeB) && nodeB.group;
    var bothAreGroups = nodeAIsGroup && nodeBIsGroup;
    var bothAreNormal = !nodeAIsGroup && !nodeBIsGroup;
    if (bothAreGroups) {
        return utils_1.Utils.defaultComparator(nodeA.key, nodeB.key);
    }
    else if (bothAreNormal) {
        return utils_1.Utils.defaultComparator(valueA, valueB);
    }
    else if (nodeAIsGroup) {
        return 1;
    }
    else {
        return -1;
    }
}
exports.defaultGroupComparator = defaultGroupComparator;

},{"./utils":156}],106:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var paginationController_1 = require("./rowControllers/paginationController");
var floatingRowModel_1 = require("./rowControllers/floatingRowModel");
var selectionController_1 = require("./selectionController");
var columnController_1 = require("./columnController/columnController");
var rowRenderer_1 = require("./rendering/rowRenderer");
var headerRenderer_1 = require("./headerRendering/headerRenderer");
var filterManager_1 = require("./filter/filterManager");
var valueService_1 = require("./valueService");
var masterSlaveService_1 = require("./masterSlaveService");
var eventService_1 = require("./eventService");
var oldToolPanelDragAndDropService_1 = require("./dragAndDrop/oldToolPanelDragAndDropService");
var gridPanel_1 = require("./gridPanel/gridPanel");
var gridApi_1 = require("./gridApi");
var headerTemplateLoader_1 = require("./headerRendering/headerTemplateLoader");
var balancedColumnTreeBuilder_1 = require("./columnController/balancedColumnTreeBuilder");
var displayedGroupCreator_1 = require("./columnController/displayedGroupCreator");
var expressionService_1 = require("./expressionService");
var templateService_1 = require("./templateService");
var popupService_1 = require("./widgets/popupService");
var logger_1 = require("./logger");
var columnUtils_1 = require("./columnController/columnUtils");
var autoWidthCalculator_1 = require("./rendering/autoWidthCalculator");
var horizontalDragService_1 = require("./headerRendering/horizontalDragService");
var context_1 = require("./context/context");
var csvCreator_1 = require("./csvCreator");
var gridCore_1 = require("./gridCore");
var standardMenu_1 = require("./headerRendering/standardMenu");
var dragAndDropService_1 = require("./dragAndDrop/dragAndDropService");
var dragService_1 = require("./dragAndDrop/dragService");
var sortController_1 = require("./sortController");
var focusedCellController_1 = require("./focusedCellController");
var mouseEventService_1 = require("./gridPanel/mouseEventService");
var cellNavigationService_1 = require("./cellNavigationService");
var utils_1 = require("./utils");
var filterStage_1 = require("./rowControllers/inMemory/filterStage");
var sortStage_1 = require("./rowControllers/inMemory/sortStage");
var flattenStage_1 = require("./rowControllers/inMemory/flattenStage");
var focusService_1 = require("./misc/focusService");
var cellEditorFactory_1 = require("./rendering/cellEditorFactory");
var events_1 = require("./events");
var virtualPageRowModel_1 = require("./rowControllers/virtualPageRowModel");
var inMemoryRowModel_1 = require("./rowControllers/inMemory/inMemoryRowModel");
var cellRendererFactory_1 = require("./rendering/cellRendererFactory");
var cellRendererService_1 = require("./rendering/cellRendererService");
var valueFormatterService_1 = require("./rendering/valueFormatterService");
var pivotService_1 = require("./columnController/pivotService");
var Grid = (function () {
    function Grid(eGridDiv, gridOptions, globalEventListener, $scope, $compile, quickFilterOnScope) {
        if (globalEventListener === void 0) { globalEventListener = null; }
        if ($scope === void 0) { $scope = null; }
        if ($compile === void 0) { $compile = null; }
        if (quickFilterOnScope === void 0) { quickFilterOnScope = null; }
        if (!eGridDiv) {
            console.error('ag-Grid: no div element provided to the grid');
        }
        if (!gridOptions) {
            console.error('ag-Grid: no gridOptions provided to the grid');
        }
        var rowModelClass = this.getRowModelClass(gridOptions);
        var enterprise = utils_1.Utils.exists(Grid.enterpriseBeans);
        this.context = new context_1.Context({
            overrideBeans: Grid.enterpriseBeans,
            seed: {
                enterprise: enterprise,
                gridOptions: gridOptions,
                eGridDiv: eGridDiv,
                $scope: $scope,
                $compile: $compile,
                quickFilterOnScope: quickFilterOnScope,
                globalEventListener: globalEventListener
            },
            beans: [rowModelClass, cellRendererFactory_1.CellRendererFactory, horizontalDragService_1.HorizontalDragService, headerTemplateLoader_1.HeaderTemplateLoader, floatingRowModel_1.FloatingRowModel, dragService_1.DragService,
                displayedGroupCreator_1.DisplayedGroupCreator, eventService_1.EventService, gridOptionsWrapper_1.GridOptionsWrapper, selectionController_1.SelectionController,
                filterManager_1.FilterManager, columnController_1.ColumnController, rowRenderer_1.RowRenderer, pivotService_1.PivotService,
                headerRenderer_1.HeaderRenderer, expressionService_1.ExpressionService, balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder, csvCreator_1.CsvCreator,
                templateService_1.TemplateService, gridPanel_1.GridPanel, popupService_1.PopupService, valueService_1.ValueService, masterSlaveService_1.MasterSlaveService,
                logger_1.LoggerFactory, oldToolPanelDragAndDropService_1.OldToolPanelDragAndDropService, columnUtils_1.ColumnUtils, autoWidthCalculator_1.AutoWidthCalculator, gridApi_1.GridApi,
                paginationController_1.PaginationController, popupService_1.PopupService, gridCore_1.GridCore, standardMenu_1.StandardMenuFactory,
                dragAndDropService_1.DragAndDropService, sortController_1.SortController, columnController_1.ColumnApi, focusedCellController_1.FocusedCellController, mouseEventService_1.MouseEventService,
                cellNavigationService_1.CellNavigationService, filterStage_1.FilterStage, sortStage_1.SortStage, flattenStage_1.FlattenStage, focusService_1.FocusService,
                cellEditorFactory_1.CellEditorFactory, cellRendererService_1.CellRendererService, valueFormatterService_1.ValueFormatterService],
            debug: !!gridOptions.debug
        });
        var eventService = this.context.getBean('eventService');
        var readyEvent = {
            api: gridOptions.api,
            columnApi: gridOptions.columnApi
        };
        eventService.dispatchEvent(events_1.Events.EVENT_GRID_READY, readyEvent);
    }
    Grid.setEnterpriseBeans = function (enterpriseBeans, rowModelClasses) {
        this.enterpriseBeans = enterpriseBeans;
        // the enterprise can inject additional row models. this is how it injects the viewportRowModel
        utils_1.Utils.iterateObject(rowModelClasses, function (key, value) { return Grid.RowModelClasses[key] = value; });
    };
    Grid.prototype.getRowModelClass = function (gridOptions) {
        var rowModelType = gridOptions.rowModelType;
        if (utils_1.Utils.exists(rowModelType)) {
            var rowModelClass = Grid.RowModelClasses[rowModelType];
            if (utils_1.Utils.exists(rowModelClass)) {
                return rowModelClass;
            }
            else {
                console.error('ag-Grid: count not find matching row model for rowModelType ' + rowModelType);
                if (rowModelType === 'viewport') {
                    console.error('ag-Grid: rowModelType viewport is only available in ag-Grid Enterprise');
                }
            }
        }
        return inMemoryRowModel_1.InMemoryRowModel;
    };
    ;
    Grid.prototype.destroy = function () {
        this.context.destroy();
    };
    // the default is InMemoryRowModel, which is also used for pagination.
    // the enterprise adds viewport to this list.
    Grid.RowModelClasses = {
        virtual: virtualPageRowModel_1.VirtualPageRowModel,
        pagination: inMemoryRowModel_1.InMemoryRowModel
    };
    return Grid;
})();
exports.Grid = Grid;

},{"./cellNavigationService":73,"./columnController/balancedColumnTreeBuilder":76,"./columnController/columnController":77,"./columnController/columnUtils":79,"./columnController/displayedGroupCreator":80,"./columnController/pivotService":82,"./context/context":87,"./csvCreator":88,"./dragAndDrop/dragAndDropService":89,"./dragAndDrop/dragService":90,"./dragAndDrop/oldToolPanelDragAndDropService":91,"./eventService":98,"./events":99,"./expressionService":100,"./filter/filterManager":101,"./focusedCellController":104,"./gridApi":107,"./gridCore":108,"./gridOptionsWrapper":109,"./gridPanel/gridPanel":110,"./gridPanel/mouseEventService":111,"./headerRendering/headerRenderer":114,"./headerRendering/headerTemplateLoader":115,"./headerRendering/horizontalDragService":116,"./headerRendering/standardMenu":120,"./logger":124,"./masterSlaveService":125,"./misc/focusService":126,"./rendering/autoWidthCalculator":127,"./rendering/cellEditorFactory":128,"./rendering/cellRendererFactory":135,"./rendering/cellRendererService":136,"./rendering/rowRenderer":143,"./rendering/valueFormatterService":144,"./rowControllers/floatingRowModel":145,"./rowControllers/inMemory/filterStage":146,"./rowControllers/inMemory/flattenStage":147,"./rowControllers/inMemory/inMemoryRowModel":148,"./rowControllers/inMemory/sortStage":149,"./rowControllers/paginationController":150,"./rowControllers/virtualPageRowModel":151,"./selectionController":152,"./sortController":153,"./templateService":155,"./utils":156,"./valueService":157,"./widgets/popupService":161}],107:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var csvCreator_1 = require("./csvCreator");
var rowRenderer_1 = require("./rendering/rowRenderer");
var headerRenderer_1 = require("./headerRendering/headerRenderer");
var filterManager_1 = require("./filter/filterManager");
var columnController_1 = require("./columnController/columnController");
var selectionController_1 = require("./selectionController");
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var gridPanel_1 = require("./gridPanel/gridPanel");
var valueService_1 = require("./valueService");
var masterSlaveService_1 = require("./masterSlaveService");
var eventService_1 = require("./eventService");
var floatingRowModel_1 = require("./rowControllers/floatingRowModel");
var constants_1 = require("./constants");
var context_1 = require("./context/context");
var gridCore_1 = require("./gridCore");
var sortController_1 = require("./sortController");
var paginationController_1 = require("./rowControllers/paginationController");
var focusedCellController_1 = require("./focusedCellController");
var utils_1 = require("./utils");
var cellRendererFactory_1 = require("./rendering/cellRendererFactory");
var cellEditorFactory_1 = require("./rendering/cellEditorFactory");
var GridApi = (function () {
    function GridApi() {
    }
    GridApi.prototype.init = function () {
        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
            this.inMemoryRowModel = this.rowModel;
        }
    };
    /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
    GridApi.prototype.__getMasterSlaveService = function () {
        return this.masterSlaveService;
    };
    GridApi.prototype.getFirstRenderedRow = function () {
        return this.rowRenderer.getFirstVirtualRenderedRow();
    };
    GridApi.prototype.getLastRenderedRow = function () {
        return this.rowRenderer.getLastVirtualRenderedRow();
    };
    GridApi.prototype.getDataAsCsv = function (params) {
        return this.csvCreator.getDataAsCsv(params);
    };
    GridApi.prototype.exportDataAsCsv = function (params) {
        this.csvCreator.exportDataAsCsv(params);
    };
    GridApi.prototype.setDatasource = function (datasource) {
        if (this.gridOptionsWrapper.isRowModelPagination()) {
            this.paginationController.setDatasource(datasource);
        }
        else if (this.gridOptionsWrapper.isRowModelVirtual()) {
            this.rowModel.setDatasource(datasource);
        }
        else {
            console.warn("ag-Grid: you can only use a datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL + "' or '" + constants_1.Constants.ROW_MODEL_TYPE_PAGINATION + "'");
        }
    };
    GridApi.prototype.setViewportDatasource = function (viewportDatasource) {
        if (this.gridOptionsWrapper.isRowModelViewport()) {
            // this is bad coding, because it's using an interface that's exposed in the enterprise.
            // really we should create an interface in the core for viewportDatasource and let
            // the enterprise implement it, rather than casting to 'any' here
            this.rowModel.setViewportDatasource(viewportDatasource);
        }
        else {
            console.warn("ag-Grid: you can only use a datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT + "'");
        }
    };
    GridApi.prototype.setRowData = function (rowData) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call setRowData unless using normal row model');
        }
        this.inMemoryRowModel.setRowData(rowData, true);
    };
    GridApi.prototype.setFloatingTopRowData = function (rows) {
        this.floatingRowModel.setFloatingTopRowData(rows);
    };
    GridApi.prototype.setFloatingBottomRowData = function (rows) {
        this.floatingRowModel.setFloatingBottomRowData(rows);
    };
    GridApi.prototype.setColumnDefs = function (colDefs) {
        this.columnController.setColumnDefs(colDefs);
    };
    GridApi.prototype.refreshRows = function (rowNodes) {
        this.rowRenderer.refreshRows(rowNodes);
    };
    GridApi.prototype.refreshCells = function (rowNodes, colIds, animate) {
        if (animate === void 0) { animate = false; }
        this.rowRenderer.refreshCells(rowNodes, colIds, animate);
    };
    GridApi.prototype.rowDataChanged = function (rows) {
        this.rowRenderer.rowDataChanged(rows);
    };
    GridApi.prototype.refreshView = function () {
        this.rowRenderer.refreshView();
    };
    GridApi.prototype.softRefreshView = function () {
        this.rowRenderer.softRefreshView();
    };
    GridApi.prototype.refreshGroupRows = function () {
        this.rowRenderer.refreshGroupRows();
    };
    GridApi.prototype.refreshHeader = function () {
        // need to review this - the refreshHeader should also refresh all icons in the header
        this.headerRenderer.refreshHeader();
    };
    GridApi.prototype.isAnyFilterPresent = function () {
        return this.filterManager.isAnyFilterPresent();
    };
    GridApi.prototype.isAdvancedFilterPresent = function () {
        return this.filterManager.isAdvancedFilterPresent();
    };
    GridApi.prototype.isQuickFilterPresent = function () {
        return this.filterManager.isQuickFilterPresent();
    };
    GridApi.prototype.getModel = function () {
        return this.rowModel;
    };
    GridApi.prototype.onGroupExpandedOrCollapsed = function (refreshFromIndex) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call onGroupExpandedOrCollapsed unless using normal row model');
        }
        this.inMemoryRowModel.refreshModel(constants_1.Constants.STEP_MAP, refreshFromIndex);
    };
    GridApi.prototype.refreshInMemoryRowModel = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call refreshInMemoryRowModel unless using normal row model');
        }
        this.inMemoryRowModel.refreshModel(constants_1.Constants.STEP_EVERYTHING);
    };
    GridApi.prototype.expandAll = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call expandAll unless using normal row model');
        }
        this.inMemoryRowModel.expandOrCollapseAll(true);
    };
    GridApi.prototype.collapseAll = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call collapseAll unless using normal row model');
        }
        this.inMemoryRowModel.expandOrCollapseAll(false);
    };
    GridApi.prototype.addVirtualRowListener = function (eventName, rowIndex, callback) {
        if (typeof eventName !== 'string') {
            console.log('ag-Grid: addVirtualRowListener is deprecated, please use addRenderedRowListener.');
        }
        this.addRenderedRowListener(eventName, rowIndex, callback);
    };
    GridApi.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
        if (eventName === 'virtualRowRemoved') {
            console.log('ag-Grid: event virtualRowRemoved is deprecated, now called renderedRowRemoved');
            eventName = '' +
                '';
        }
        if (eventName === 'virtualRowSelected') {
            console.log('ag-Grid: event virtualRowSelected is deprecated, to register for individual row ' +
                'selection events, add a listener directly to the row node.');
        }
        this.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
    };
    GridApi.prototype.setQuickFilter = function (newFilter) {
        this.filterManager.setQuickFilter(newFilter);
    };
    GridApi.prototype.selectIndex = function (index, tryMulti, suppressEvents) {
        console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        this.selectionController.selectIndex(index, tryMulti);
    };
    GridApi.prototype.deselectIndex = function (index, suppressEvents) {
        if (suppressEvents === void 0) { suppressEvents = false; }
        console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        this.selectionController.deselectIndex(index);
    };
    GridApi.prototype.selectNode = function (node, tryMulti, suppressEvents) {
        if (tryMulti === void 0) { tryMulti = false; }
        if (suppressEvents === void 0) { suppressEvents = false; }
        console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        node.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
    };
    GridApi.prototype.deselectNode = function (node, suppressEvents) {
        if (suppressEvents === void 0) { suppressEvents = false; }
        console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
        if (suppressEvents) {
            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
        }
        node.setSelectedParams({ newValue: false });
    };
    GridApi.prototype.selectAll = function () {
        this.selectionController.selectAllRowNodes();
    };
    GridApi.prototype.deselectAll = function () {
        this.selectionController.deselectAllRowNodes();
    };
    GridApi.prototype.recomputeAggregates = function () {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call recomputeAggregates unless using normal row model');
        }
        this.inMemoryRowModel.refreshModel(constants_1.Constants.STEP_AGGREGATE);
    };
    GridApi.prototype.sizeColumnsToFit = function () {
        if (this.gridOptionsWrapper.isForPrint()) {
            console.warn('ag-grid: sizeColumnsToFit does not work when forPrint=true');
            return;
        }
        this.gridPanel.sizeColumnsToFit();
    };
    GridApi.prototype.showLoadingOverlay = function () {
        this.gridPanel.showLoadingOverlay();
    };
    GridApi.prototype.showNoRowsOverlay = function () {
        this.gridPanel.showNoRowsOverlay();
    };
    GridApi.prototype.hideOverlay = function () {
        this.gridPanel.hideOverlay();
    };
    GridApi.prototype.isNodeSelected = function (node) {
        console.log('ag-Grid: no need to call api.isNodeSelected(), just call node.isSelected() instead');
        return node.isSelected();
    };
    GridApi.prototype.getSelectedNodesById = function () {
        console.error('ag-Grid: since version 3.4, getSelectedNodesById no longer exists, use getSelectedNodes() instead');
        return null;
    };
    GridApi.prototype.getSelectedNodes = function () {
        return this.selectionController.getSelectedNodes();
    };
    GridApi.prototype.getSelectedRows = function () {
        return this.selectionController.getSelectedRows();
    };
    GridApi.prototype.getBestCostNodeSelection = function () {
        return this.selectionController.getBestCostNodeSelection();
    };
    GridApi.prototype.getRenderedNodes = function () {
        return this.rowRenderer.getRenderedNodes();
    };
    GridApi.prototype.ensureColIndexVisible = function (index) {
        console.warn('ag-Grid: ensureColIndexVisible(index) no longer supported, use ensureColumnVisible(colKey) instead.');
    };
    GridApi.prototype.ensureColumnVisible = function (key) {
        this.gridPanel.ensureColumnVisible(key);
    };
    GridApi.prototype.ensureIndexVisible = function (index) {
        this.gridPanel.ensureIndexVisible(index);
    };
    GridApi.prototype.ensureNodeVisible = function (comparator) {
        this.gridCore.ensureNodeVisible(comparator);
    };
    GridApi.prototype.forEachLeafNode = function (callback) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call forEachNodeAfterFilter unless using normal row model');
        }
        this.inMemoryRowModel.forEachLeafNode(callback);
    };
    GridApi.prototype.forEachNode = function (callback) {
        this.rowModel.forEachNode(callback);
    };
    GridApi.prototype.forEachNodeAfterFilter = function (callback) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call forEachNodeAfterFilter unless using normal row model');
        }
        this.inMemoryRowModel.forEachNodeAfterFilter(callback);
    };
    GridApi.prototype.forEachNodeAfterFilterAndSort = function (callback) {
        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
            console.log('cannot call forEachNodeAfterFilterAndSort unless using normal row model');
        }
        this.inMemoryRowModel.forEachNodeAfterFilterAndSort(callback);
    };
    GridApi.prototype.getFilterApiForColDef = function (colDef) {
        console.warn('ag-grid API method getFilterApiForColDef deprecated, use getFilterApi instead');
        return this.getFilterApi(colDef);
    };
    GridApi.prototype.getFilterApi = function (key) {
        var column = this.columnController.getOriginalColumn(key);
        if (column) {
            return this.filterManager.getFilterApi(column);
        }
    };
    GridApi.prototype.destroyFilter = function (key) {
        var column = this.columnController.getOriginalColumn(key);
        if (column) {
            return this.filterManager.destroyFilter(column);
        }
    };
    GridApi.prototype.getColumnDef = function (key) {
        var column = this.columnController.getOriginalColumn(key);
        if (column) {
            return column.getColDef();
        }
        else {
            return null;
        }
    };
    GridApi.prototype.onFilterChanged = function () {
        this.filterManager.onFilterChanged();
    };
    GridApi.prototype.setSortModel = function (sortModel) {
        this.sortController.setSortModel(sortModel);
    };
    GridApi.prototype.getSortModel = function () {
        return this.sortController.getSortModel();
    };
    GridApi.prototype.setFilterModel = function (model) {
        this.filterManager.setFilterModel(model);
    };
    GridApi.prototype.getFilterModel = function () {
        return this.filterManager.getFilterModel();
    };
    GridApi.prototype.getFocusedCell = function () {
        return this.focusedCellController.getFocusedCell();
    };
    GridApi.prototype.setFocusedCell = function (rowIndex, colKey, floating) {
        this.focusedCellController.setFocusedCell(rowIndex, colKey, floating, true);
    };
    GridApi.prototype.setHeaderHeight = function (headerHeight) {
        this.gridOptionsWrapper.setHeaderHeight(headerHeight);
    };
    GridApi.prototype.showToolPanel = function (show) {
        this.gridCore.showToolPanel(show);
    };
    GridApi.prototype.isToolPanelShowing = function () {
        return this.gridCore.isToolPanelShowing();
    };
    GridApi.prototype.doLayout = function () {
        this.gridCore.doLayout();
    };
    GridApi.prototype.getValue = function (colKey, rowNode) {
        var column = this.columnController.getOriginalColumn(colKey);
        return this.valueService.getValue(column, rowNode);
    };
    GridApi.prototype.addEventListener = function (eventType, listener) {
        this.eventService.addEventListener(eventType, listener);
    };
    GridApi.prototype.addGlobalListener = function (listener) {
        this.eventService.addGlobalListener(listener);
    };
    GridApi.prototype.removeEventListener = function (eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    };
    GridApi.prototype.removeGlobalListener = function (listener) {
        this.eventService.removeGlobalListener(listener);
    };
    GridApi.prototype.dispatchEvent = function (eventType, event) {
        this.eventService.dispatchEvent(eventType, event);
    };
    GridApi.prototype.destroy = function () {
        this.context.destroy();
    };
    GridApi.prototype.resetQuickFilter = function () {
        this.rowModel.forEachNode(function (node) { return node.quickFilterAggregateText = null; });
    };
    GridApi.prototype.getRangeSelections = function () {
        if (this.rangeController) {
            return this.rangeController.getCellRanges();
        }
        else {
            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
            return null;
        }
    };
    GridApi.prototype.addRangeSelection = function (rangeSelection) {
        if (!this.rangeController) {
            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
        }
        this.rangeController.addRange(rangeSelection);
    };
    GridApi.prototype.clearRangeSelection = function () {
        if (!this.rangeController) {
            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
        }
        this.rangeController.clearSelection();
    };
    GridApi.prototype.copySelectedRowsToClipboard = function () {
        if (!this.clipboardService) {
            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
        }
        this.clipboardService.copySelectedRowsToClipboard();
    };
    GridApi.prototype.copySelectedRangeToClipboard = function () {
        if (!this.clipboardService) {
            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
        }
        this.clipboardService.copySelectedRangeToClipboard();
    };
    GridApi.prototype.copySelectedRangeDown = function () {
        if (!this.clipboardService) {
            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
        }
        this.clipboardService.copyRangeDown();
    };
    GridApi.prototype.showColumnMenuAfterButtonClick = function (colKey, buttonElement) {
        var column = this.columnController.getOriginalColumn(colKey);
        this.menuFactory.showMenuAfterButtonClick(column, buttonElement);
    };
    GridApi.prototype.showColumnMenuAfterMouseClick = function (colKey, mouseEvent) {
        var column = this.columnController.getOriginalColumn(colKey);
        this.menuFactory.showMenuAfterMouseEvent(column, mouseEvent);
    };
    GridApi.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        this.rowRenderer.stopEditing(cancel);
    };
    __decorate([
        context_1.Autowired('csvCreator'), 
        __metadata('design:type', csvCreator_1.CsvCreator)
    ], GridApi.prototype, "csvCreator", void 0);
    __decorate([
        context_1.Autowired('gridCore'), 
        __metadata('design:type', gridCore_1.GridCore)
    ], GridApi.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'), 
        __metadata('design:type', rowRenderer_1.RowRenderer)
    ], GridApi.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('headerRenderer'), 
        __metadata('design:type', headerRenderer_1.HeaderRenderer)
    ], GridApi.prototype, "headerRenderer", void 0);
    __decorate([
        context_1.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], GridApi.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], GridApi.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], GridApi.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridApi.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], GridApi.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], GridApi.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('masterSlaveService'), 
        __metadata('design:type', masterSlaveService_1.MasterSlaveService)
    ], GridApi.prototype, "masterSlaveService", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], GridApi.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('floatingRowModel'), 
        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
    ], GridApi.prototype, "floatingRowModel", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], GridApi.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], GridApi.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('sortController'), 
        __metadata('design:type', sortController_1.SortController)
    ], GridApi.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('paginationController'), 
        __metadata('design:type', paginationController_1.PaginationController)
    ], GridApi.prototype, "paginationController", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'), 
        __metadata('design:type', focusedCellController_1.FocusedCellController)
    ], GridApi.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Optional('rangeController'), 
        __metadata('design:type', Object)
    ], GridApi.prototype, "rangeController", void 0);
    __decorate([
        context_1.Optional('clipboardService'), 
        __metadata('design:type', Object)
    ], GridApi.prototype, "clipboardService", void 0);
    __decorate([
        context_1.Autowired('menuFactory'), 
        __metadata('design:type', Object)
    ], GridApi.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('cellRendererFactory'), 
        __metadata('design:type', cellRendererFactory_1.CellRendererFactory)
    ], GridApi.prototype, "cellRendererFactory", void 0);
    __decorate([
        context_1.Autowired('cellEditorFactory'), 
        __metadata('design:type', cellEditorFactory_1.CellEditorFactory)
    ], GridApi.prototype, "cellEditorFactory", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], GridApi.prototype, "init", null);
    GridApi = __decorate([
        context_1.Bean('gridApi'), 
        __metadata('design:paramtypes', [])
    ], GridApi);
    return GridApi;
})();
exports.GridApi = GridApi;

},{"./columnController/columnController":77,"./constants":86,"./context/context":87,"./csvCreator":88,"./eventService":98,"./filter/filterManager":101,"./focusedCellController":104,"./gridCore":108,"./gridOptionsWrapper":109,"./gridPanel/gridPanel":110,"./headerRendering/headerRenderer":114,"./masterSlaveService":125,"./rendering/cellEditorFactory":128,"./rendering/cellRendererFactory":135,"./rendering/rowRenderer":143,"./rowControllers/floatingRowModel":145,"./rowControllers/paginationController":150,"./selectionController":152,"./sortController":153,"./utils":156,"./valueService":157}],108:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var paginationController_1 = require("./rowControllers/paginationController");
var columnController_1 = require("./columnController/columnController");
var rowRenderer_1 = require("./rendering/rowRenderer");
var filterManager_1 = require("./filter/filterManager");
var eventService_1 = require("./eventService");
var gridPanel_1 = require("./gridPanel/gridPanel");
var logger_1 = require("./logger");
var constants_1 = require("./constants");
var popupService_1 = require("./widgets/popupService");
var events_1 = require("./events");
var borderLayout_1 = require("./layout/borderLayout");
var context_1 = require("./context/context");
var focusedCellController_1 = require("./focusedCellController");
var component_1 = require("./widgets/component");
var GridCore = (function () {
    function GridCore(loggerFactory) {
        this.logger = loggerFactory.create('GridCore');
    }
    GridCore.prototype.init = function () {
        var _this = this;
        // and the last bean, done in it's own section, as it's optional
        var toolPanelGui;
        var eSouthPanel = this.createSouthPanel();
        if (this.toolPanel && !this.gridOptionsWrapper.isForPrint()) {
            toolPanelGui = this.toolPanel.getGui();
        }
        var rowGroupGui;
        if (this.rowGroupCompFactory) {
            this.rowGroupComp = this.rowGroupCompFactory.create();
            rowGroupGui = this.rowGroupComp.getGui();
        }
        this.eRootPanel = new borderLayout_1.BorderLayout({
            center: this.gridPanel.getLayout(),
            east: toolPanelGui,
            north: rowGroupGui,
            south: eSouthPanel,
            dontFill: this.gridOptionsWrapper.isForPrint(),
            name: 'eRootPanel'
        });
        // see what the grid options are for default of toolbar
        this.showToolPanel(this.gridOptionsWrapper.isShowToolPanel());
        this.eGridDiv.appendChild(this.eRootPanel.getGui());
        // if using angular, watch for quickFilter changes
        if (this.$scope) {
            this.$scope.$watch(this.quickFilterOnScope, function (newFilter) { return _this.filterManager.setQuickFilter(newFilter); });
        }
        if (!this.gridOptionsWrapper.isForPrint()) {
            this.addWindowResizeListener();
        }
        this.doLayout();
        this.finished = false;
        this.periodicallyDoLayout();
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onRowGroupChanged.bind(this));
        this.onRowGroupChanged();
        this.logger.log('ready');
    };
    GridCore.prototype.getRootGui = function () {
        return this.eRootPanel.getGui();
    };
    GridCore.prototype.createSouthPanel = function () {
        if (!this.statusBar && this.gridOptionsWrapper.isEnableStatusBar()) {
            console.warn('ag-Grid: status bar is only available in ag-Grid-Enterprise');
        }
        var statusBarEnabled = this.statusBar && this.gridOptionsWrapper.isEnableStatusBar();
        var paginationPanelEnabled = this.gridOptionsWrapper.isRowModelPagination() && !this.gridOptionsWrapper.isForPrint();
        if (!statusBarEnabled && !paginationPanelEnabled) {
            return null;
        }
        var eSouthPanel = document.createElement('div');
        if (statusBarEnabled) {
            eSouthPanel.appendChild(this.statusBar.getGui());
        }
        if (paginationPanelEnabled) {
            eSouthPanel.appendChild(this.paginationController.getGui());
        }
        return eSouthPanel;
    };
    GridCore.prototype.onRowGroupChanged = function () {
        if (!this.rowGroupComp) {
            return;
        }
        var rowGroupPanelShow = this.gridOptionsWrapper.getRowGroupPanelShow();
        if (rowGroupPanelShow === constants_1.Constants.ALWAYS) {
            this.eRootPanel.setNorthVisible(true);
        }
        else if (rowGroupPanelShow === constants_1.Constants.ONLY_WHEN_GROUPING) {
            var grouping = !this.columnController.isRowGroupEmpty();
            this.eRootPanel.setNorthVisible(grouping);
        }
        else {
            this.eRootPanel.setNorthVisible(false);
        }
    };
    GridCore.prototype.addWindowResizeListener = function () {
        var that = this;
        // putting this into a function, so when we remove the function,
        // we are sure we are removing the exact same function (i'm not
        // sure what 'bind' does to the function reference, if it's safe
        // the result from 'bind').
        this.windowResizeListener = function resizeListener() {
            that.doLayout();
        };
        window.addEventListener('resize', this.windowResizeListener);
    };
    GridCore.prototype.periodicallyDoLayout = function () {
        if (!this.finished) {
            var that = this;
            setTimeout(function () {
                that.doLayout();
                that.gridPanel.periodicallyCheck();
                that.periodicallyDoLayout();
            }, 500);
        }
    };
    GridCore.prototype.showToolPanel = function (show) {
        if (show && !this.toolPanel) {
            console.warn('ag-Grid: toolPanel is only available in ag-Grid Enterprise');
            this.toolPanelShowing = false;
            return;
        }
        this.toolPanelShowing = show;
        this.eRootPanel.setEastVisible(show);
    };
    GridCore.prototype.isToolPanelShowing = function () {
        return this.toolPanelShowing;
    };
    GridCore.prototype.destroy = function () {
        if (this.windowResizeListener) {
            window.removeEventListener('resize', this.windowResizeListener);
            this.logger.log('Removing windowResizeListener');
        }
        this.finished = true;
        this.eGridDiv.removeChild(this.eRootPanel.getGui());
        this.logger.log('Grid DOM removed');
    };
    GridCore.prototype.ensureNodeVisible = function (comparator) {
        if (this.doingVirtualPaging) {
            throw 'Cannot use ensureNodeVisible when doing virtual paging, as we cannot check rows that are not in memory';
        }
        // look for the node index we want to display
        var rowCount = this.rowModel.getRowCount();
        var comparatorIsAFunction = typeof comparator === 'function';
        var indexToSelect = -1;
        // go through all the nodes, find the one we want to show
        for (var i = 0; i < rowCount; i++) {
            var node = this.rowModel.getRow(i);
            if (comparatorIsAFunction) {
                if (comparator(node)) {
                    indexToSelect = i;
                    break;
                }
            }
            else {
                // check object equality against node and data
                if (comparator === node || comparator === node.data) {
                    indexToSelect = i;
                    break;
                }
            }
        }
        if (indexToSelect >= 0) {
            this.gridPanel.ensureIndexVisible(indexToSelect);
        }
    };
    GridCore.prototype.doLayout = function () {
        // need to do layout first, as drawVirtualRows and setPinnedColHeight
        // need to know the result of the resizing of the panels.
        var sizeChanged = this.eRootPanel.doLayout();
        // both of the two below should be done in gridPanel, the gridPanel should register 'resize' to the panel
        if (sizeChanged) {
            this.rowRenderer.drawVirtualRows();
            var event = {
                clientWidth: this.eRootPanel.getGui().clientWidth,
                clientHeight: this.eRootPanel.getGui().clientHeight
            };
            this.eventService.dispatchEvent(events_1.Events.EVENT_GRID_SIZE_CHANGED, event);
        }
    };
    __decorate([
        context_1.Autowired('gridOptions'), 
        __metadata('design:type', Object)
    ], GridCore.prototype, "gridOptions", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridCore.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('paginationController'), 
        __metadata('design:type', paginationController_1.PaginationController)
    ], GridCore.prototype, "paginationController", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], GridCore.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], GridCore.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'), 
        __metadata('design:type', rowRenderer_1.RowRenderer)
    ], GridCore.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], GridCore.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], GridCore.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], GridCore.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('eGridDiv'), 
        __metadata('design:type', HTMLElement)
    ], GridCore.prototype, "eGridDiv", void 0);
    __decorate([
        context_1.Autowired('$scope'), 
        __metadata('design:type', Object)
    ], GridCore.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('quickFilterOnScope'), 
        __metadata('design:type', String)
    ], GridCore.prototype, "quickFilterOnScope", void 0);
    __decorate([
        context_1.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], GridCore.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'), 
        __metadata('design:type', focusedCellController_1.FocusedCellController)
    ], GridCore.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Optional('rowGroupCompFactory'), 
        __metadata('design:type', Object)
    ], GridCore.prototype, "rowGroupCompFactory", void 0);
    __decorate([
        context_1.Optional('toolPanel'), 
        __metadata('design:type', component_1.Component)
    ], GridCore.prototype, "toolPanel", void 0);
    __decorate([
        context_1.Optional('statusBar'), 
        __metadata('design:type', component_1.Component)
    ], GridCore.prototype, "statusBar", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], GridCore.prototype, "init", null);
    __decorate([
        context_1.PreDestroy, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], GridCore.prototype, "destroy", null);
    GridCore = __decorate([
        context_1.Bean('gridCore'),
        __param(0, context_1.Qualifier('loggerFactory')), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory])
    ], GridCore);
    return GridCore;
})();
exports.GridCore = GridCore;

},{"./columnController/columnController":77,"./constants":86,"./context/context":87,"./eventService":98,"./events":99,"./filter/filterManager":101,"./focusedCellController":104,"./gridOptionsWrapper":109,"./gridPanel/gridPanel":110,"./layout/borderLayout":121,"./logger":124,"./rendering/rowRenderer":143,"./rowControllers/paginationController":150,"./widgets/component":158,"./widgets/popupService":161}],109:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var eventService_1 = require("./eventService");
var constants_1 = require("./constants");
var componentUtil_1 = require("./components/componentUtil");
var gridApi_1 = require("./gridApi");
var context_1 = require("./context/context");
var columnController_1 = require("./columnController/columnController");
var events_1 = require("./events");
var utils_1 = require("./utils");
var DEFAULT_ROW_HEIGHT = 25;
var DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE = 5;
var DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE = 5;
function isTrue(value) {
    return value === true || value === 'true';
}
function positiveNumberOrZero(value, defaultValue) {
    if (value > 0) {
        return value;
    }
    else {
        // zero gets returned if number is missing or the wrong type
        return defaultValue;
    }
}
var GridOptionsWrapper = (function () {
    function GridOptionsWrapper() {
    }
    GridOptionsWrapper.prototype.agWire = function (gridApi, columnApi) {
        this.headerHeight = this.gridOptions.headerHeight;
        this.gridOptions.api = gridApi;
        this.gridOptions.columnApi = columnApi;
        this.checkForDeprecated();
    };
    GridOptionsWrapper.prototype.init = function () {
        this.eventService.addGlobalListener(this.globalEventHandler.bind(this));
        if (this.isGroupSelectsChildren() && this.isSuppressParentsInRowNodes()) {
            console.warn('ag-Grid: groupSelectsChildren does not work wth suppressParentsInRowNodes, this selection method needs the part in rowNode to work');
        }
        if (this.isGroupSelectsChildren() && !this.isRowSelectionMulti()) {
            console.warn('ag-Grid: rowSelectionMulti must be true for groupSelectsChildren to make sense');
        }
    };
    GridOptionsWrapper.prototype.isEnterprise = function () { return this.enterprise; };
    GridOptionsWrapper.prototype.isRowSelection = function () { return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple"; };
    GridOptionsWrapper.prototype.isRowDeselection = function () { return isTrue(this.gridOptions.rowDeselection); };
    GridOptionsWrapper.prototype.isRowSelectionMulti = function () { return this.gridOptions.rowSelection === 'multiple'; };
    GridOptionsWrapper.prototype.getContext = function () { return this.gridOptions.context; };
    GridOptionsWrapper.prototype.isRowModelPagination = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_PAGINATION; };
    GridOptionsWrapper.prototype.isRowModelVirtual = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL; };
    GridOptionsWrapper.prototype.isRowModelViewport = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT; };
    GridOptionsWrapper.prototype.isRowModelDefault = function () { return !(this.isRowModelPagination() || this.isRowModelVirtual() || this.isRowModelViewport()); };
    GridOptionsWrapper.prototype.isShowToolPanel = function () { return isTrue(this.gridOptions.showToolPanel); };
    GridOptionsWrapper.prototype.isToolPanelSuppressGroups = function () { return isTrue(this.gridOptions.toolPanelSuppressGroups); };
    GridOptionsWrapper.prototype.isToolPanelSuppressValues = function () { return isTrue(this.gridOptions.toolPanelSuppressValues); };
    GridOptionsWrapper.prototype.isEnableCellChangeFlash = function () { return isTrue(this.gridOptions.enableCellChangeFlash); };
    GridOptionsWrapper.prototype.isGroupSelectsChildren = function () { return isTrue(this.gridOptions.groupSelectsChildren); };
    GridOptionsWrapper.prototype.isGroupIncludeFooter = function () { return isTrue(this.gridOptions.groupIncludeFooter); };
    GridOptionsWrapper.prototype.isGroupSuppressBlankHeader = function () { return isTrue(this.gridOptions.groupSuppressBlankHeader); };
    GridOptionsWrapper.prototype.isSuppressRowClickSelection = function () { return isTrue(this.gridOptions.suppressRowClickSelection); };
    GridOptionsWrapper.prototype.isSuppressCellSelection = function () { return isTrue(this.gridOptions.suppressCellSelection); };
    GridOptionsWrapper.prototype.isSuppressMultiSort = function () { return isTrue(this.gridOptions.suppressMultiSort); };
    GridOptionsWrapper.prototype.isGroupSuppressAutoColumn = function () { return isTrue(this.gridOptions.groupSuppressAutoColumn); };
    GridOptionsWrapper.prototype.isSuppressDragLeaveHidesColumns = function () { return isTrue(this.gridOptions.suppressDragLeaveHidesColumns); };
    GridOptionsWrapper.prototype.isForPrint = function () { return isTrue(this.gridOptions.forPrint); };
    GridOptionsWrapper.prototype.isSuppressHorizontalScroll = function () { return isTrue(this.gridOptions.suppressHorizontalScroll); };
    GridOptionsWrapper.prototype.isSuppressLoadingOverlay = function () { return isTrue(this.gridOptions.suppressLoadingOverlay); };
    GridOptionsWrapper.prototype.isSuppressNoRowsOverlay = function () { return isTrue(this.gridOptions.suppressNoRowsOverlay); };
    GridOptionsWrapper.prototype.isSuppressFieldDotNotation = function () { return isTrue(this.gridOptions.suppressFieldDotNotation); };
    GridOptionsWrapper.prototype.getFloatingTopRowData = function () { return this.gridOptions.floatingTopRowData; };
    GridOptionsWrapper.prototype.getFloatingBottomRowData = function () { return this.gridOptions.floatingBottomRowData; };
    GridOptionsWrapper.prototype.getQuickFilterText = function () { return this.gridOptions.quickFilterText; };
    GridOptionsWrapper.prototype.isUnSortIcon = function () { return isTrue(this.gridOptions.unSortIcon); };
    GridOptionsWrapper.prototype.isSuppressMenuHide = function () { return isTrue(this.gridOptions.suppressMenuHide); };
    GridOptionsWrapper.prototype.getRowStyle = function () { return this.gridOptions.rowStyle; };
    GridOptionsWrapper.prototype.getRowClass = function () { return this.gridOptions.rowClass; };
    GridOptionsWrapper.prototype.getRowStyleFunc = function () { return this.gridOptions.getRowStyle; };
    GridOptionsWrapper.prototype.getRowClassFunc = function () { return this.gridOptions.getRowClass; };
    GridOptionsWrapper.prototype.getBusinessKeyForNodeFunc = function () { return this.gridOptions.getBusinessKeyForNode; };
    GridOptionsWrapper.prototype.getHeaderCellRenderer = function () { return this.gridOptions.headerCellRenderer; };
    GridOptionsWrapper.prototype.getApi = function () { return this.gridOptions.api; };
    GridOptionsWrapper.prototype.getColumnApi = function () { return this.gridOptions.columnApi; };
    GridOptionsWrapper.prototype.isEnableColResize = function () { return isTrue(this.gridOptions.enableColResize); };
    GridOptionsWrapper.prototype.isSingleClickEdit = function () { return isTrue(this.gridOptions.singleClickEdit); };
    GridOptionsWrapper.prototype.getGroupDefaultExpanded = function () { return this.gridOptions.groupDefaultExpanded; };
    GridOptionsWrapper.prototype.getRowData = function () { return this.gridOptions.rowData; };
    GridOptionsWrapper.prototype.isGroupUseEntireRow = function () { return isTrue(this.gridOptions.groupUseEntireRow); };
    GridOptionsWrapper.prototype.getGroupColumnDef = function () { return this.gridOptions.groupColumnDef; };
    GridOptionsWrapper.prototype.isGroupSuppressRow = function () { return isTrue(this.gridOptions.groupSuppressRow); };
    GridOptionsWrapper.prototype.getRowGroupPanelShow = function () { return this.gridOptions.rowGroupPanelShow; };
    GridOptionsWrapper.prototype.isAngularCompileRows = function () { return isTrue(this.gridOptions.angularCompileRows); };
    GridOptionsWrapper.prototype.isAngularCompileFilters = function () { return isTrue(this.gridOptions.angularCompileFilters); };
    GridOptionsWrapper.prototype.isAngularCompileHeaders = function () { return isTrue(this.gridOptions.angularCompileHeaders); };
    GridOptionsWrapper.prototype.isDebug = function () { return isTrue(this.gridOptions.debug); };
    GridOptionsWrapper.prototype.getColumnDefs = function () { return this.gridOptions.columnDefs; };
    GridOptionsWrapper.prototype.getDatasource = function () { return this.gridOptions.datasource; };
    GridOptionsWrapper.prototype.getViewportDatasource = function () { return this.gridOptions.viewportDatasource; };
    GridOptionsWrapper.prototype.isEnableSorting = function () { return isTrue(this.gridOptions.enableSorting) || isTrue(this.gridOptions.enableServerSideSorting); };
    GridOptionsWrapper.prototype.isEnableCellExpressions = function () { return isTrue(this.gridOptions.enableCellExpressions); };
    GridOptionsWrapper.prototype.isSuppressMiddleClickScrolls = function () { return isTrue(this.gridOptions.suppressMiddleClickScrolls); };
    GridOptionsWrapper.prototype.isSuppressPreventDefaultOnMouseWheel = function () { return isTrue(this.gridOptions.suppressPreventDefaultOnMouseWheel); };
    GridOptionsWrapper.prototype.isEnableServerSideSorting = function () { return isTrue(this.gridOptions.enableServerSideSorting); };
    GridOptionsWrapper.prototype.isSuppressContextMenu = function () { return isTrue(this.gridOptions.suppressContextMenu); };
    GridOptionsWrapper.prototype.isEnableFilter = function () { return isTrue(this.gridOptions.enableFilter) || isTrue(this.gridOptions.enableServerSideFilter); };
    GridOptionsWrapper.prototype.isEnableServerSideFilter = function () { return this.gridOptions.enableServerSideFilter; };
    GridOptionsWrapper.prototype.isSuppressScrollLag = function () { return isTrue(this.gridOptions.suppressScrollLag); };
    GridOptionsWrapper.prototype.isSuppressMovableColumns = function () { return isTrue(this.gridOptions.suppressMovableColumns); };
    GridOptionsWrapper.prototype.isSuppressColumnMoveAnimation = function () { return isTrue(this.gridOptions.suppressColumnMoveAnimation); };
    GridOptionsWrapper.prototype.isSuppressMenuColumnPanel = function () { return isTrue(this.gridOptions.suppressMenuColumnPanel); };
    GridOptionsWrapper.prototype.isSuppressMenuFilterPanel = function () { return isTrue(this.gridOptions.suppressMenuFilterPanel); };
    GridOptionsWrapper.prototype.isSuppressMenuMainPanel = function () { return isTrue(this.gridOptions.suppressMenuMainPanel); };
    GridOptionsWrapper.prototype.isEnableRangeSelection = function () { return isTrue(this.gridOptions.enableRangeSelection); };
    GridOptionsWrapper.prototype.isRememberGroupStateWhenNewData = function () { return isTrue(this.gridOptions.rememberGroupStateWhenNewData); };
    GridOptionsWrapper.prototype.getIcons = function () { return this.gridOptions.icons; };
    GridOptionsWrapper.prototype.getIsScrollLag = function () { return this.gridOptions.isScrollLag; };
    GridOptionsWrapper.prototype.getSortingOrder = function () { return this.gridOptions.sortingOrder; };
    GridOptionsWrapper.prototype.getSlaveGrids = function () { return this.gridOptions.slaveGrids; };
    GridOptionsWrapper.prototype.getGroupRowRenderer = function () { return this.gridOptions.groupRowRenderer; };
    GridOptionsWrapper.prototype.getGroupRowRendererParams = function () { return this.gridOptions.groupRowRendererParams; };
    GridOptionsWrapper.prototype.getGroupRowInnerRenderer = function () { return this.gridOptions.groupRowInnerRenderer; };
    GridOptionsWrapper.prototype.getOverlayLoadingTemplate = function () { return this.gridOptions.overlayLoadingTemplate; };
    GridOptionsWrapper.prototype.getOverlayNoRowsTemplate = function () { return this.gridOptions.overlayNoRowsTemplate; };
    GridOptionsWrapper.prototype.getCheckboxSelection = function () { return this.gridOptions.checkboxSelection; };
    GridOptionsWrapper.prototype.isSuppressAutoSize = function () { return isTrue(this.gridOptions.suppressAutoSize); };
    GridOptionsWrapper.prototype.isSuppressParentsInRowNodes = function () { return isTrue(this.gridOptions.suppressParentsInRowNodes); };
    GridOptionsWrapper.prototype.isEnableStatusBar = function () { return isTrue(this.gridOptions.enableStatusBar); };
    GridOptionsWrapper.prototype.getHeaderCellTemplate = function () { return this.gridOptions.headerCellTemplate; };
    GridOptionsWrapper.prototype.getHeaderCellTemplateFunc = function () { return this.gridOptions.getHeaderCellTemplate; };
    GridOptionsWrapper.prototype.getNodeChildDetailsFunc = function () { return this.gridOptions.getNodeChildDetails; };
    GridOptionsWrapper.prototype.getGroupRowAggNodesFunc = function () { return this.gridOptions.groupRowAggNodes; };
    GridOptionsWrapper.prototype.getContextMenuItemsFunc = function () { return this.gridOptions.getContextMenuItems; };
    GridOptionsWrapper.prototype.getMainMenuItemsFunc = function () { return this.gridOptions.getMainMenuItems; };
    GridOptionsWrapper.prototype.getProcessCellForClipboardFunc = function () { return this.gridOptions.processCellForClipboard; };
    GridOptionsWrapper.prototype.getViewportRowModelPageSize = function () { return positiveNumberOrZero(this.gridOptions.viewportRowModelPageSize, DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE); };
    GridOptionsWrapper.prototype.getViewportRowModelBufferSize = function () { return positiveNumberOrZero(this.gridOptions.viewportRowModelBufferSize, DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE); };
    // public getCellRenderers(): {[key: string]: {new(): ICellRenderer} | ICellRendererFunc} { return this.gridOptions.cellRenderers; }
    // public getCellEditors(): {[key: string]: {new(): ICellEditor}} { return this.gridOptions.cellEditors; }
    GridOptionsWrapper.prototype.executeProcessRowPostCreateFunc = function (params) {
        if (this.gridOptions.processRowPostCreate) {
            this.gridOptions.processRowPostCreate(params);
        }
    };
    // properties
    GridOptionsWrapper.prototype.getHeaderHeight = function () {
        if (typeof this.headerHeight === 'number') {
            return this.headerHeight;
        }
        else {
            return 25;
        }
    };
    GridOptionsWrapper.prototype.setHeaderHeight = function (headerHeight) {
        this.headerHeight = headerHeight;
        this.eventService.dispatchEvent(events_1.Events.EVENT_HEADER_HEIGHT_CHANGED);
    };
    GridOptionsWrapper.prototype.isExternalFilterPresent = function () {
        if (typeof this.gridOptions.isExternalFilterPresent === 'function') {
            return this.gridOptions.isExternalFilterPresent();
        }
        else {
            return false;
        }
    };
    GridOptionsWrapper.prototype.doesExternalFilterPass = function (node) {
        if (typeof this.gridOptions.doesExternalFilterPass === 'function') {
            return this.gridOptions.doesExternalFilterPass(node);
        }
        else {
            return false;
        }
    };
    GridOptionsWrapper.prototype.getMinColWidth = function () {
        if (this.gridOptions.minColWidth > GridOptionsWrapper.MIN_COL_WIDTH) {
            return this.gridOptions.minColWidth;
        }
        else {
            return GridOptionsWrapper.MIN_COL_WIDTH;
        }
    };
    GridOptionsWrapper.prototype.getMaxColWidth = function () {
        if (this.gridOptions.maxColWidth > GridOptionsWrapper.MIN_COL_WIDTH) {
            return this.gridOptions.maxColWidth;
        }
        else {
            return null;
        }
    };
    GridOptionsWrapper.prototype.getColWidth = function () {
        if (typeof this.gridOptions.colWidth !== 'number' || this.gridOptions.colWidth < GridOptionsWrapper.MIN_COL_WIDTH) {
            return 200;
        }
        else {
            return this.gridOptions.colWidth;
        }
    };
    GridOptionsWrapper.prototype.getRowBuffer = function () {
        if (typeof this.gridOptions.rowBuffer === 'number') {
            if (this.gridOptions.rowBuffer < 0) {
                console.warn('ag-Grid: rowBuffer should not be negative');
            }
            return this.gridOptions.rowBuffer;
        }
        else {
            return constants_1.Constants.ROW_BUFFER_SIZE;
        }
    };
    GridOptionsWrapper.prototype.checkForDeprecated = function () {
        // casting to generic object, so typescript compiles even though
        // we are looking for attributes that don't exist
        var options = this.gridOptions;
        if (options.suppressUnSort) {
            console.warn('ag-grid: as of v1.12.4 suppressUnSort is not used. Please use sortOrder instead.');
        }
        if (options.suppressDescSort) {
            console.warn('ag-grid: as of v1.12.4 suppressDescSort is not used. Please use sortOrder instead.');
        }
        if (options.groupAggFields) {
            console.warn('ag-grid: as of v3 groupAggFields is not used. Please add appropriate agg fields to your columns.');
        }
        if (options.groupHidePivotColumns) {
            console.warn('ag-grid: as of v3 groupHidePivotColumns is not used as pivot columns are now called rowGroup columns. Please refer to the documentation');
        }
        if (options.groupKeys) {
            console.warn('ag-grid: as of v3 groupKeys is not used. You need to set rowGroupIndex on the columns to group. Please refer to the documentation');
        }
        if (options.ready || options.onReady) {
            console.warn('ag-grid: as of v3.3 ready event is now called gridReady, so the callback should be onGridReady');
        }
        if (typeof options.groupDefaultExpanded === 'boolean') {
            console.warn('ag-grid: groupDefaultExpanded can no longer be boolean. for groupDefaultExpanded=true, use groupDefaultExpanded=9999 instead, to expand all the groups');
        }
        if (options.onRowDeselected || options.rowDeselected) {
            console.warn('ag-grid: since version 3.4 event rowDeselected no longer exists, please check the docs');
        }
        if (options.rowsAlreadyGrouped) {
            console.warn('ag-grid: since version 3.4 rowsAlreadyGrouped no longer exists, please use getNodeChildDetails() instead');
        }
        if (options.groupAggFunction) {
            console.warn('ag-grid: since version 4.3.x groupAggFunction is now called groupRowAggNodes');
        }
    };
    GridOptionsWrapper.prototype.getLocaleTextFunc = function () {
        if (this.gridOptions.localeTextFunc) {
            return this.gridOptions.localeTextFunc;
        }
        var that = this;
        return function (key, defaultValue) {
            var localeText = that.gridOptions.localeText;
            if (localeText && localeText[key]) {
                return localeText[key];
            }
            else {
                return defaultValue;
            }
        };
    };
    // responsible for calling the onXXX functions on gridOptions
    GridOptionsWrapper.prototype.globalEventHandler = function (eventName, event) {
        var callbackMethodName = componentUtil_1.ComponentUtil.getCallbackForEvent(eventName);
        if (typeof this.gridOptions[callbackMethodName] === 'function') {
            this.gridOptions[callbackMethodName](event);
        }
    };
    // we don't allow dynamic row height for virtual paging
    GridOptionsWrapper.prototype.getRowHeightAsNumber = function () {
        var rowHeight = this.gridOptions.rowHeight;
        if (utils_1.Utils.missing(rowHeight)) {
            return DEFAULT_ROW_HEIGHT;
        }
        else if (typeof this.gridOptions.rowHeight === 'number') {
            return this.gridOptions.rowHeight;
        }
        else {
            console.warn('ag-Grid row height must be a number if not using standard row model');
            return DEFAULT_ROW_HEIGHT;
        }
    };
    GridOptionsWrapper.prototype.getRowHeightForNode = function (rowNode) {
        if (typeof this.gridOptions.rowHeight === 'number') {
            return this.gridOptions.rowHeight;
        }
        else if (typeof this.gridOptions.getRowHeight === 'function') {
            var params = {
                node: rowNode,
                data: rowNode.data,
                api: this.gridOptions.api,
                context: this.gridOptions.context
            };
            return this.gridOptions.getRowHeight(params);
        }
        else {
            return DEFAULT_ROW_HEIGHT;
        }
    };
    GridOptionsWrapper.MIN_COL_WIDTH = 10;
    __decorate([
        context_1.Autowired('gridOptions'), 
        __metadata('design:type', Object)
    ], GridOptionsWrapper.prototype, "gridOptions", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], GridOptionsWrapper.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], GridOptionsWrapper.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('enterprise'), 
        __metadata('design:type', Boolean)
    ], GridOptionsWrapper.prototype, "enterprise", void 0);
    __decorate([
        __param(0, context_1.Qualifier('gridApi')),
        __param(1, context_1.Qualifier('columnApi')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [gridApi_1.GridApi, columnController_1.ColumnApi]), 
        __metadata('design:returntype', void 0)
    ], GridOptionsWrapper.prototype, "agWire", null);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], GridOptionsWrapper.prototype, "init", null);
    GridOptionsWrapper = __decorate([
        context_1.Bean('gridOptionsWrapper'), 
        __metadata('design:paramtypes', [])
    ], GridOptionsWrapper);
    return GridOptionsWrapper;
})();
exports.GridOptionsWrapper = GridOptionsWrapper;

},{"./columnController/columnController":77,"./components/componentUtil":85,"./constants":86,"./context/context":87,"./eventService":98,"./events":99,"./gridApi":107,"./utils":156}],110:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var utils_1 = require("../utils");
var masterSlaveService_1 = require("../masterSlaveService");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var columnController_1 = require("../columnController/columnController");
var rowRenderer_1 = require("../rendering/rowRenderer");
var floatingRowModel_1 = require("../rowControllers/floatingRowModel");
var borderLayout_1 = require("../layout/borderLayout");
var logger_1 = require("../logger");
var context_1 = require("../context/context");
var eventService_1 = require("../eventService");
var events_1 = require("../events");
var dragService_1 = require("../dragAndDrop/dragService");
var constants_1 = require("../constants");
var selectionController_1 = require("../selectionController");
var csvCreator_1 = require("../csvCreator");
var mouseEventService_1 = require("./mouseEventService");
var focusedCellController_1 = require("../focusedCellController");
// in the html below, it is important that there are no white space between some of the divs, as if there is white space,
// it won't render correctly in safari, as safari renders white space as a gap
var gridHtml = '<div>' +
    // header
    '<div class="ag-header">' +
    '<div class="ag-pinned-left-header"></div>' +
    '<div class="ag-pinned-right-header"></div>' +
    '<div class="ag-header-viewport">' +
    '<div class="ag-header-container"></div>' +
    '</div>' +
    '<div class="ag-header-overlay"></div>' +
    '</div>' +
    // floating top
    '<div class="ag-floating-top">' +
    '<div class="ag-pinned-left-floating-top"></div>' +
    '<div class="ag-pinned-right-floating-top"></div>' +
    '<div class="ag-floating-top-viewport">' +
    '<div class="ag-floating-top-container"></div>' +
    '</div>' +
    '</div>' +
    // floating bottom
    '<div class="ag-floating-bottom">' +
    '<div class="ag-pinned-left-floating-bottom"></div>' +
    '<div class="ag-pinned-right-floating-bottom"></div>' +
    '<div class="ag-floating-bottom-viewport">' +
    '<div class="ag-floating-bottom-container"></div>' +
    '</div>' +
    '</div>' +
    // body
    '<div class="ag-body">' +
    '<div class="ag-pinned-left-cols-viewport">' +
    '<div class="ag-pinned-left-cols-container"></div>' +
    '</div>' +
    '<div class="ag-pinned-right-cols-viewport">' +
    '<div class="ag-pinned-right-cols-container"></div>' +
    '</div>' +
    '<div class="ag-body-viewport-wrapper">' +
    '<div class="ag-body-viewport">' +
    '<div class="ag-body-container"></div>' +
    '</div>' +
    '</div>' +
    '</div>' +
    '</div>';
var gridForPrintHtml = '<div>' +
    // header
    '<div class="ag-header-container"></div>' +
    // floating
    '<div class="ag-floating-top-container"></div>' +
    // body
    '<div class="ag-body-container"></div>' +
    // floating bottom
    '<div class="ag-floating-bottom-container"></div>' +
    '</div>';
// wrapping in outer div, and wrapper, is needed to center the loading icon
// The idea for centering came from here: http://www.vanseodesign.com/css/vertical-centering/
var mainOverlayTemplate = '<div class="ag-overlay-panel">' +
    '<div class="ag-overlay-wrapper ag-overlay-[OVERLAY_NAME]-wrapper">[OVERLAY_TEMPLATE]</div>' +
    '</div>';
var defaultLoadingOverlayTemplate = '<span class="ag-overlay-loading-center">[LOADING...]</span>';
var defaultNoRowsOverlayTemplate = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>';
var GridPanel = (function () {
    function GridPanel() {
        this.scrollLagCounter = 0;
        this.lastLeftPosition = -1;
        this.lastTopPosition = -1;
        this.animationThreadCount = 0;
    }
    GridPanel.prototype.agWire = function (loggerFactory) {
        // makes code below more readable if we pull 'forPrint' out
        this.forPrint = this.gridOptionsWrapper.isForPrint();
        this.scrollWidth = utils_1.Utils.getScrollbarWidth();
        this.logger = loggerFactory.create('GridPanel');
        this.findElements();
    };
    GridPanel.prototype.onRowDataChanged = function () {
        if (this.rowModel.isEmpty() && !this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
            this.showNoRowsOverlay();
        }
        else {
            this.hideOverlay();
        }
    };
    GridPanel.prototype.getLayout = function () {
        return this.layout;
    };
    GridPanel.prototype.init = function () {
        this.addEventListeners();
        this.addDragListeners();
        this.layout = new borderLayout_1.BorderLayout({
            overlays: {
                loading: utils_1.Utils.loadTemplate(this.createLoadingOverlayTemplate()),
                noRows: utils_1.Utils.loadTemplate(this.createNoRowsOverlayTemplate())
            },
            center: this.eRoot,
            dontFill: this.forPrint,
            name: 'eGridPanel'
        });
        this.layout.addSizeChangeListener(this.sizeHeaderAndBody.bind(this));
        this.addScrollListener();
        if (this.gridOptionsWrapper.isSuppressHorizontalScroll()) {
            this.eBodyViewport.style.overflowX = 'hidden';
        }
        if (this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData()) {
            this.showLoadingOverlay();
        }
        this.setWidthsOfContainers();
        this.showPinnedColContainersIfNeeded();
        this.sizeHeaderAndBody();
        this.disableBrowserDragging();
        this.addShortcutKeyListeners();
        this.addCellListeners();
    };
    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
    GridPanel.prototype.disableBrowserDragging = function () {
        this.eRoot.addEventListener('dragstart', function (event) {
            if (event.target instanceof HTMLImageElement) {
                event.preventDefault();
                return false;
            }
        });
    };
    GridPanel.prototype.addEventListeners = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnsChanged.bind(this));
        //this.eventService.addEventListener(Events.EVENT_COLUMN_VALUE_CHANGE, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, this.sizeHeaderAndBody.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_HEADER_HEIGHT_CHANGED, this.sizeHeaderAndBody.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_PIVOT_VALUE_CHANGED, this.sizeHeaderAndBody.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_PIVOT_VALUE_CHANGED, this.onColumnsChanged.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this));
    };
    GridPanel.prototype.addDragListeners = function () {
        var _this = this;
        if (this.forPrint // no range select when doing 'for print'
            || !this.gridOptionsWrapper.isEnableRangeSelection() // no range selection if no property
            || utils_1.Utils.missing(this.rangeController)) {
            return;
        }
        var containers = [this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer,
            this.eFloatingTop, this.eFloatingBottom];
        containers.forEach(function (container) {
            _this.dragService.addDragSource({
                dragStartPixels: 0,
                eElement: container,
                onDragStart: _this.rangeController.onDragStart.bind(_this.rangeController),
                onDragStop: _this.rangeController.onDragStop.bind(_this.rangeController),
                onDragging: _this.rangeController.onDragging.bind(_this.rangeController)
            });
        });
    };
    GridPanel.prototype.addCellListeners = function () {
        var _this = this;
        var eventNames = ['click', 'mousedown', 'dblclick', 'contextmenu'];
        var that = this;
        eventNames.forEach(function (eventName) {
            _this.eAllCellContainers.forEach(function (container) {
                return container.addEventListener(eventName, function (mouseEvent) {
                    var eventSource = this;
                    that.processMouseEvent(eventName, mouseEvent, eventSource);
                });
            });
        });
    };
    GridPanel.prototype.processMouseEvent = function (eventName, mouseEvent, eventSource) {
        var cell = this.mouseEventService.getCellForMouseEvent(mouseEvent);
        if (utils_1.Utils.exists(cell)) {
            //console.log(`row = ${cell.rowIndex}, floating = ${floating}`);
            this.rowRenderer.onMouseEvent(eventName, mouseEvent, eventSource, cell);
        }
        // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'
        // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse
        // button in the browser). so this property allows the user to receive middle button clicks if
        // they want.
        if (this.gridOptionsWrapper.isSuppressMiddleClickScrolls() && mouseEvent.which === 2) {
            mouseEvent.preventDefault();
        }
    };
    GridPanel.prototype.addShortcutKeyListeners = function () {
        var _this = this;
        this.eAllCellContainers.forEach(function (container) {
            container.addEventListener('keydown', function (event) {
                if (event.ctrlKey || event.metaKey) {
                    switch (event.which) {
                        case constants_1.Constants.KEY_A: return _this.onCtrlAndA(event);
                        case constants_1.Constants.KEY_C: return _this.onCtrlAndC(event);
                        case constants_1.Constants.KEY_V: return _this.onCtrlAndV(event);
                        case constants_1.Constants.KEY_D: return _this.onCtrlAndD(event);
                    }
                }
            });
        });
    };
    GridPanel.prototype.onCtrlAndA = function (event) {
        if (this.rangeController && this.rowModel.isRowsToRender()) {
            var rowEnd;
            var floatingStart;
            var floatingEnd;
            if (this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_TOP)) {
                floatingStart = null;
            }
            else {
                floatingStart = constants_1.Constants.FLOATING_TOP;
            }
            if (this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_BOTTOM)) {
                floatingEnd = null;
                rowEnd = this.rowModel.getRowCount() - 1;
            }
            else {
                floatingEnd = constants_1.Constants.FLOATING_BOTTOM;
                rowEnd = this.floatingRowModel.getFloatingBottomRowData().length = 1;
            }
            var allDisplayedColumns = this.columnController.getAllDisplayedColumns();
            if (utils_1.Utils.missingOrEmpty(allDisplayedColumns)) {
                return;
            }
            this.rangeController.setRange({
                rowStart: 0,
                floatingStart: floatingStart,
                rowEnd: rowEnd,
                floatingEnd: floatingEnd,
                columnStart: allDisplayedColumns[0],
                columnEnd: allDisplayedColumns[allDisplayedColumns.length - 1]
            });
        }
        event.preventDefault();
        return false;
    };
    GridPanel.prototype.onCtrlAndC = function (event) {
        if (!this.clipboardService) {
            return;
        }
        var focusedCell = this.focusedCellController.getFocusedCell();
        this.clipboardService.copyToClipboard();
        event.preventDefault();
        // the copy operation results in loosing focus on the cell,
        // because of the trickery the copy logic uses with a temporary
        // widget. so we set it back again.
        if (focusedCell) {
            this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);
        }
        return false;
    };
    GridPanel.prototype.onCtrlAndV = function (event) {
        if (!this.rangeController) {
            return;
        }
        this.clipboardService.pasteFromClipboard();
        return false;
    };
    GridPanel.prototype.onCtrlAndD = function (event) {
        if (!this.clipboardService) {
            return;
        }
        this.clipboardService.copyRangeDown();
        event.preventDefault();
        return false;
    };
    GridPanel.prototype.getPinnedLeftFloatingTop = function () {
        return this.ePinnedLeftFloatingTop;
    };
    GridPanel.prototype.getPinnedRightFloatingTop = function () {
        return this.ePinnedRightFloatingTop;
    };
    GridPanel.prototype.getFloatingTopContainer = function () {
        return this.eFloatingTopContainer;
    };
    GridPanel.prototype.getPinnedLeftFloatingBottom = function () {
        return this.ePinnedLeftFloatingBottom;
    };
    GridPanel.prototype.getPinnedRightFloatingBottom = function () {
        return this.ePinnedRightFloatingBottom;
    };
    GridPanel.prototype.getFloatingBottomContainer = function () {
        return this.eFloatingBottomContainer;
    };
    GridPanel.prototype.createOverlayTemplate = function (name, defaultTemplate, userProvidedTemplate) {
        var template = mainOverlayTemplate
            .replace('[OVERLAY_NAME]', name);
        if (userProvidedTemplate) {
            template = template.replace('[OVERLAY_TEMPLATE]', userProvidedTemplate);
        }
        else {
            template = template.replace('[OVERLAY_TEMPLATE]', defaultTemplate);
        }
        return template;
    };
    GridPanel.prototype.createLoadingOverlayTemplate = function () {
        var userProvidedTemplate = this.gridOptionsWrapper.getOverlayLoadingTemplate();
        var templateNotLocalised = this.createOverlayTemplate('loading', defaultLoadingOverlayTemplate, userProvidedTemplate);
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        var templateLocalised = templateNotLocalised.replace('[LOADING...]', localeTextFunc('loadingOoo', 'Loading...'));
        return templateLocalised;
    };
    GridPanel.prototype.createNoRowsOverlayTemplate = function () {
        var userProvidedTemplate = this.gridOptionsWrapper.getOverlayNoRowsTemplate();
        var templateNotLocalised = this.createOverlayTemplate('no-rows', defaultNoRowsOverlayTemplate, userProvidedTemplate);
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        var templateLocalised = templateNotLocalised.replace('[NO_ROWS_TO_SHOW]', localeTextFunc('noRowsToShow', 'No Rows To Show'));
        return templateLocalised;
    };
    GridPanel.prototype.ensureIndexVisible = function (index) {
        this.logger.log('ensureIndexVisible: ' + index);
        var lastRow = this.rowModel.getRowCount();
        if (typeof index !== 'number' || index < 0 || index >= lastRow) {
            console.warn('invalid row index for ensureIndexVisible: ' + index);
            return;
        }
        var nodeAtIndex = this.rowModel.getRow(index);
        var rowTopPixel = nodeAtIndex.rowTop;
        var rowBottomPixel = rowTopPixel + nodeAtIndex.rowHeight;
        var viewportTopPixel = this.eBodyViewport.scrollTop;
        var viewportHeight = this.eBodyViewport.offsetHeight;
        var scrollShowing = this.isHorizontalScrollShowing();
        if (scrollShowing) {
            viewportHeight -= this.scrollWidth;
        }
        var viewportBottomPixel = viewportTopPixel + viewportHeight;
        var viewportScrolledPastRow = viewportTopPixel > rowTopPixel;
        var viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel;
        var eViewportToScroll = this.columnController.isPinningRight() ? this.ePinnedRightColsViewport : this.eBodyViewport;
        if (viewportScrolledPastRow) {
            // if row is before, scroll up with row at top
            eViewportToScroll.scrollTop = rowTopPixel;
        }
        else if (viewportScrolledBeforeRow) {
            // if row is below, scroll down with row at bottom
            var newScrollPosition = rowBottomPixel - viewportHeight;
            eViewportToScroll.scrollTop = newScrollPosition;
        }
        // otherwise, row is already in view, so do nothing
    };
    // + moveColumnController
    GridPanel.prototype.getCenterWidth = function () {
        return this.eBodyViewport.clientWidth;
    };
    GridPanel.prototype.isHorizontalScrollShowing = function () {
        var result = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
        return result;
    };
    GridPanel.prototype.isVerticalScrollShowing = function () {
        if (this.columnController.isPinningRight()) {
            // if pinning right, then the scroll bar can show, however for some reason
            // it overlays the grid and doesn't take space.
            return false;
        }
        else {
            return this.eBodyViewport.clientHeight < this.eBodyViewport.scrollHeight;
        }
    };
    // gets called every 500 ms. we use this to set padding on right pinned column
    GridPanel.prototype.periodicallyCheck = function () {
        if (this.columnController.isPinningRight()) {
            var bodyHorizontalScrollShowing = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
            if (bodyHorizontalScrollShowing) {
                this.ePinnedRightColsContainer.style.marginBottom = this.scrollWidth + 'px';
            }
            else {
                this.ePinnedRightColsContainer.style.marginBottom = '';
            }
        }
    };
    GridPanel.prototype.ensureColumnVisible = function (key) {
        var column = this.columnController.getOriginalColumn(key);
        if (column.isPinned()) {
            console.warn('calling ensureIndexVisible on a ' + column.getPinned() + ' pinned column doesn\'t make sense for column ' + column.getColId());
            return;
        }
        if (!this.columnController.isColumnDisplayed(column)) {
            console.warn('column is not currently visible');
            return;
        }
        var colLeftPixel = column.getLeft();
        var colRightPixel = colLeftPixel + column.getActualWidth();
        var viewportLeftPixel = this.eBodyViewport.scrollLeft;
        var viewportWidth = this.eBodyViewport.offsetWidth;
        var scrollShowing = this.eBodyViewport.clientHeight < this.eBodyViewport.scrollHeight;
        if (scrollShowing) {
            viewportWidth -= this.scrollWidth;
        }
        var viewportRightPixel = viewportLeftPixel + viewportWidth;
        var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;
        var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;
        if (viewportScrolledPastCol) {
            // if viewport's left side is after col's left side, scroll right to pull col into viewport at left
            this.eBodyViewport.scrollLeft = colLeftPixel;
        }
        else if (viewportScrolledBeforeCol) {
            // if viewport's right side is before col's right side, scroll left to pull col into viewport at right
            var newScrollPosition = colRightPixel - viewportWidth;
            this.eBodyViewport.scrollLeft = newScrollPosition;
        }
        // otherwise, col is already in view, so do nothing
    };
    GridPanel.prototype.showLoadingOverlay = function () {
        if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {
            this.layout.showOverlay('loading');
        }
    };
    GridPanel.prototype.showNoRowsOverlay = function () {
        if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
            this.layout.showOverlay('noRows');
        }
    };
    GridPanel.prototype.hideOverlay = function () {
        this.layout.hideOverlay();
    };
    GridPanel.prototype.getWidthForSizeColsToFit = function () {
        var availableWidth = this.eBody.clientWidth;
        var scrollShowing = this.isVerticalScrollShowing();
        if (scrollShowing) {
            availableWidth -= this.scrollWidth;
        }
        return availableWidth;
    };
    // method will call itself if no available width. this covers if the grid
    // isn't visible, but is just about to be visible.
    GridPanel.prototype.sizeColumnsToFit = function (nextTimeout) {
        var _this = this;
        var availableWidth = this.getWidthForSizeColsToFit();
        if (availableWidth > 0) {
            this.columnController.sizeColumnsToFit(availableWidth);
        }
        else {
            if (nextTimeout === undefined) {
                setTimeout(function () {
                    _this.sizeColumnsToFit(100);
                }, 0);
            }
            else if (nextTimeout === 100) {
                setTimeout(function () {
                    _this.sizeColumnsToFit(-1);
                }, 100);
            }
            else {
                console.log('ag-Grid: tried to call sizeColumnsToFit() but the grid is coming back with ' +
                    'zero width, maybe the grid is not visible yet on the screen?');
            }
        }
    };
    GridPanel.prototype.getBodyContainer = function () {
        return this.eBodyContainer;
    };
    GridPanel.prototype.getDropTargetBodyContainers = function () {
        if (this.forPrint) {
            return [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
        }
        else {
            return [this.eBodyViewport, this.eFloatingTopViewport, this.eFloatingBottomViewport];
        }
    };
    GridPanel.prototype.getBodyViewport = function () {
        return this.eBodyViewport;
    };
    GridPanel.prototype.getPinnedLeftColsContainer = function () {
        return this.ePinnedLeftColsContainer;
    };
    GridPanel.prototype.getDropTargetLeftContainers = function () {
        if (this.forPrint) {
            return [];
        }
        else {
            return [this.ePinnedLeftColsViewport, this.ePinnedLeftFloatingBottom, this.ePinnedLeftFloatingTop];
        }
    };
    GridPanel.prototype.getPinnedRightColsContainer = function () {
        return this.ePinnedRightColsContainer;
    };
    GridPanel.prototype.getDropTargetPinnedRightContainers = function () {
        if (this.forPrint) {
            return [];
        }
        else {
            return [this.ePinnedRightColsViewport, this.ePinnedRightFloatingBottom, this.ePinnedRightFloatingTop];
        }
    };
    GridPanel.prototype.getHeaderContainer = function () {
        return this.eHeaderContainer;
    };
    GridPanel.prototype.getHeaderOverlay = function () {
        return this.eHeaderOverlay;
    };
    GridPanel.prototype.getRoot = function () {
        return this.eRoot;
    };
    GridPanel.prototype.getPinnedLeftHeader = function () {
        return this.ePinnedLeftHeader;
    };
    GridPanel.prototype.getPinnedRightHeader = function () {
        return this.ePinnedRightHeader;
    };
    GridPanel.prototype.queryHtmlElement = function (selector) {
        return this.eRoot.querySelector(selector);
    };
    GridPanel.prototype.findElements = function () {
        if (this.forPrint) {
            this.eRoot = utils_1.Utils.loadTemplate(gridForPrintHtml);
            utils_1.Utils.addCssClass(this.eRoot, 'ag-root');
            utils_1.Utils.addCssClass(this.eRoot, 'ag-font-style');
            utils_1.Utils.addCssClass(this.eRoot, 'ag-no-scrolls');
        }
        else {
            this.eRoot = utils_1.Utils.loadTemplate(gridHtml);
            utils_1.Utils.addCssClass(this.eRoot, 'ag-root');
            utils_1.Utils.addCssClass(this.eRoot, 'ag-font-style');
            utils_1.Utils.addCssClass(this.eRoot, 'ag-scrolls');
        }
        if (this.forPrint) {
            this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
            this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
            this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
            this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
            this.eAllCellContainers = [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
        }
        else {
            this.eBody = this.queryHtmlElement('.ag-body');
            this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
            this.eBodyViewport = this.queryHtmlElement('.ag-body-viewport');
            this.eBodyViewportWrapper = this.queryHtmlElement('.ag-body-viewport-wrapper');
            this.ePinnedLeftColsContainer = this.queryHtmlElement('.ag-pinned-left-cols-container');
            this.ePinnedRightColsContainer = this.queryHtmlElement('.ag-pinned-right-cols-container');
            this.ePinnedLeftColsViewport = this.queryHtmlElement('.ag-pinned-left-cols-viewport');
            this.ePinnedRightColsViewport = this.queryHtmlElement('.ag-pinned-right-cols-viewport');
            this.ePinnedLeftHeader = this.queryHtmlElement('.ag-pinned-left-header');
            this.ePinnedRightHeader = this.queryHtmlElement('.ag-pinned-right-header');
            this.eHeader = this.queryHtmlElement('.ag-header');
            this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
            this.eHeaderOverlay = this.queryHtmlElement('.ag-header-overlay');
            this.eHeaderViewport = this.queryHtmlElement('.ag-header-viewport');
            this.eFloatingTop = this.queryHtmlElement('.ag-floating-top');
            this.ePinnedLeftFloatingTop = this.queryHtmlElement('.ag-pinned-left-floating-top');
            this.ePinnedRightFloatingTop = this.queryHtmlElement('.ag-pinned-right-floating-top');
            this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
            this.eFloatingTopViewport = this.queryHtmlElement('.ag-floating-top-viewport');
            this.eFloatingBottom = this.queryHtmlElement('.ag-floating-bottom');
            this.ePinnedLeftFloatingBottom = this.queryHtmlElement('.ag-pinned-left-floating-bottom');
            this.ePinnedRightFloatingBottom = this.queryHtmlElement('.ag-pinned-right-floating-bottom');
            this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
            this.eFloatingBottomViewport = this.queryHtmlElement('.ag-floating-bottom-viewport');
            this.eAllCellContainers = [this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer,
                this.eFloatingTop, this.eFloatingBottom];
            // IE9, Chrome, Safari, Opera
            this.ePinnedLeftColsViewport.addEventListener('mousewheel', this.pinnedLeftMouseWheelListener.bind(this));
            this.eBodyViewport.addEventListener('mousewheel', this.centerMouseWheelListener.bind(this));
            // Firefox
            this.ePinnedLeftColsViewport.addEventListener('DOMMouseScroll', this.pinnedLeftMouseWheelListener.bind(this));
            this.eBodyViewport.addEventListener('DOMMouseScroll', this.centerMouseWheelListener.bind(this));
        }
    };
    GridPanel.prototype.getHeaderViewport = function () {
        return this.eHeaderViewport;
    };
    GridPanel.prototype.centerMouseWheelListener = function (event) {
        // we are only interested in mimicking the mouse wheel if we are pinning on the right,
        // as if we are not pinning on the right, then we have scrollbars in the center body, and
        // as such we just use the default browser wheel behaviour.
        if (this.columnController.isPinningRight()) {
            return this.generalMouseWheelListener(event, this.ePinnedRightColsViewport);
        }
    };
    GridPanel.prototype.pinnedLeftMouseWheelListener = function (event) {
        var targetPanel;
        if (this.columnController.isPinningRight()) {
            targetPanel = this.ePinnedRightColsViewport;
        }
        else {
            targetPanel = this.eBodyViewport;
        }
        return this.generalMouseWheelListener(event, targetPanel);
    };
    GridPanel.prototype.generalMouseWheelListener = function (event, targetPanel) {
        var wheelEvent = utils_1.Utils.normalizeWheel(event);
        // we need to detect in which direction scroll is happening to allow trackpads scroll horizontally
        // horizontal scroll
        if (Math.abs(wheelEvent.pixelX) > Math.abs(wheelEvent.pixelY)) {
            var newLeftPosition = this.eBodyViewport.scrollLeft + wheelEvent.pixelX;
            this.eBodyViewport.scrollLeft = newLeftPosition;
        }
        else {
            var newTopPosition = this.eBodyViewport.scrollTop + wheelEvent.pixelY;
            targetPanel.scrollTop = newTopPosition;
        }
        // allow the option to pass mouse wheel events ot the browser
        // https://github.com/ceolter/ag-grid/issues/800
        // in the future, this should be tied in with 'forPrint' option, or have an option 'no vertical scrolls'
        if (!this.gridOptionsWrapper.isSuppressPreventDefaultOnMouseWheel()) {
            // if we don't prevent default, then the whole browser will scroll also as well as the grid
            event.preventDefault();
        }
        return false;
    };
    GridPanel.prototype.onColumnsChanged = function (event) {
        if (event.isContainerWidthImpacted()) {
            this.setWidthsOfContainers();
        }
        if (event.isPinnedPanelVisibilityImpacted()) {
            this.showPinnedColContainersIfNeeded();
        }
        if (event.getType() === events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED) {
            this.sizeHeaderAndBody();
        }
    };
    GridPanel.prototype.setWidthsOfContainers = function () {
        this.logger.log('setWidthsOfContainers()');
        this.showPinnedColContainersIfNeeded();
        var mainRowWidth = this.columnController.getBodyContainerWidth() + 'px';
        this.eBodyContainer.style.width = mainRowWidth;
        if (this.forPrint) {
            // pinned col doesn't exist when doing forPrint
            return;
        }
        this.eFloatingBottomContainer.style.width = mainRowWidth;
        this.eFloatingTopContainer.style.width = mainRowWidth;
        var pinnedLeftWidth = this.columnController.getPinnedLeftContainerWidth() + 'px';
        this.ePinnedLeftColsContainer.style.width = pinnedLeftWidth;
        this.ePinnedLeftFloatingBottom.style.width = pinnedLeftWidth;
        this.ePinnedLeftFloatingTop.style.width = pinnedLeftWidth;
        this.eBodyViewportWrapper.style.marginLeft = pinnedLeftWidth;
        var pinnedRightWidth = this.columnController.getPinnedRightContainerWidth() + 'px';
        this.ePinnedRightColsContainer.style.width = pinnedRightWidth;
        this.ePinnedRightFloatingBottom.style.width = pinnedRightWidth;
        this.ePinnedRightFloatingTop.style.width = pinnedRightWidth;
        this.eBodyViewportWrapper.style.marginRight = pinnedRightWidth;
    };
    GridPanel.prototype.showPinnedColContainersIfNeeded = function () {
        // no need to do this if not using scrolls
        if (this.forPrint) {
            return;
        }
        //some browsers had layout issues with the blank divs, so if blank,
        //we don't display them
        if (this.columnController.isPinningLeft()) {
            this.ePinnedLeftHeader.style.display = 'inline-block';
            this.ePinnedLeftColsViewport.style.display = 'inline';
        }
        else {
            this.ePinnedLeftHeader.style.display = 'none';
            this.ePinnedLeftColsViewport.style.display = 'none';
        }
        if (this.columnController.isPinningRight()) {
            this.ePinnedRightHeader.style.display = 'inline-block';
            this.ePinnedRightColsViewport.style.display = 'inline';
            this.eBodyViewport.style.overflowY = 'hidden';
        }
        else {
            this.ePinnedRightHeader.style.display = 'none';
            this.ePinnedRightColsViewport.style.display = 'none';
            this.eBodyViewport.style.overflowY = 'auto';
        }
    };
    GridPanel.prototype.sizeHeaderAndBody = function () {
        if (this.forPrint) {
            // if doing 'for print', then the header and footers are laid
            // out naturally by the browser. it whatever size that's needed to fit.
            return;
        }
        var heightOfContainer = this.layout.getCentreHeight();
        if (!heightOfContainer) {
            return;
        }
        var headerHeight = this.gridOptionsWrapper.getHeaderHeight();
        var numberOfRowsInHeader = this.columnController.getHeaderRowCount();
        var totalHeaderHeight = headerHeight * numberOfRowsInHeader;
        this.eHeader.style['height'] = totalHeaderHeight + 'px';
        // padding top covers the header and the floating rows on top
        var floatingTopHeight = this.floatingRowModel.getFloatingTopTotalHeight();
        var paddingTop = totalHeaderHeight + floatingTopHeight;
        // bottom is just the bottom floating rows
        var floatingBottomHeight = this.floatingRowModel.getFloatingBottomTotalHeight();
        var floatingBottomTop = heightOfContainer - floatingBottomHeight;
        var heightOfCentreRows = heightOfContainer - totalHeaderHeight - floatingBottomHeight - floatingTopHeight;
        this.eBody.style.paddingTop = paddingTop + 'px';
        this.eBody.style.paddingBottom = floatingBottomHeight + 'px';
        this.eFloatingTop.style.top = totalHeaderHeight + 'px';
        this.eFloatingTop.style.height = floatingTopHeight + 'px';
        this.eFloatingBottom.style.height = floatingBottomHeight + 'px';
        this.eFloatingBottom.style.top = floatingBottomTop + 'px';
        this.ePinnedLeftColsViewport.style.height = heightOfCentreRows + 'px';
        this.ePinnedRightColsViewport.style.height = heightOfCentreRows + 'px';
    };
    GridPanel.prototype.setHorizontalScrollPosition = function (hScrollPosition) {
        this.eBodyViewport.scrollLeft = hScrollPosition;
    };
    // tries to scroll by pixels, but returns what the result actually was
    GridPanel.prototype.scrollHorizontally = function (pixels) {
        var oldScrollPosition = this.eBodyViewport.scrollLeft;
        this.setHorizontalScrollPosition(oldScrollPosition + pixels);
        var newScrollPosition = this.eBodyViewport.scrollLeft;
        return newScrollPosition - oldScrollPosition;
    };
    GridPanel.prototype.getHorizontalScrollPosition = function () {
        if (this.forPrint) {
            return 0;
        }
        else {
            return this.eBodyViewport.scrollLeft;
        }
    };
    GridPanel.prototype.turnOnAnimationForABit = function () {
        var _this = this;
        if (this.gridOptionsWrapper.isSuppressColumnMoveAnimation()) {
            return;
        }
        this.animationThreadCount++;
        var animationThreadCountCopy = this.animationThreadCount;
        utils_1.Utils.addCssClass(this.eRoot, 'ag-column-moving');
        setTimeout(function () {
            if (_this.animationThreadCount === animationThreadCountCopy) {
                utils_1.Utils.removeCssClass(_this.eRoot, 'ag-column-moving');
            }
        }, 300);
    };
    GridPanel.prototype.addScrollListener = function () {
        var _this = this;
        // if printing, then no scrolling, so no point in listening for scroll events
        if (this.forPrint) {
            return;
        }
        this.eBodyViewport.addEventListener('scroll', function () {
            // we are always interested in horizontal scrolls of the body
            var newLeftPosition = _this.eBodyViewport.scrollLeft;
            if (newLeftPosition !== _this.lastLeftPosition) {
                _this.lastLeftPosition = newLeftPosition;
                _this.horizontallyScrollHeaderCenterAndFloatingCenter();
                _this.masterSlaveService.fireHorizontalScrollEvent(newLeftPosition);
            }
            // if we are pinning to the right, then it's the right pinned container
            // that has the scroll.
            if (!_this.columnController.isPinningRight()) {
                var newTopPosition = _this.eBodyViewport.scrollTop;
                if (newTopPosition !== _this.lastTopPosition) {
                    _this.lastTopPosition = newTopPosition;
                    _this.verticallyScrollLeftPinned(newTopPosition);
                    _this.requestDrawVirtualRows();
                }
            }
        });
        this.ePinnedRightColsViewport.addEventListener('scroll', function () {
            var newTopPosition = _this.ePinnedRightColsViewport.scrollTop;
            if (newTopPosition !== _this.lastTopPosition) {
                _this.lastTopPosition = newTopPosition;
                _this.verticallyScrollLeftPinned(newTopPosition);
                _this.verticallyScrollBody(newTopPosition);
                _this.requestDrawVirtualRows();
            }
        });
        // this means the pinned panel was moved, which can only
        // happen when the user is navigating in the pinned container
        // as the pinned col should never scroll. so we rollback
        // the scroll on the pinned.
        this.ePinnedLeftColsViewport.addEventListener('scroll', function () {
            _this.ePinnedLeftColsViewport.scrollTop = 0;
        });
    };
    GridPanel.prototype.requestDrawVirtualRows = function () {
        var _this = this;
        // if we are in IE or Safari, then we only redraw if there was no scroll event
        // in the 50ms following this scroll event. without this, these browsers have
        // a bad scrolling feel, where the redraws clog the scroll experience
        // (makes the scroll clunky and sticky). this method is like throttling
        // the scroll events.
        var useScrollLag;
        // let the user override scroll lag option
        if (this.gridOptionsWrapper.isSuppressScrollLag()) {
            useScrollLag = false;
        }
        else if (this.gridOptionsWrapper.getIsScrollLag()) {
            useScrollLag = this.gridOptionsWrapper.getIsScrollLag()();
        }
        else {
            useScrollLag = utils_1.Utils.isBrowserIE() || utils_1.Utils.isBrowserSafari();
        }
        if (useScrollLag) {
            this.scrollLagCounter++;
            var scrollLagCounterCopy = this.scrollLagCounter;
            setTimeout(function () {
                if (_this.scrollLagCounter === scrollLagCounterCopy) {
                    _this.rowRenderer.drawVirtualRows();
                }
            }, 50);
        }
        else {
            this.rowRenderer.drawVirtualRows();
        }
    };
    GridPanel.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function () {
        var bodyLeftPosition = this.eBodyViewport.scrollLeft;
        this.eHeaderContainer.style.left = -bodyLeftPosition + 'px';
        this.eFloatingBottomContainer.style.left = -bodyLeftPosition + 'px';
        this.eFloatingTopContainer.style.left = -bodyLeftPosition + 'px';
    };
    GridPanel.prototype.verticallyScrollLeftPinned = function (bodyTopPosition) {
        this.ePinnedLeftColsContainer.style.top = -bodyTopPosition + 'px';
    };
    GridPanel.prototype.verticallyScrollBody = function (position) {
        this.eBodyViewport.scrollTop = position;
    };
    GridPanel.prototype.getVerticalScrollPosition = function () {
        if (this.forPrint) {
            return 0;
        }
        else {
            return this.eBodyViewport.scrollTop;
        }
    };
    GridPanel.prototype.getBodyViewportClientRect = function () {
        if (this.forPrint) {
            return this.eBodyContainer.getBoundingClientRect();
        }
        else {
            return this.eBodyViewport.getBoundingClientRect();
        }
    };
    GridPanel.prototype.getFloatingTopClientRect = function () {
        if (this.forPrint) {
            return this.eFloatingTopContainer.getBoundingClientRect();
        }
        else {
            return this.eFloatingTop.getBoundingClientRect();
        }
    };
    GridPanel.prototype.getFloatingBottomClientRect = function () {
        if (this.forPrint) {
            return this.eFloatingBottomContainer.getBoundingClientRect();
        }
        else {
            return this.eFloatingBottom.getBoundingClientRect();
        }
    };
    GridPanel.prototype.getPinnedLeftColsViewportClientRect = function () {
        return this.ePinnedLeftColsViewport.getBoundingClientRect();
    };
    GridPanel.prototype.getPinnedRightColsViewportClientRect = function () {
        return this.ePinnedRightColsViewport.getBoundingClientRect();
    };
    GridPanel.prototype.addScrollEventListener = function (listener) {
        this.eBodyViewport.addEventListener('scroll', listener);
    };
    GridPanel.prototype.removeScrollEventListener = function (listener) {
        this.eBodyViewport.removeEventListener('scroll', listener);
    };
    __decorate([
        context_1.Autowired('masterSlaveService'), 
        __metadata('design:type', masterSlaveService_1.MasterSlaveService)
    ], GridPanel.prototype, "masterSlaveService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], GridPanel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], GridPanel.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'), 
        __metadata('design:type', rowRenderer_1.RowRenderer)
    ], GridPanel.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('floatingRowModel'), 
        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
    ], GridPanel.prototype, "floatingRowModel", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], GridPanel.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], GridPanel.prototype, "rowModel", void 0);
    __decorate([
        context_1.Optional('rangeController'), 
        __metadata('design:type', Object)
    ], GridPanel.prototype, "rangeController", void 0);
    __decorate([
        context_1.Autowired('dragService'), 
        __metadata('design:type', dragService_1.DragService)
    ], GridPanel.prototype, "dragService", void 0);
    __decorate([
        context_1.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], GridPanel.prototype, "selectionController", void 0);
    __decorate([
        context_1.Optional('clipboardService'), 
        __metadata('design:type', Object)
    ], GridPanel.prototype, "clipboardService", void 0);
    __decorate([
        context_1.Autowired('csvCreator'), 
        __metadata('design:type', csvCreator_1.CsvCreator)
    ], GridPanel.prototype, "csvCreator", void 0);
    __decorate([
        context_1.Autowired('mouseEventService'), 
        __metadata('design:type', mouseEventService_1.MouseEventService)
    ], GridPanel.prototype, "mouseEventService", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'), 
        __metadata('design:type', focusedCellController_1.FocusedCellController)
    ], GridPanel.prototype, "focusedCellController", void 0);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], GridPanel.prototype, "agWire", null);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], GridPanel.prototype, "init", null);
    GridPanel = __decorate([
        context_1.Bean('gridPanel'), 
        __metadata('design:paramtypes', [])
    ], GridPanel);
    return GridPanel;
})();
exports.GridPanel = GridPanel;

},{"../columnController/columnController":77,"../constants":86,"../context/context":87,"../csvCreator":88,"../dragAndDrop/dragService":90,"../eventService":98,"../events":99,"../focusedCellController":104,"../gridOptionsWrapper":109,"../layout/borderLayout":121,"../logger":124,"../masterSlaveService":125,"../rendering/rowRenderer":143,"../rowControllers/floatingRowModel":145,"../selectionController":152,"../utils":156,"./mouseEventService":111}],111:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var context_2 = require("../context/context");
var gridPanel_1 = require("./gridPanel");
var columnController_1 = require("../columnController/columnController");
var column_1 = require("../entities/column");
var constants_1 = require("../constants");
var floatingRowModel_1 = require("../rowControllers/floatingRowModel");
var utils_1 = require('../utils');
var gridCell_1 = require("../entities/gridCell");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var MouseEventService = (function () {
    function MouseEventService() {
    }
    MouseEventService.prototype.getCellForMouseEvent = function (mouseEvent) {
        var floating = this.getFloating(mouseEvent);
        var rowIndex = this.getRowIndex(mouseEvent, floating);
        var column = this.getColumn(mouseEvent);
        if (rowIndex >= 0 && utils_1.Utils.exists(column)) {
            return new gridCell_1.GridCell(rowIndex, floating, column);
        }
        else {
            return null;
        }
    };
    MouseEventService.prototype.getFloating = function (mouseEvent) {
        var floatingTopRect = this.gridPanel.getFloatingTopClientRect();
        var floatingBottomRect = this.gridPanel.getFloatingBottomClientRect();
        var floatingTopRowsExist = !this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_TOP);
        var floatingBottomRowsExist = !this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_BOTTOM);
        if (floatingTopRowsExist && floatingTopRect.bottom >= mouseEvent.clientY) {
            return constants_1.Constants.FLOATING_TOP;
        }
        else if (floatingBottomRowsExist && floatingBottomRect.top <= mouseEvent.clientY) {
            return constants_1.Constants.FLOATING_BOTTOM;
        }
        else {
            return null;
        }
    };
    MouseEventService.prototype.getFloatingRowIndex = function (mouseEvent, floating) {
        var clientRect;
        switch (floating) {
            case constants_1.Constants.FLOATING_TOP:
                clientRect = this.gridPanel.getFloatingTopClientRect();
                break;
            case constants_1.Constants.FLOATING_BOTTOM:
                clientRect = this.gridPanel.getFloatingBottomClientRect();
                break;
        }
        var bodyY = mouseEvent.clientY - clientRect.top;
        var rowIndex = this.floatingRowModel.getRowAtPixel(bodyY, floating);
        return rowIndex;
    };
    MouseEventService.prototype.getRowIndex = function (mouseEvent, floating) {
        switch (floating) {
            case constants_1.Constants.FLOATING_TOP:
            case constants_1.Constants.FLOATING_BOTTOM:
                return this.getFloatingRowIndex(mouseEvent, floating);
            default: return this.getBodyRowIndex(mouseEvent);
        }
    };
    MouseEventService.prototype.getBodyRowIndex = function (mouseEvent) {
        var clientRect = this.gridPanel.getBodyViewportClientRect();
        var scrollY = this.gridPanel.getVerticalScrollPosition();
        var bodyY = mouseEvent.clientY - clientRect.top + scrollY;
        var rowIndex = this.rowModel.getRowIndexAtPixel(bodyY);
        return rowIndex;
    };
    MouseEventService.prototype.getContainer = function (mouseEvent) {
        var centerRect = this.gridPanel.getBodyViewportClientRect();
        var mouseX = mouseEvent.clientX;
        if (mouseX < centerRect.left && this.columnController.isPinningLeft()) {
            return column_1.Column.PINNED_LEFT;
        }
        else if (mouseX > centerRect.right && this.columnController.isPinningRight()) {
            return column_1.Column.PINNED_RIGHT;
        }
        else {
            return null;
        }
    };
    MouseEventService.prototype.getColumn = function (mouseEvent) {
        if (this.columnController.isEmpty()) {
            return null;
        }
        var container = this.getContainer(mouseEvent);
        var columns = this.getColumnsForContainer(container);
        var containerX = this.getXForContainer(container, mouseEvent);
        var hoveringColumn;
        if (containerX < 0) {
            hoveringColumn = columns[0];
        }
        columns.forEach(function (column) {
            var afterLeft = containerX >= column.getLeft();
            var beforeRight = containerX <= column.getRight();
            if (afterLeft && beforeRight) {
                hoveringColumn = column;
            }
        });
        if (!hoveringColumn) {
            hoveringColumn = columns[columns.length - 1];
        }
        return hoveringColumn;
    };
    MouseEventService.prototype.getColumnsForContainer = function (container) {
        switch (container) {
            case column_1.Column.PINNED_LEFT: return this.columnController.getDisplayedLeftColumns();
            case column_1.Column.PINNED_RIGHT: return this.columnController.getDisplayedRightColumns();
            default: return this.columnController.getDisplayedCenterColumns();
        }
    };
    MouseEventService.prototype.getXForContainer = function (container, mouseEvent) {
        var containerX;
        switch (container) {
            case column_1.Column.PINNED_LEFT:
                containerX = this.gridPanel.getPinnedLeftColsViewportClientRect().left;
                break;
            case column_1.Column.PINNED_RIGHT:
                containerX = this.gridPanel.getPinnedRightColsViewportClientRect().left;
                break;
            default:
                var centerRect = this.gridPanel.getBodyViewportClientRect();
                var centerScroll = this.gridPanel.getHorizontalScrollPosition();
                containerX = centerRect.left - centerScroll;
        }
        var result = mouseEvent.clientX - containerX;
        return result;
    };
    __decorate([
        context_2.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], MouseEventService.prototype, "gridPanel", void 0);
    __decorate([
        context_2.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], MouseEventService.prototype, "columnController", void 0);
    __decorate([
        context_2.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], MouseEventService.prototype, "rowModel", void 0);
    __decorate([
        context_2.Autowired('floatingRowModel'), 
        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
    ], MouseEventService.prototype, "floatingRowModel", void 0);
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], MouseEventService.prototype, "gridOptionsWrapper", void 0);
    MouseEventService = __decorate([
        context_1.Bean('mouseEventService'), 
        __metadata('design:paramtypes', [])
    ], MouseEventService);
    return MouseEventService;
})();
exports.MouseEventService = MouseEventService;

},{"../columnController/columnController":77,"../constants":86,"../context/context":87,"../entities/column":92,"../entities/gridCell":94,"../gridOptionsWrapper":109,"../rowControllers/floatingRowModel":145,"../utils":156,"./gridPanel":110}],112:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('../utils');
var CssClassApplier = (function () {
    function CssClassApplier() {
    }
    CssClassApplier.addHeaderClassesFromCollDef = function (abstractColDef, eHeaderCell, gridOptionsWrapper) {
        if (abstractColDef && abstractColDef.headerClass) {
            var classToUse;
            if (typeof abstractColDef.headerClass === 'function') {
                var params = {
                    // bad naming, as colDef here can be a group or a column,
                    // however most people won't appreciate the difference,
                    // so keeping it as colDef to avoid confusion.
                    colDef: abstractColDef,
                    context: gridOptionsWrapper.getContext(),
                    api: gridOptionsWrapper.getApi()
                };
                var headerClassFunc = abstractColDef.headerClass;
                classToUse = headerClassFunc(params);
            }
            else {
                classToUse = abstractColDef.headerClass;
            }
            if (typeof classToUse === 'string') {
                utils_1.Utils.addCssClass(eHeaderCell, classToUse);
            }
            else if (Array.isArray(classToUse)) {
                classToUse.forEach(function (cssClassItem) {
                    utils_1.Utils.addCssClass(eHeaderCell, cssClassItem);
                });
            }
        }
    };
    return CssClassApplier;
})();
exports.CssClassApplier = CssClassApplier;

},{"../utils":156}],113:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require('../utils');
var columnGroup_1 = require("../entities/columnGroup");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var context_1 = require("../context/context");
var column_1 = require("../entities/column");
var context_2 = require("../context/context");
var renderedHeaderGroupCell_1 = require("./renderedHeaderGroupCell");
var renderedHeaderCell_1 = require("./renderedHeaderCell");
var dragAndDropService_1 = require("../dragAndDrop/dragAndDropService");
var moveColumnController_1 = require("./moveColumnController");
var columnController_1 = require("../columnController/columnController");
var gridPanel_1 = require("../gridPanel/gridPanel");
var context_3 = require("../context/context");
var HeaderContainer = (function () {
    function HeaderContainer(eContainer, eViewport, eRoot, pinned) {
        this.headerElements = [];
        this.eContainer = eContainer;
        this.eRoot = eRoot;
        this.pinned = pinned;
        this.eViewport = eViewport;
    }
    HeaderContainer.prototype.init = function () {
        var moveColumnController = new moveColumnController_1.MoveColumnController(this.pinned);
        this.context.wireBean(moveColumnController);
        var secondaryContainers;
        switch (this.pinned) {
            case column_1.Column.PINNED_LEFT:
                secondaryContainers = this.gridPanel.getDropTargetLeftContainers();
                break;
            case column_1.Column.PINNED_RIGHT:
                secondaryContainers = this.gridPanel.getDropTargetPinnedRightContainers();
                break;
            default:
                secondaryContainers = this.gridPanel.getDropTargetBodyContainers();
                break;
        }
        var icon = this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
        this.dropTarget = {
            eContainer: this.eViewport ? this.eViewport : this.eContainer,
            iconName: icon,
            eSecondaryContainers: secondaryContainers,
            onDragging: moveColumnController.onDragging.bind(moveColumnController),
            onDragEnter: moveColumnController.onDragEnter.bind(moveColumnController),
            onDragLeave: moveColumnController.onDragLeave.bind(moveColumnController),
            onDragStop: moveColumnController.onDragStop.bind(moveColumnController)
        };
        this.dragAndDropService.addDropTarget(this.dropTarget);
    };
    HeaderContainer.prototype.removeAllChildren = function () {
        this.headerElements.forEach(function (headerElement) {
            headerElement.destroy();
        });
        this.headerElements.length = 0;
        utils_1.Utils.removeAllChildren(this.eContainer);
    };
    HeaderContainer.prototype.insertHeaderRowsIntoContainer = function () {
        var _this = this;
        var cellTree = this.columnController.getDisplayedColumnGroups(this.pinned);
        // if we are displaying header groups, then we have many rows here.
        // go through each row of the header, one by one.
        var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
        for (var dept = 0;; dept++) {
            var nodesAtDept = [];
            this.addTreeNodesAtDept(cellTree, dept, nodesAtDept);
            // we want to break the for loop when we get to an empty set of cells,
            // that's how we know we have finished rendering the last row.
            if (nodesAtDept.length === 0) {
                break;
            }
            var eRow = document.createElement('div');
            eRow.className = 'ag-header-row';
            eRow.style.top = (dept * rowHeight) + 'px';
            eRow.style.height = rowHeight + 'px';
            nodesAtDept.forEach(function (child) {
                // skip groups that have no displayed children. this can happen when the group is broken,
                // and this section happens to have nothing to display for the open / closed state
                if (child instanceof columnGroup_1.ColumnGroup && child.getDisplayedChildren().length == 0) {
                    return;
                }
                var renderedHeaderElement = _this.createHeaderElement(child);
                _this.headerElements.push(renderedHeaderElement);
                var eGui = renderedHeaderElement.getGui();
                eRow.appendChild(eGui);
            });
            this.eContainer.appendChild(eRow);
        }
    };
    HeaderContainer.prototype.addTreeNodesAtDept = function (cellTree, dept, result) {
        var _this = this;
        cellTree.forEach(function (abstractColumn) {
            if (dept === 0) {
                result.push(abstractColumn);
            }
            else if (abstractColumn instanceof columnGroup_1.ColumnGroup) {
                var columnGroup = abstractColumn;
                _this.addTreeNodesAtDept(columnGroup.getDisplayedChildren(), dept - 1, result);
            }
            else {
            }
        });
    };
    HeaderContainer.prototype.createHeaderElement = function (columnGroupChild) {
        var result;
        if (columnGroupChild instanceof columnGroup_1.ColumnGroup) {
            result = new renderedHeaderGroupCell_1.RenderedHeaderGroupCell(columnGroupChild, this.eRoot, this.$scope, this.dropTarget);
        }
        else {
            result = new renderedHeaderCell_1.RenderedHeaderCell(columnGroupChild, this.$scope, this.eRoot, this.dropTarget);
        }
        this.context.wireBean(result);
        return result;
    };
    HeaderContainer.prototype.onIndividualColumnResized = function (column) {
        this.headerElements.forEach(function (headerElement) {
            headerElement.onIndividualColumnResized(column);
        });
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderContainer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_2.Context)
    ], HeaderContainer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('$scope'), 
        __metadata('design:type', Object)
    ], HeaderContainer.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'), 
        __metadata('design:type', dragAndDropService_1.DragAndDropService)
    ], HeaderContainer.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], HeaderContainer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], HeaderContainer.prototype, "gridPanel", void 0);
    __decorate([
        context_3.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], HeaderContainer.prototype, "init", null);
    return HeaderContainer;
})();
exports.HeaderContainer = HeaderContainer;

},{"../columnController/columnController":77,"../context/context":87,"../dragAndDrop/dragAndDropService":89,"../entities/column":92,"../entities/columnGroup":93,"../gridOptionsWrapper":109,"../gridPanel/gridPanel":110,"../utils":156,"./moveColumnController":117,"./renderedHeaderCell":118,"./renderedHeaderGroupCell":119}],114:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var columnController_1 = require("../columnController/columnController");
var gridPanel_1 = require("../gridPanel/gridPanel");
var column_1 = require("../entities/column");
var context_1 = require("../context/context");
var headerContainer_1 = require("./headerContainer");
var eventService_1 = require("../eventService");
var events_1 = require("../events");
var HeaderRenderer = (function () {
    function HeaderRenderer() {
    }
    HeaderRenderer.prototype.init = function () {
        this.eHeaderViewport = this.gridPanel.getHeaderViewport();
        this.eRoot = this.gridPanel.getRoot();
        this.eHeaderOverlay = this.gridPanel.getHeaderOverlay();
        this.pinnedLeftContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedLeftHeader(), null, this.eRoot, column_1.Column.PINNED_LEFT);
        this.pinnedRightContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedRightHeader(), null, this.eRoot, column_1.Column.PINNED_RIGHT);
        this.centerContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getHeaderContainer(), this.gridPanel.getHeaderViewport(), this.eRoot, null);
        this.context.wireBean(this.pinnedLeftContainer);
        this.context.wireBean(this.pinnedRightContainer);
        this.context.wireBean(this.centerContainer);
        // unlike the table data, the header more often 'refreshes everything' as a way to redraw, rather than
        // do delta changes based on the event. this is because groups have bigger impacts, eg a column move
        // can end up in a group splitting into two, or joining into one. this complexity makes the job much
        // harder to do delta updates. instead we just shotgun - which is fine, as the header is relatively
        // small compared to the body, so the cpu cost is low in comparison. it does mean we don't get any
        // animations.
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_HEADER_HEIGHT_CHANGED, this.refreshHeader.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_PIVOT_VALUE_CHANGED, this.refreshHeader.bind(this));
        // for resized, the individual cells take care of this, so don't need to refresh everything
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.setPinnedColContainerWidth.bind(this));
        if (this.columnController.isReady()) {
            this.refreshHeader();
        }
    };
    // this is called from the API and refreshes everything, should be broken out
    // into refresh everything vs just something changed
    HeaderRenderer.prototype.refreshHeader = function () {
        this.pinnedLeftContainer.removeAllChildren();
        this.pinnedRightContainer.removeAllChildren();
        this.centerContainer.removeAllChildren();
        this.pinnedLeftContainer.insertHeaderRowsIntoContainer();
        this.pinnedRightContainer.insertHeaderRowsIntoContainer();
        this.centerContainer.insertHeaderRowsIntoContainer();
        // if forPrint, overlay is missing
        var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
        // we can probably get rid of this when we no longer need the overlay
        var dept = this.columnController.getColumnDept();
        if (this.eHeaderOverlay) {
            this.eHeaderOverlay.style.height = rowHeight + 'px';
            this.eHeaderOverlay.style.top = ((dept - 1) * rowHeight) + 'px';
        }
        this.setPinnedColContainerWidth();
    };
    HeaderRenderer.prototype.setPinnedColContainerWidth = function () {
        if (this.gridOptionsWrapper.isForPrint()) {
            // pinned col doesn't exist when doing forPrint
            return;
        }
        var pinnedLeftWidth = this.columnController.getPinnedLeftContainerWidth() + 'px';
        this.eHeaderViewport.style.marginLeft = pinnedLeftWidth;
        var pinnedRightWidth = this.columnController.getPinnedRightContainerWidth() + 'px';
        this.eHeaderViewport.style.marginRight = pinnedRightWidth;
    };
    HeaderRenderer.prototype.onIndividualColumnResized = function (column) {
        this.pinnedLeftContainer.onIndividualColumnResized(column);
        this.pinnedRightContainer.onIndividualColumnResized(column);
        this.centerContainer.onIndividualColumnResized(column);
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], HeaderRenderer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], HeaderRenderer.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], HeaderRenderer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], HeaderRenderer.prototype, "eventService", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], HeaderRenderer.prototype, "init", null);
    HeaderRenderer = __decorate([
        context_1.Bean('headerRenderer'), 
        __metadata('design:paramtypes', [])
    ], HeaderRenderer);
    return HeaderRenderer;
})();
exports.HeaderRenderer = HeaderRenderer;

},{"../columnController/columnController":77,"../context/context":87,"../entities/column":92,"../eventService":98,"../events":99,"../gridOptionsWrapper":109,"../gridPanel/gridPanel":110,"./headerContainer":113}],115:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var svgFactory_1 = require("../svgFactory");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var context_1 = require("../context/context");
var svgFactory = svgFactory_1.SvgFactory.getInstance();
var HeaderTemplateLoader = (function () {
    function HeaderTemplateLoader() {
    }
    HeaderTemplateLoader.prototype.createHeaderElement = function (column) {
        var params = {
            column: column,
            colDef: column.getColDef,
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridOptionsWrapper.getApi()
        };
        // option 1 - see if user provided a template in colDef
        var userProvidedTemplate = column.getColDef().headerCellTemplate;
        if (typeof userProvidedTemplate === 'function') {
            var colDefFunc = userProvidedTemplate;
            userProvidedTemplate = colDefFunc(params);
        }
        // option 2 - check the gridOptions for cellTemplate
        if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplate()) {
            userProvidedTemplate = this.gridOptionsWrapper.getHeaderCellTemplate();
        }
        // option 3 - check the gridOptions for templateFunction
        if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplateFunc()) {
            var gridOptionsFunc = this.gridOptionsWrapper.getHeaderCellTemplateFunc();
            userProvidedTemplate = gridOptionsFunc(params);
        }
        // finally, if still no template, use the default
        if (!userProvidedTemplate) {
            userProvidedTemplate = this.createDefaultHeaderElement(column);
        }
        // template can be a string or a dom element, if string we need to convert to a dom element
        var result;
        if (typeof userProvidedTemplate === 'string') {
            result = utils_1.Utils.loadTemplate(userProvidedTemplate);
        }
        else if (utils_1.Utils.isNodeOrElement(userProvidedTemplate)) {
            result = userProvidedTemplate;
        }
        else {
            console.error('ag-Grid: header template must be a string or an HTML element');
        }
        return result;
    };
    HeaderTemplateLoader.prototype.createDefaultHeaderElement = function (column) {
        var eTemplate = utils_1.Utils.loadTemplate(HeaderTemplateLoader.HEADER_CELL_TEMPLATE);
        this.addInIcon(eTemplate, 'sortAscending', '#agSortAsc', column, svgFactory.createArrowUpSvg);
        this.addInIcon(eTemplate, 'sortDescending', '#agSortDesc', column, svgFactory.createArrowDownSvg);
        this.addInIcon(eTemplate, 'sortUnSort', '#agNoSort', column, svgFactory.createArrowUpDownSvg);
        this.addInIcon(eTemplate, 'menu', '#agMenu', column, svgFactory.createMenuSvg);
        this.addInIcon(eTemplate, 'filter', '#agFilter', column, svgFactory.createFilterSvg);
        return eTemplate;
    };
    HeaderTemplateLoader.prototype.addInIcon = function (eTemplate, iconName, cssSelector, column, defaultIconFactory) {
        var eIcon = utils_1.Utils.createIconNoSpan(iconName, this.gridOptionsWrapper, column, defaultIconFactory);
        eTemplate.querySelector(cssSelector).appendChild(eIcon);
    };
    HeaderTemplateLoader.HEADER_CELL_TEMPLATE = '<div class="ag-header-cell">' +
        '  <div id="agResizeBar" class="ag-header-cell-resize"></div>' +
        '  <span id="agMenu" class="ag-header-icon ag-header-cell-menu-button"></span>' +
        '  <div id="agHeaderCellLabel" class="ag-header-cell-label">' +
        '    <span id="agSortAsc" class="ag-header-icon ag-sort-ascending-icon"></span>' +
        '    <span id="agSortDesc" class="ag-header-icon ag-sort-descending-icon"></span>' +
        '    <span id="agNoSort" class="ag-header-icon ag-sort-none-icon"></span>' +
        '    <span id="agFilter" class="ag-header-icon ag-filter-icon"></span>' +
        '    <span id="agText" class="ag-header-cell-text"></span>' +
        '  </div>' +
        '</div>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], HeaderTemplateLoader.prototype, "gridOptionsWrapper", void 0);
    HeaderTemplateLoader = __decorate([
        context_1.Bean('headerTemplateLoader'), 
        __metadata('design:paramtypes', [])
    ], HeaderTemplateLoader);
    return HeaderTemplateLoader;
})();
exports.HeaderTemplateLoader = HeaderTemplateLoader;

},{"../context/context":87,"../gridOptionsWrapper":109,"../svgFactory":154,"../utils":156}],116:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var HorizontalDragService = (function () {
    function HorizontalDragService() {
    }
    HorizontalDragService.prototype.addDragHandling = function (params) {
        params.eDraggableElement.addEventListener('mousedown', function (startEvent) {
            new DragInstance(params, startEvent);
        });
    };
    HorizontalDragService = __decorate([
        context_1.Bean('horizontalDragService'), 
        __metadata('design:paramtypes', [])
    ], HorizontalDragService);
    return HorizontalDragService;
})();
exports.HorizontalDragService = HorizontalDragService;
var DragInstance = (function () {
    function DragInstance(params, startEvent) {
        this.mouseMove = this.onMouseMove.bind(this);
        this.mouseUp = this.onMouseUp.bind(this);
        this.mouseLeave = this.onMouseLeave.bind(this);
        this.lastDelta = 0;
        this.params = params;
        this.eDragParent = document.querySelector('body');
        this.dragStartX = startEvent.clientX;
        this.startEvent = startEvent;
        this.eDragParent.addEventListener('mousemove', this.mouseMove);
        this.eDragParent.addEventListener('mouseup', this.mouseUp);
        this.eDragParent.addEventListener('mouseleave', this.mouseLeave);
        this.draggingStarted = false;
        var startAfterPixelsExist = typeof params.startAfterPixels === 'number' && params.startAfterPixels > 0;
        if (!startAfterPixelsExist) {
            this.startDragging();
        }
    }
    DragInstance.prototype.startDragging = function () {
        this.draggingStarted = true;
        this.oldBodyCursor = this.params.eBody.style.cursor;
        this.oldParentCursor = this.eDragParent.style.cursor;
        this.oldMsUserSelect = this.eDragParent.style.msUserSelect;
        this.oldWebkitUserSelect = this.eDragParent.style.webkitUserSelect;
        // change the body cursor, so when drag moves out of the drag bar, the cursor is still 'resize' (or 'move'
        this.params.eBody.style.cursor = this.params.cursor;
        // same for outside the grid, we want to keep the resize (or move) cursor
        this.eDragParent.style.cursor = this.params.cursor;
        // we don't want text selection outside the grid (otherwise it looks weird as text highlights when we move)
        this.eDragParent.style.msUserSelect = 'none';
        this.eDragParent.style.webkitUserSelect = 'none';
        this.params.onDragStart(this.startEvent);
    };
    DragInstance.prototype.onMouseMove = function (moveEvent) {
        var newX = moveEvent.clientX;
        this.lastDelta = newX - this.dragStartX;
        if (!this.draggingStarted) {
            var dragExceededStartAfterPixels = Math.abs(this.lastDelta) >= this.params.startAfterPixels;
            if (dragExceededStartAfterPixels) {
                this.startDragging();
            }
        }
        if (this.draggingStarted) {
            this.params.onDragging(this.lastDelta, false);
        }
    };
    DragInstance.prototype.onMouseUp = function () {
        this.stopDragging();
    };
    DragInstance.prototype.onMouseLeave = function () {
        this.stopDragging();
    };
    DragInstance.prototype.stopDragging = function () {
        // reset cursor back to original cursor, if they were changed in the first place
        if (this.draggingStarted) {
            this.params.eBody.style.cursor = this.oldBodyCursor;
            this.eDragParent.style.cursor = this.oldParentCursor;
            this.eDragParent.style.msUserSelect = this.oldMsUserSelect;
            this.eDragParent.style.webkitUserSelect = this.oldWebkitUserSelect;
            this.params.onDragging(this.lastDelta, true);
        }
        // always remove the listeners, as these are always added
        this.eDragParent.removeEventListener('mousemove', this.mouseMove);
        this.eDragParent.removeEventListener('mouseup', this.mouseUp);
        this.eDragParent.removeEventListener('mouseleave', this.mouseLeave);
    };
    return DragInstance;
})();

},{"../context/context":87}],117:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var logger_1 = require("../logger");
var columnController_1 = require("../columnController/columnController");
var column_1 = require("../entities/column");
var utils_1 = require("../utils");
var dragAndDropService_1 = require("../dragAndDrop/dragAndDropService");
var gridPanel_1 = require("../gridPanel/gridPanel");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var MoveColumnController = (function () {
    function MoveColumnController(pinned) {
        this.needToMoveLeft = false;
        this.needToMoveRight = false;
        this.pinned = pinned;
        this.centerContainer = !utils_1.Utils.exists(pinned);
    }
    MoveColumnController.prototype.init = function () {
        this.logger = this.loggerFactory.create('MoveColumnController');
    };
    MoveColumnController.prototype.onDragEnter = function (draggingEvent) {
        // we do dummy drag, so make sure column appears in the right location when first placed
        var columns = draggingEvent.dragSource.dragItem;
        this.columnController.setColumnsVisible(columns, true);
        this.columnController.setColumnsPinned(columns, this.pinned);
        this.onDragging(draggingEvent, true);
    };
    MoveColumnController.prototype.onDragLeave = function (draggingEvent) {
        if (!this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns()) {
            var columns = draggingEvent.dragSource.dragItem;
            this.columnController.setColumnsVisible(columns, false);
        }
        this.ensureIntervalCleared();
    };
    MoveColumnController.prototype.onDragStop = function () {
        this.ensureIntervalCleared();
    };
    MoveColumnController.prototype.adjustXForScroll = function (draggingEvent) {
        if (this.centerContainer) {
            return draggingEvent.x + this.gridPanel.getHorizontalScrollPosition();
        }
        else {
            return draggingEvent.x;
        }
    };
    MoveColumnController.prototype.workOutNewIndex = function (displayedColumns, allColumns, dragColumn, direction, xAdjustedForScroll) {
        if (direction === dragAndDropService_1.DragAndDropService.DIRECTION_LEFT) {
            return this.getNewIndexForColMovingLeft(displayedColumns, allColumns, dragColumn, xAdjustedForScroll);
        }
        else {
            return this.getNewIndexForColMovingRight(displayedColumns, allColumns, dragColumn, xAdjustedForScroll);
        }
    };
    MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {
        if (this.centerContainer) {
            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)
            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen
            var firstVisiblePixel = this.gridPanel.getHorizontalScrollPosition();
            var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();
            this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);
            this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);
            if (this.needToMoveLeft || this.needToMoveRight) {
                this.ensureIntervalStarted();
            }
            else {
                this.ensureIntervalCleared();
            }
        }
    };
    MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {
        if (fromEnter === void 0) { fromEnter = false; }
        this.lastDraggingEvent = draggingEvent;
        // if moving up or down (ie not left or right) then do nothing
        if (!draggingEvent.direction) {
            return;
        }
        var xAdjustedForScroll = this.adjustXForScroll(draggingEvent);
        // if the user is dragging into the panel, ie coming from the side panel into the main grid,
        // we don't want to scroll the grid this time, it would appear like the table is jumping
        // each time a column is dragged in.
        if (!fromEnter) {
            this.checkCenterForScrolling(xAdjustedForScroll);
        }
        var columnsToMove = draggingEvent.dragSource.dragItem;
        this.attemptMoveColumns(columnsToMove, draggingEvent.direction, xAdjustedForScroll, fromEnter);
    };
    MoveColumnController.prototype.attemptMoveColumns = function (allMovingColumns, dragDirection, xAdjustedForScroll, fromEnter) {
        var displayedColumns = this.columnController.getDisplayedColumns(this.pinned);
        var gridColumns = this.columnController.getAllGridColumns();
        var draggingLeft = dragDirection === dragAndDropService_1.DragAndDropService.DIRECTION_LEFT;
        var draggingRight = dragDirection === dragAndDropService_1.DragAndDropService.DIRECTION_RIGHT;
        var dragColumn;
        var displayedMovingColumns = utils_1.Utils.filter(allMovingColumns, function (column) { return displayedColumns.indexOf(column) >= 0; });
        // if dragging left, we want to use the left most column, ie move the left most column to
        // under the mouse pointer
        if (draggingLeft) {
            dragColumn = displayedMovingColumns[0];
        }
        else {
            dragColumn = displayedMovingColumns[displayedMovingColumns.length - 1];
        }
        var newIndex = this.workOutNewIndex(displayedColumns, gridColumns, dragColumn, dragDirection, xAdjustedForScroll);
        var oldIndex = gridColumns.indexOf(dragColumn);
        // the two check below stop an error when the user grabs a group my a middle column, then
        // it is possible the mouse pointer is to the right of a column while been dragged left.
        // so we need to make sure that the mouse pointer is actually left of the left most column
        // if moving left, and right of the right most column if moving right
        // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from
        // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should
        // place the column to the RHS even if the mouse is moving left and the column is already on
        // the LHS. otherwise we stick to the rule described above.
        // only allow left drag if this column is moving left
        if (!fromEnter && draggingLeft && newIndex >= oldIndex) {
            return;
        }
        // only allow right drag if this column is moving right
        if (!fromEnter && draggingRight && newIndex <= oldIndex) {
            return;
        }
        // if moving right, the new index is the index of the right most column, so adjust to first column
        if (draggingRight) {
            newIndex = newIndex - allMovingColumns.length + 1;
        }
        this.columnController.moveColumns(allMovingColumns, newIndex);
    };
    MoveColumnController.prototype.getNewIndexForColMovingLeft = function (displayedColumns, allColumns, dragColumn, x) {
        var usedX = 0;
        var leftColumn = null;
        for (var i = 0; i < displayedColumns.length; i++) {
            var currentColumn = displayedColumns[i];
            if (currentColumn === dragColumn) {
                continue;
            }
            usedX += currentColumn.getActualWidth();
            if (usedX > x) {
                break;
            }
            leftColumn = currentColumn;
        }
        var newIndex;
        if (leftColumn) {
            newIndex = allColumns.indexOf(leftColumn) + 1;
            var oldIndex = allColumns.indexOf(dragColumn);
            if (oldIndex < newIndex) {
                newIndex--;
            }
        }
        else {
            newIndex = 0;
        }
        return newIndex;
    };
    MoveColumnController.prototype.getNewIndexForColMovingRight = function (displayedColumns, allColumns, dragColumnOrGroup, x) {
        var dragColumn = dragColumnOrGroup;
        var usedX = dragColumn.getActualWidth();
        var leftColumn = null;
        for (var i = 0; i < displayedColumns.length; i++) {
            if (usedX > x) {
                break;
            }
            var currentColumn = displayedColumns[i];
            if (currentColumn === dragColumn) {
                continue;
            }
            usedX += currentColumn.getActualWidth();
            leftColumn = currentColumn;
        }
        var newIndex;
        if (leftColumn) {
            newIndex = allColumns.indexOf(leftColumn) + 1;
            var oldIndex = allColumns.indexOf(dragColumn);
            if (oldIndex < newIndex) {
                newIndex--;
            }
        }
        else {
            newIndex = 0;
        }
        return newIndex;
    };
    MoveColumnController.prototype.ensureIntervalStarted = function () {
        if (!this.movingIntervalId) {
            this.intervalCount = 0;
            this.failedMoveAttempts = 0;
            this.movingIntervalId = setInterval(this.moveInterval.bind(this), 100);
            if (this.needToMoveLeft) {
                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);
            }
            else {
                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);
            }
        }
    };
    MoveColumnController.prototype.ensureIntervalCleared = function () {
        if (this.moveInterval) {
            clearInterval(this.movingIntervalId);
            this.movingIntervalId = null;
            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);
        }
    };
    MoveColumnController.prototype.moveInterval = function () {
        var pixelsToMove;
        this.intervalCount++;
        pixelsToMove = 10 + (this.intervalCount * 5);
        if (pixelsToMove > 100) {
            pixelsToMove = 100;
        }
        var pixelsMoved;
        if (this.needToMoveLeft) {
            pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);
        }
        else if (this.needToMoveRight) {
            pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);
        }
        if (pixelsMoved !== 0) {
            this.onDragging(this.lastDraggingEvent);
            this.failedMoveAttempts = 0;
        }
        else {
            this.failedMoveAttempts++;
            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);
            if (this.failedMoveAttempts > 7) {
                var columns = this.lastDraggingEvent.dragSource.dragItem;
                var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;
                this.columnController.setColumnsPinned(columns, pinType);
                this.dragAndDropService.nudge();
            }
        }
    };
    __decorate([
        context_1.Autowired('loggerFactory'), 
        __metadata('design:type', logger_1.LoggerFactory)
    ], MoveColumnController.prototype, "loggerFactory", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], MoveColumnController.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], MoveColumnController.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'), 
        __metadata('design:type', dragAndDropService_1.DragAndDropService)
    ], MoveColumnController.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], MoveColumnController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], MoveColumnController.prototype, "init", null);
    return MoveColumnController;
})();
exports.MoveColumnController = MoveColumnController;

},{"../columnController/columnController":77,"../context/context":87,"../dragAndDrop/dragAndDropService":89,"../entities/column":92,"../gridOptionsWrapper":109,"../gridPanel/gridPanel":110,"../logger":124,"../utils":156}],118:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var column_1 = require("../entities/column");
var filterManager_1 = require("../filter/filterManager");
var columnController_1 = require("../columnController/columnController");
var headerTemplateLoader_1 = require("./headerTemplateLoader");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var horizontalDragService_1 = require("./horizontalDragService");
var gridCore_1 = require("../gridCore");
var context_1 = require("../context/context");
var cssClassApplier_1 = require("./cssClassApplier");
var dragAndDropService_1 = require("../dragAndDrop/dragAndDropService");
var sortController_1 = require("../sortController");
var RenderedHeaderCell = (function () {
    function RenderedHeaderCell(column, parentScope, eRoot, dragSourceDropTarget) {
        // for better structured code, anything we need to do when this column gets destroyed,
        // we put a function in here. otherwise we would have a big destroy function with lots
        // of 'if / else' mapping to things that got created.
        this.destroyFunctions = [];
        this.column = column;
        this.parentScope = parentScope;
        this.eRoot = eRoot;
        this.dragSourceDropTarget = dragSourceDropTarget;
    }
    RenderedHeaderCell.prototype.init = function () {
        this.eHeaderCell = this.headerTemplateLoader.createHeaderElement(this.column);
        utils_1.Utils.addCssClass(this.eHeaderCell, 'ag-header-cell');
        this.createScope(this.parentScope);
        this.addAttributes();
        cssClassApplier_1.CssClassApplier.addHeaderClassesFromCollDef(this.column.getColDef(), this.eHeaderCell, this.gridOptionsWrapper);
        // label div
        var eHeaderCellLabel = this.eHeaderCell.querySelector('#agHeaderCellLabel');
        this.displayName = this.columnController.getDisplayNameForCol(this.column);
        this.setupMovingCss();
        this.setupTooltip();
        this.setupResize();
        this.setupMove(eHeaderCellLabel);
        this.setupMenu();
        this.setupSort(eHeaderCellLabel);
        this.setupFilterIcon();
        this.setupText();
        this.setupWidth();
    };
    RenderedHeaderCell.prototype.setupTooltip = function () {
        var colDef = this.column.getColDef();
        // add tooltip if exists
        if (colDef.headerTooltip) {
            this.eHeaderCell.title = colDef.headerTooltip;
        }
    };
    RenderedHeaderCell.prototype.setupText = function () {
        var colDef = this.column.getColDef();
        // render the cell, use a renderer if one is provided
        var headerCellRenderer;
        if (colDef.headerCellRenderer) {
            headerCellRenderer = colDef.headerCellRenderer;
        }
        else if (this.gridOptionsWrapper.getHeaderCellRenderer()) {
            headerCellRenderer = this.gridOptionsWrapper.getHeaderCellRenderer();
        }
        var eText = this.eHeaderCell.querySelector('#agText');
        if (eText) {
            if (headerCellRenderer) {
                this.useRenderer(this.displayName, headerCellRenderer, eText);
            }
            else {
                // no renderer, default text render
                eText.className = 'ag-header-cell-text';
                eText.innerHTML = this.displayName;
            }
        }
    };
    RenderedHeaderCell.prototype.setupFilterIcon = function () {
        var _this = this;
        var eFilterIcon = this.eHeaderCell.querySelector('#agFilter');
        if (!eFilterIcon) {
            return;
        }
        var filterChangedListener = function () {
            var filterPresent = _this.column.isFilterActive();
            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-filtered', filterPresent);
            utils_1.Utils.addOrRemoveCssClass(eFilterIcon, 'ag-hidden', !filterPresent);
        };
        this.column.addEventListener(column_1.Column.EVENT_FILTER_ACTIVE_CHANGED, filterChangedListener);
        this.destroyFunctions.push(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_FILTER_ACTIVE_CHANGED, filterChangedListener);
        });
        filterChangedListener();
    };
    RenderedHeaderCell.prototype.setupWidth = function () {
        var _this = this;
        var widthChangedListener = function () {
            _this.eHeaderCell.style.width = _this.column.getActualWidth() + 'px';
        };
        this.column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
        this.destroyFunctions.push(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
        });
        widthChangedListener();
    };
    RenderedHeaderCell.prototype.getGui = function () {
        return this.eHeaderCell;
    };
    RenderedHeaderCell.prototype.destroy = function () {
        this.destroyFunctions.forEach(function (func) {
            func();
        });
    };
    RenderedHeaderCell.prototype.createScope = function (parentScope) {
        var _this = this;
        if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
            this.childScope = parentScope.$new();
            this.childScope.colDef = this.column.getColDef();
            this.childScope.colDefWrapper = this.column;
            this.childScope.context = this.gridOptionsWrapper.getContext();
            this.destroyFunctions.push(function () {
                _this.childScope.$destroy();
            });
        }
    };
    RenderedHeaderCell.prototype.addAttributes = function () {
        this.eHeaderCell.setAttribute("colId", this.column.getColId());
    };
    RenderedHeaderCell.prototype.setupMenu = function () {
        var _this = this;
        var eMenu = this.eHeaderCell.querySelector('#agMenu');
        // if no menu provided in template, do nothing
        if (!eMenu) {
            return;
        }
        var weWantMenu = this.menuFactory.isMenuEnabled(this.column) && !this.column.getColDef().suppressMenu;
        if (!weWantMenu) {
            utils_1.Utils.removeFromParent(eMenu);
            return;
        }
        eMenu.addEventListener('click', function () { return _this.showMenu(eMenu); });
        if (!this.gridOptionsWrapper.isSuppressMenuHide()) {
            eMenu.style.opacity = '0';
            this.eHeaderCell.addEventListener('mouseover', function () {
                eMenu.style.opacity = '1';
            });
            this.eHeaderCell.addEventListener('mouseout', function () {
                eMenu.style.opacity = '0';
            });
        }
        var style = eMenu.style;
        style['transition'] = 'opacity 0.2s, border 0.2s';
        style['-webkit-transition'] = 'opacity 0.2s, border 0.2s';
    };
    RenderedHeaderCell.prototype.showMenu = function (eventSource) {
        this.menuFactory.showMenuAfterButtonClick(this.column, eventSource);
    };
    RenderedHeaderCell.prototype.setupMovingCss = function () {
        var _this = this;
        // this function adds or removes the moving css, based on if the col is moving
        var addMovingCssFunc = function () {
            if (_this.column.isMoving()) {
                utils_1.Utils.addCssClass(_this.eHeaderCell, 'ag-header-cell-moving');
            }
            else {
                utils_1.Utils.removeCssClass(_this.eHeaderCell, 'ag-header-cell-moving');
            }
        };
        // call it now once, so the col is set up correctly
        addMovingCssFunc();
        // then call it every time we are informed of a moving state change in the col
        this.column.addEventListener(column_1.Column.EVENT_MOVING_CHANGED, addMovingCssFunc);
        // finally we remove the listener when this cell is no longer rendered
        this.destroyFunctions.push(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_MOVING_CHANGED, addMovingCssFunc);
        });
    };
    RenderedHeaderCell.prototype.setupMove = function (eHeaderCellLabel) {
        if (this.gridOptionsWrapper.isSuppressMovableColumns() || this.column.getColDef().suppressMovable) {
            return;
        }
        if (this.gridOptionsWrapper.isForPrint()) {
            // don't allow moving of headers when forPrint, as the header overlay doesn't exist
            return;
        }
        if (eHeaderCellLabel) {
            var dragSource = {
                eElement: eHeaderCellLabel,
                dragItem: [this.column],
                dragItemName: this.displayName,
                dragSourceDropTarget: this.dragSourceDropTarget
            };
            this.dragAndDropService.addDragSource(dragSource);
        }
    };
    RenderedHeaderCell.prototype.setupResize = function () {
        var _this = this;
        var colDef = this.column.getColDef();
        var eResize = this.eHeaderCell.querySelector('#agResizeBar');
        // if no eResize in template, do nothing
        if (!eResize) {
            return;
        }
        var weWantResize = this.gridOptionsWrapper.isEnableColResize() && !colDef.suppressResize;
        if (!weWantResize) {
            utils_1.Utils.removeFromParent(eResize);
            return;
        }
        this.dragService.addDragHandling({
            eDraggableElement: eResize,
            eBody: this.eRoot,
            cursor: 'col-resize',
            startAfterPixels: 0,
            onDragStart: this.onDragStart.bind(this),
            onDragging: this.onDragging.bind(this)
        });
        var weWantAutoSize = !this.gridOptionsWrapper.isSuppressAutoSize() && !colDef.suppressAutoSize;
        if (weWantAutoSize) {
            eResize.addEventListener('dblclick', function () {
                _this.columnController.autoSizeColumn(_this.column);
            });
        }
    };
    RenderedHeaderCell.prototype.useRenderer = function (headerNameValue, headerCellRenderer, eText) {
        // renderer provided, use it
        var cellRendererParams = {
            colDef: this.column.getColDef(),
            $scope: this.childScope,
            context: this.gridOptionsWrapper.getContext(),
            value: headerNameValue,
            api: this.gridOptionsWrapper.getApi(),
            eHeaderCell: this.eHeaderCell
        };
        var cellRendererResult = headerCellRenderer(cellRendererParams);
        var childToAppend;
        if (utils_1.Utils.isNodeOrElement(cellRendererResult)) {
            // a dom node or element was returned, so add child
            childToAppend = cellRendererResult;
        }
        else {
            // otherwise assume it was html, so just insert
            var eTextSpan = document.createElement("span");
            eTextSpan.innerHTML = cellRendererResult;
            childToAppend = eTextSpan;
        }
        // angular compile header if option is turned on
        if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
            var childToAppendCompiled = this.$compile(childToAppend)(this.childScope)[0];
            eText.appendChild(childToAppendCompiled);
        }
        else {
            eText.appendChild(childToAppend);
        }
    };
    RenderedHeaderCell.prototype.setupSort = function (eHeaderCellLabel) {
        var _this = this;
        var enableSorting = this.gridOptionsWrapper.isEnableSorting() && !this.column.getColDef().suppressSorting;
        if (!enableSorting) {
            utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agSortAsc'));
            utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agSortDesc'));
            utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agNoSort'));
            return;
        }
        // add sortable class for styling
        utils_1.Utils.addCssClass(this.eHeaderCell, 'ag-header-cell-sortable');
        // add the event on the header, so when clicked, we do sorting
        if (eHeaderCellLabel) {
            eHeaderCellLabel.addEventListener("click", function (event) {
                _this.sortController.progressSort(_this.column, event.shiftKey);
            });
        }
        // add listener for sort changing, and update the icons accordingly
        var eSortAsc = this.eHeaderCell.querySelector('#agSortAsc');
        var eSortDesc = this.eHeaderCell.querySelector('#agSortDesc');
        var eSortNone = this.eHeaderCell.querySelector('#agNoSort');
        var sortChangedListener = function () {
            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-asc', _this.column.isSortAscending());
            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-desc', _this.column.isSortDescending());
            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-none', _this.column.isSortNone());
            if (eSortAsc) {
                utils_1.Utils.addOrRemoveCssClass(eSortAsc, 'ag-hidden', !_this.column.isSortAscending());
            }
            if (eSortDesc) {
                utils_1.Utils.addOrRemoveCssClass(eSortDesc, 'ag-hidden', !_this.column.isSortDescending());
            }
            if (eSortNone) {
                var alwaysHideNoSort = !_this.column.getColDef().unSortIcon && !_this.gridOptionsWrapper.isUnSortIcon();
                utils_1.Utils.addOrRemoveCssClass(eSortNone, 'ag-hidden', alwaysHideNoSort || !_this.column.isSortNone());
            }
        };
        this.column.addEventListener(column_1.Column.EVENT_SORT_CHANGED, sortChangedListener);
        this.destroyFunctions.push(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_SORT_CHANGED, sortChangedListener);
        });
        sortChangedListener();
    };
    RenderedHeaderCell.prototype.onDragStart = function () {
        this.startWidth = this.column.getActualWidth();
    };
    RenderedHeaderCell.prototype.onDragging = function (dragChange, finished) {
        var newWidth = this.startWidth + dragChange;
        this.columnController.setColumnWidth(this.column, newWidth, finished);
    };
    RenderedHeaderCell.prototype.onIndividualColumnResized = function (column) {
        if (this.column !== column) {
            return;
        }
        var newWidthPx = column.getActualWidth() + "px";
        this.eHeaderCell.style.width = newWidthPx;
    };
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], RenderedHeaderCell.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], RenderedHeaderCell.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], RenderedHeaderCell.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('$compile'), 
        __metadata('design:type', Object)
    ], RenderedHeaderCell.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('gridCore'), 
        __metadata('design:type', gridCore_1.GridCore)
    ], RenderedHeaderCell.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('headerTemplateLoader'), 
        __metadata('design:type', headerTemplateLoader_1.HeaderTemplateLoader)
    ], RenderedHeaderCell.prototype, "headerTemplateLoader", void 0);
    __decorate([
        context_1.Autowired('horizontalDragService'), 
        __metadata('design:type', horizontalDragService_1.HorizontalDragService)
    ], RenderedHeaderCell.prototype, "dragService", void 0);
    __decorate([
        context_1.Autowired('menuFactory'), 
        __metadata('design:type', Object)
    ], RenderedHeaderCell.prototype, "menuFactory", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], RenderedHeaderCell.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'), 
        __metadata('design:type', dragAndDropService_1.DragAndDropService)
    ], RenderedHeaderCell.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.Autowired('sortController'), 
        __metadata('design:type', sortController_1.SortController)
    ], RenderedHeaderCell.prototype, "sortController", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], RenderedHeaderCell.prototype, "init", null);
    return RenderedHeaderCell;
})();
exports.RenderedHeaderCell = RenderedHeaderCell;

},{"../columnController/columnController":77,"../context/context":87,"../dragAndDrop/dragAndDropService":89,"../entities/column":92,"../filter/filterManager":101,"../gridCore":108,"../gridOptionsWrapper":109,"../sortController":153,"../utils":156,"./cssClassApplier":112,"./headerTemplateLoader":115,"./horizontalDragService":116}],119:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var svgFactory_1 = require("../svgFactory");
var columnController_1 = require("../columnController/columnController");
var filterManager_1 = require("../filter/filterManager");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var column_1 = require("../entities/column");
var horizontalDragService_1 = require("./horizontalDragService");
var context_1 = require("../context/context");
var cssClassApplier_1 = require("./cssClassApplier");
var dragAndDropService_1 = require("../dragAndDrop/dragAndDropService");
var svgFactory = svgFactory_1.SvgFactory.getInstance();
var RenderedHeaderGroupCell = (function () {
    function RenderedHeaderGroupCell(columnGroup, eRoot, parentScope, dragSourceDropTarget) {
        this.destroyFunctions = [];
        this.columnGroup = columnGroup;
        this.parentScope = parentScope;
        this.eRoot = eRoot;
        this.parentScope = parentScope;
        this.dragSourceDropTarget = dragSourceDropTarget;
    }
    RenderedHeaderGroupCell.prototype.getGui = function () {
        return this.eHeaderGroupCell;
    };
    RenderedHeaderGroupCell.prototype.onIndividualColumnResized = function (column) {
        if (this.columnGroup.isChildInThisGroupDeepSearch(column)) {
            this.setWidth();
        }
    };
    RenderedHeaderGroupCell.prototype.init = function () {
        this.eHeaderGroupCell = document.createElement('div');
        cssClassApplier_1.CssClassApplier.addHeaderClassesFromCollDef(this.columnGroup.getColGroupDef(), this.eHeaderGroupCell, this.gridOptionsWrapper);
        this.displayName = this.columnGroup.getHeaderName();
        this.setupResize();
        this.addClasses();
        this.setupLabel();
        this.setupMove();
        this.setWidth();
    };
    RenderedHeaderGroupCell.prototype.setupLabel = function () {
        // no renderer, default text render
        if (this.displayName && this.displayName !== '') {
            var eGroupCellLabel = document.createElement("div");
            eGroupCellLabel.className = 'ag-header-group-cell-label';
            this.eHeaderGroupCell.appendChild(eGroupCellLabel);
            if (utils_1.Utils.isBrowserSafari()) {
                eGroupCellLabel.style.display = 'table-cell';
            }
            var eInnerText = document.createElement("span");
            eInnerText.className = 'ag-header-group-text';
            eInnerText.innerHTML = this.displayName;
            eGroupCellLabel.appendChild(eInnerText);
            if (this.columnGroup.isExpandable()) {
                this.addGroupExpandIcon(eGroupCellLabel);
            }
        }
    };
    RenderedHeaderGroupCell.prototype.addClasses = function () {
        utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell');
        // having different classes below allows the style to not have a bottom border
        // on the group header, if no group is specified
        if (this.columnGroup.getColGroupDef()) {
            utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell-with-group');
        }
        else {
            utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell-no-group');
        }
    };
    RenderedHeaderGroupCell.prototype.setupResize = function () {
        var _this = this;
        if (!this.gridOptionsWrapper.isEnableColResize()) {
            return;
        }
        this.eHeaderCellResize = document.createElement("div");
        this.eHeaderCellResize.className = "ag-header-cell-resize";
        this.eHeaderGroupCell.appendChild(this.eHeaderCellResize);
        this.dragService.addDragHandling({
            eDraggableElement: this.eHeaderCellResize,
            eBody: this.eRoot,
            cursor: 'col-resize',
            startAfterPixels: 0,
            onDragStart: this.onDragStart.bind(this),
            onDragging: this.onDragging.bind(this)
        });
        if (!this.gridOptionsWrapper.isSuppressAutoSize()) {
            this.eHeaderCellResize.addEventListener('dblclick', function (event) {
                // get list of all the column keys we are responsible for
                var keys = [];
                _this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
                    // not all cols in the group may be participating with auto-resize
                    if (!column.getColDef().suppressAutoSize) {
                        keys.push(column.getColId());
                    }
                });
                if (keys.length > 0) {
                    _this.columnController.autoSizeColumns(keys);
                }
            });
        }
    };
    RenderedHeaderGroupCell.prototype.setupMove = function () {
        var eLabel = this.eHeaderGroupCell.querySelector('.ag-header-group-cell-label');
        if (!eLabel) {
            return;
        }
        if (this.gridOptionsWrapper.isSuppressMovableColumns()) {
            return;
        }
        // if any child is fixed, then don't allow moving
        var atLeastOneChildNotMovable = false;
        this.columnGroup.getLeafColumns().forEach(function (column) {
            if (column.getColDef().suppressMovable) {
                atLeastOneChildNotMovable = true;
            }
        });
        if (atLeastOneChildNotMovable) {
            return;
        }
        // don't allow moving of headers when forPrint, as the header overlay doesn't exist
        if (this.gridOptionsWrapper.isForPrint()) {
            return;
        }
        if (eLabel) {
            var dragSource = {
                eElement: eLabel,
                dragItemName: this.displayName,
                // we add in the original group leaf columns, so we move both visible and non-visible items
                dragItem: this.getAllColumnsInThisGroup(),
                dragSourceDropTarget: this.dragSourceDropTarget
            };
            this.dragAndDropService.addDragSource(dragSource);
        }
    };
    // when moving the columns, we want to move all the columns in this group in one go, and in the order they
    // are currently in the screen.
    RenderedHeaderGroupCell.prototype.getAllColumnsInThisGroup = function () {
        var allColumnsOriginalOrder = this.columnGroup.getOriginalColumnGroup().getLeafColumns();
        var allColumnsCurrentOrder = [];
        this.columnController.getAllDisplayedColumns().forEach(function (column) {
            if (allColumnsOriginalOrder.indexOf(column) >= 0) {
                allColumnsCurrentOrder.push(column);
                utils_1.Utils.removeFromArray(allColumnsOriginalOrder, column);
            }
        });
        // we are left with non-visible columns, stick these in at the end
        allColumnsOriginalOrder.forEach(function (column) { return allColumnsCurrentOrder.push(column); });
        return allColumnsCurrentOrder;
    };
    RenderedHeaderGroupCell.prototype.setWidth = function () {
        var _this = this;
        var widthChangedListener = function () {
            _this.eHeaderGroupCell.style.width = _this.columnGroup.getActualWidth() + 'px';
        };
        this.columnGroup.getLeafColumns().forEach(function (column) {
            column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
            _this.destroyFunctions.push(function () {
                column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
            });
        });
        widthChangedListener();
    };
    RenderedHeaderGroupCell.prototype.destroy = function () {
        this.destroyFunctions.forEach(function (func) {
            func();
        });
    };
    RenderedHeaderGroupCell.prototype.addGroupExpandIcon = function (eGroupCellLabel) {
        var eGroupIcon;
        if (this.columnGroup.isExpanded()) {
            eGroupIcon = utils_1.Utils.createIcon('columnGroupOpened', this.gridOptionsWrapper, null, svgFactory.createGroupContractedIcon);
        }
        else {
            eGroupIcon = utils_1.Utils.createIcon('columnGroupClosed', this.gridOptionsWrapper, null, svgFactory.createGroupExpandedIcon);
        }
        eGroupIcon.className = 'ag-header-expand-icon';
        eGroupCellLabel.appendChild(eGroupIcon);
        var that = this;
        eGroupIcon.onclick = function () {
            var newExpandedValue = !that.columnGroup.isExpanded();
            that.columnController.setColumnGroupOpened(that.columnGroup, newExpandedValue);
        };
    };
    RenderedHeaderGroupCell.prototype.onDragStart = function () {
        var _this = this;
        this.groupWidthStart = this.columnGroup.getActualWidth();
        this.childrenWidthStarts = [];
        this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
            _this.childrenWidthStarts.push(column.getActualWidth());
        });
    };
    RenderedHeaderGroupCell.prototype.onDragging = function (dragChange, finished) {
        var _this = this;
        var newWidth = this.groupWidthStart + dragChange;
        var minWidth = this.columnGroup.getMinWidth();
        if (newWidth < minWidth) {
            newWidth = minWidth;
        }
        // distribute the new width to the child headers
        var changeRatio = newWidth / this.groupWidthStart;
        // keep track of pixels used, and last column gets the remaining,
        // to cater for rounding errors, and min width adjustments
        var pixelsToDistribute = newWidth;
        var displayedColumns = this.columnGroup.getDisplayedLeafColumns();
        displayedColumns.forEach(function (column, index) {
            var notLastCol = index !== (displayedColumns.length - 1);
            var newChildSize;
            if (notLastCol) {
                // if not the last col, calculate the column width as normal
                var startChildSize = _this.childrenWidthStarts[index];
                newChildSize = startChildSize * changeRatio;
                if (newChildSize < column.getMinWidth()) {
                    newChildSize = column.getMinWidth();
                }
                pixelsToDistribute -= newChildSize;
            }
            else {
                // if last col, give it the remaining pixels
                newChildSize = pixelsToDistribute;
            }
            _this.columnController.setColumnWidth(column, newChildSize, finished);
        });
    };
    __decorate([
        context_1.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], RenderedHeaderGroupCell.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], RenderedHeaderGroupCell.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('horizontalDragService'), 
        __metadata('design:type', horizontalDragService_1.HorizontalDragService)
    ], RenderedHeaderGroupCell.prototype, "dragService", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], RenderedHeaderGroupCell.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('dragAndDropService'), 
        __metadata('design:type', dragAndDropService_1.DragAndDropService)
    ], RenderedHeaderGroupCell.prototype, "dragAndDropService", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], RenderedHeaderGroupCell.prototype, "init", null);
    return RenderedHeaderGroupCell;
})();
exports.RenderedHeaderGroupCell = RenderedHeaderGroupCell;

},{"../columnController/columnController":77,"../context/context":87,"../dragAndDrop/dragAndDropService":89,"../entities/column":92,"../filter/filterManager":101,"../gridOptionsWrapper":109,"../svgFactory":154,"../utils":156,"./cssClassApplier":112,"./horizontalDragService":116}],120:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var filterManager_1 = require("../filter/filterManager");
var utils_1 = require('../utils');
var context_2 = require("../context/context");
var popupService_1 = require("../widgets/popupService");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var StandardMenuFactory = (function () {
    function StandardMenuFactory() {
    }
    StandardMenuFactory.prototype.showMenuAfterMouseEvent = function (column, mouseEvent) {
        var _this = this;
        this.showPopup(column, function (eMenu) {
            _this.popupService.positionPopupUnderMouseEvent({
                mouseEvent: mouseEvent,
                ePopup: eMenu
            });
        });
    };
    StandardMenuFactory.prototype.showMenuAfterButtonClick = function (column, eventSource) {
        var _this = this;
        this.showPopup(column, function (eMenu) {
            _this.popupService.positionPopupUnderComponent({ eventSource: eventSource, ePopup: eMenu, keepWithinBounds: true });
        });
    };
    StandardMenuFactory.prototype.showPopup = function (column, positionCallback) {
        var filterWrapper = this.filterManager.getOrCreateFilterWrapper(column);
        var eMenu = document.createElement('div');
        utils_1.Utils.addCssClass(eMenu, 'ag-menu');
        eMenu.appendChild(filterWrapper.gui);
        // need to show filter before positioning, as only after filter
        // is visible can we find out what the width of it is
        var hidePopup = this.popupService.addAsModalPopup(eMenu, true);
        positionCallback(eMenu);
        if (filterWrapper.filter.afterGuiAttached) {
            var params = {
                hidePopup: hidePopup
            };
            filterWrapper.filter.afterGuiAttached(params);
        }
    };
    StandardMenuFactory.prototype.isMenuEnabled = function (column) {
        // for standard, we show menu if filter is enabled, and he menu is not suppressed
        return this.gridOptionsWrapper.isEnableFilter();
    };
    __decorate([
        context_2.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], StandardMenuFactory.prototype, "filterManager", void 0);
    __decorate([
        context_2.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], StandardMenuFactory.prototype, "popupService", void 0);
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], StandardMenuFactory.prototype, "gridOptionsWrapper", void 0);
    StandardMenuFactory = __decorate([
        context_1.Bean('menuFactory'), 
        __metadata('design:paramtypes', [])
    ], StandardMenuFactory);
    return StandardMenuFactory;
})();
exports.StandardMenuFactory = StandardMenuFactory;

},{"../context/context":87,"../filter/filterManager":101,"../gridOptionsWrapper":109,"../utils":156,"../widgets/popupService":161}],121:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('../utils');
var BorderLayout = (function () {
    function BorderLayout(params) {
        this.sizeChangeListeners = [];
        this.isLayoutPanel = true;
        this.fullHeight = !params.north && !params.south;
        var template;
        if (!params.dontFill) {
            if (this.fullHeight) {
                template =
                    '<div style="height: 100%; overflow: auto; position: relative;">' +
                        '<div id="west" style="height: 100%; float: left;"></div>' +
                        '<div id="east" style="height: 100%; float: right;"></div>' +
                        '<div id="center" style="height: 100%;"></div>' +
                        '<div id="overlay" style="pointer-events: none; position: absolute; height: 100%; width: 100%; top: 0px; left: 0px;"></div>' +
                        '</div>';
            }
            else {
                template =
                    '<div style="height: 100%; position: relative;">' +
                        '<div id="north"></div>' +
                        '<div id="centerRow" style="height: 100%; overflow: hidden;">' +
                        '<div id="west" style="height: 100%; float: left;"></div>' +
                        '<div id="east" style="height: 100%; float: right;"></div>' +
                        '<div id="center" style="height: 100%;"></div>' +
                        '</div>' +
                        '<div id="south"></div>' +
                        '<div id="overlay" style="pointer-events: none; position: absolute; height: 100%; width: 100%; top: 0px; left: 0px;"></div>' +
                        '</div>';
            }
            this.layoutActive = true;
        }
        else {
            template =
                '<div style="position: relative;">' +
                    '<div id="north"></div>' +
                    '<div id="centerRow">' +
                    '<div id="west"></div>' +
                    '<div id="east"></div>' +
                    '<div id="center"></div>' +
                    '</div>' +
                    '<div id="south"></div>' +
                    '<div id="overlay" style="pointer-events: none; position: absolute; height: 100%; width: 100%; top: 0px; left: 0px;"></div>' +
                    '</div>';
            this.layoutActive = false;
        }
        this.eGui = utils_1.Utils.loadTemplate(template);
        this.id = 'borderLayout';
        if (params.name) {
            this.id += '_' + params.name;
        }
        this.eGui.setAttribute('id', this.id);
        this.childPanels = [];
        if (params) {
            this.setupPanels(params);
        }
        this.overlays = params.overlays;
        this.setupOverlays();
    }
    BorderLayout.prototype.addSizeChangeListener = function (listener) {
        this.sizeChangeListeners.push(listener);
    };
    BorderLayout.prototype.fireSizeChanged = function () {
        this.sizeChangeListeners.forEach(function (listener) {
            listener();
        });
    };
    BorderLayout.prototype.setupPanels = function (params) {
        this.eNorthWrapper = this.eGui.querySelector('#north');
        this.eSouthWrapper = this.eGui.querySelector('#south');
        this.eEastWrapper = this.eGui.querySelector('#east');
        this.eWestWrapper = this.eGui.querySelector('#west');
        this.eCenterWrapper = this.eGui.querySelector('#center');
        this.eOverlayWrapper = this.eGui.querySelector('#overlay');
        this.eCenterRow = this.eGui.querySelector('#centerRow');
        this.eNorthChildLayout = this.setupPanel(params.north, this.eNorthWrapper);
        this.eSouthChildLayout = this.setupPanel(params.south, this.eSouthWrapper);
        this.eEastChildLayout = this.setupPanel(params.east, this.eEastWrapper);
        this.eWestChildLayout = this.setupPanel(params.west, this.eWestWrapper);
        this.eCenterChildLayout = this.setupPanel(params.center, this.eCenterWrapper);
    };
    BorderLayout.prototype.setupPanel = function (content, ePanel) {
        if (!ePanel) {
            return;
        }
        if (content) {
            if (content.isLayoutPanel) {
                this.childPanels.push(content);
                ePanel.appendChild(content.getGui());
                return content;
            }
            else {
                ePanel.appendChild(content);
                return null;
            }
        }
        else {
            ePanel.parentNode.removeChild(ePanel);
            return null;
        }
    };
    BorderLayout.prototype.getGui = function () {
        return this.eGui;
    };
    // returns true if any item changed size, otherwise returns false
    BorderLayout.prototype.doLayout = function () {
        if (!utils_1.Utils.isVisible(this.eGui)) {
            return false;
        }
        var atLeastOneChanged = false;
        var childLayouts = [this.eNorthChildLayout, this.eSouthChildLayout, this.eEastChildLayout, this.eWestChildLayout];
        var that = this;
        utils_1.Utils.forEach(childLayouts, function (childLayout) {
            var childChangedSize = that.layoutChild(childLayout);
            if (childChangedSize) {
                atLeastOneChanged = true;
            }
        });
        if (this.layoutActive) {
            var ourHeightChanged = this.layoutHeight();
            var ourWidthChanged = this.layoutWidth();
            if (ourHeightChanged || ourWidthChanged) {
                atLeastOneChanged = true;
            }
        }
        var centerChanged = this.layoutChild(this.eCenterChildLayout);
        if (centerChanged) {
            atLeastOneChanged = true;
        }
        if (atLeastOneChanged) {
            this.fireSizeChanged();
        }
        return atLeastOneChanged;
    };
    BorderLayout.prototype.layoutChild = function (childPanel) {
        if (childPanel) {
            return childPanel.doLayout();
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.layoutHeight = function () {
        if (this.fullHeight) {
            return this.layoutHeightFullHeight();
        }
        else {
            return this.layoutHeightNormal();
        }
    };
    // full height never changes the height, because the center is always 100%,
    // however we do check for change, to inform the listeners
    BorderLayout.prototype.layoutHeightFullHeight = function () {
        var centerHeight = utils_1.Utils.offsetHeight(this.eGui);
        if (centerHeight < 0) {
            centerHeight = 0;
        }
        if (this.centerHeightLastTime !== centerHeight) {
            this.centerHeightLastTime = centerHeight;
            return true;
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.layoutHeightNormal = function () {
        var totalHeight = utils_1.Utils.offsetHeight(this.eGui);
        var northHeight = utils_1.Utils.offsetHeight(this.eNorthWrapper);
        var southHeight = utils_1.Utils.offsetHeight(this.eSouthWrapper);
        var centerHeight = totalHeight - northHeight - southHeight;
        if (centerHeight < 0) {
            centerHeight = 0;
        }
        if (this.centerHeightLastTime !== centerHeight) {
            this.eCenterRow.style.height = centerHeight + 'px';
            this.centerHeightLastTime = centerHeight;
            return true; // return true because there was a change
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.getCentreHeight = function () {
        return this.centerHeightLastTime;
    };
    BorderLayout.prototype.layoutWidth = function () {
        var totalWidth = utils_1.Utils.offsetWidth(this.eGui);
        var eastWidth = utils_1.Utils.offsetWidth(this.eEastWrapper);
        var westWidth = utils_1.Utils.offsetWidth(this.eWestWrapper);
        var centerWidth = totalWidth - eastWidth - westWidth;
        if (centerWidth < 0) {
            centerWidth = 0;
        }
        if (this.centerWidthLastTime !== centerWidth) {
            this.centerWidthLastTime = centerWidth;
            this.eCenterWrapper.style.width = centerWidth + 'px';
            return true; // return true because there was a change
        }
        else {
            return false;
        }
    };
    BorderLayout.prototype.setEastVisible = function (visible) {
        if (this.eEastWrapper) {
            this.eEastWrapper.style.display = visible ? '' : 'none';
        }
        this.doLayout();
    };
    BorderLayout.prototype.setNorthVisible = function (visible) {
        if (this.eNorthWrapper) {
            this.eNorthWrapper.style.display = visible ? '' : 'none';
        }
        this.doLayout();
    };
    BorderLayout.prototype.setupOverlays = function () {
        // if no overlays, just remove the panel
        if (!this.overlays) {
            this.eOverlayWrapper.parentNode.removeChild(this.eOverlayWrapper);
            return;
        }
        this.hideOverlay();
        //
        //this.setOverlayVisible(false);
    };
    BorderLayout.prototype.hideOverlay = function () {
        utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
        this.eOverlayWrapper.style.display = 'none';
    };
    BorderLayout.prototype.showOverlay = function (key) {
        var overlay = this.overlays ? this.overlays[key] : null;
        if (overlay) {
            utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
            this.eOverlayWrapper.style.display = '';
            this.eOverlayWrapper.appendChild(overlay);
        }
        else {
            console.log('ag-Grid: unknown overlay');
            this.hideOverlay();
        }
    };
    BorderLayout.prototype.setSouthVisible = function (visible) {
        if (this.eSouthWrapper) {
            this.eSouthWrapper.style.display = visible ? '' : 'none';
        }
        this.doLayout();
    };
    return BorderLayout;
})();
exports.BorderLayout = BorderLayout;

},{"../utils":156}],122:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('../utils');
var TabbedLayout = (function () {
    function TabbedLayout(params) {
        var _this = this;
        this.items = [];
        this.params = params;
        this.eGui = document.createElement('div');
        this.eGui.innerHTML = TabbedLayout.TEMPLATE;
        this.eHeader = this.eGui.querySelector('#tabHeader');
        this.eBody = this.eGui.querySelector('#tabBody');
        utils_1.Utils.addCssClass(this.eGui, params.cssClass);
        if (params.items) {
            params.items.forEach(function (item) { return _this.addItem(item); });
        }
    }
    TabbedLayout.prototype.setAfterAttachedParams = function (params) {
        this.afterAttachedParams = params;
    };
    TabbedLayout.prototype.getMinWidth = function () {
        var eDummyContainer = document.createElement('span');
        // position fixed, so it isn't restricted to the boundaries of the parent
        eDummyContainer.style.position = 'fixed';
        // we put the dummy into the body container, so it will inherit all the
        // css styles that the real cells are inheriting
        this.eGui.appendChild(eDummyContainer);
        var minWidth = 0;
        this.items.forEach(function (itemWrapper) {
            utils_1.Utils.removeAllChildren(eDummyContainer);
            var eClone = itemWrapper.tabbedItem.body.cloneNode(true);
            eDummyContainer.appendChild(eClone);
            if (minWidth < eDummyContainer.offsetWidth) {
                minWidth = eDummyContainer.offsetWidth;
            }
        });
        this.eGui.removeChild(eDummyContainer);
        return minWidth;
    };
    TabbedLayout.prototype.showFirstItem = function () {
        if (this.items.length > 0) {
            this.showItemWrapper(this.items[0]);
        }
    };
    TabbedLayout.prototype.addItem = function (item) {
        var eHeaderButton = document.createElement('span');
        eHeaderButton.appendChild(item.title);
        utils_1.Utils.addCssClass(eHeaderButton, 'ag-tab');
        this.eHeader.appendChild(eHeaderButton);
        var wrapper = {
            tabbedItem: item,
            eHeaderButton: eHeaderButton
        };
        this.items.push(wrapper);
        eHeaderButton.addEventListener('click', this.showItemWrapper.bind(this, wrapper));
    };
    TabbedLayout.prototype.showItem = function (tabbedItem) {
        var itemWrapper = utils_1.Utils.find(this.items, function (itemWrapper) {
            return itemWrapper.tabbedItem === tabbedItem;
        });
        if (itemWrapper) {
            this.showItemWrapper(itemWrapper);
        }
    };
    TabbedLayout.prototype.showItemWrapper = function (wrapper) {
        if (this.params.onItemClicked) {
            this.params.onItemClicked({ item: wrapper.tabbedItem });
        }
        if (this.activeItem === wrapper) {
            utils_1.Utils.callIfPresent(this.params.onActiveItemClicked);
            return;
        }
        utils_1.Utils.removeAllChildren(this.eBody);
        this.eBody.appendChild(wrapper.tabbedItem.body);
        if (this.activeItem) {
            utils_1.Utils.removeCssClass(this.activeItem.eHeaderButton, 'ag-tab-selected');
        }
        utils_1.Utils.addCssClass(wrapper.eHeaderButton, 'ag-tab-selected');
        this.activeItem = wrapper;
        if (wrapper.tabbedItem.afterAttachedCallback) {
            wrapper.tabbedItem.afterAttachedCallback(this.afterAttachedParams);
        }
    };
    TabbedLayout.prototype.getGui = function () {
        return this.eGui;
    };
    TabbedLayout.TEMPLATE = '<div>' +
        '<div id="tabHeader" class="ag-tab-header"></div>' +
        '<div id="tabBody" class="ag-tab-body"></div>' +
        '</div>';
    return TabbedLayout;
})();
exports.TabbedLayout = TabbedLayout;

},{"../utils":156}],123:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var VerticalStack = (function () {
    function VerticalStack() {
        this.isLayoutPanel = true;
        this.childPanels = [];
        this.eGui = document.createElement('div');
        this.eGui.style.height = '100%';
    }
    VerticalStack.prototype.addPanel = function (panel, height) {
        var component;
        if (panel.isLayoutPanel) {
            this.childPanels.push(panel);
            component = panel.getGui();
        }
        else {
            component = panel;
        }
        if (height) {
            component.style.height = height;
        }
        this.eGui.appendChild(component);
    };
    VerticalStack.prototype.getGui = function () {
        return this.eGui;
    };
    VerticalStack.prototype.doLayout = function () {
        for (var i = 0; i < this.childPanels.length; i++) {
            this.childPanels[i].doLayout();
        }
    };
    return VerticalStack;
})();
exports.VerticalStack = VerticalStack;

},{}],124:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var LoggerFactory = (function () {
    function LoggerFactory() {
    }
    LoggerFactory.prototype.setBeans = function (gridOptionsWrapper) {
        this.logging = gridOptionsWrapper.isDebug();
    };
    LoggerFactory.prototype.create = function (name) {
        return new Logger(name, this.logging);
    };
    __decorate([
        __param(0, context_2.Qualifier('gridOptionsWrapper')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [gridOptionsWrapper_1.GridOptionsWrapper]), 
        __metadata('design:returntype', void 0)
    ], LoggerFactory.prototype, "setBeans", null);
    LoggerFactory = __decorate([
        context_1.Bean('loggerFactory'), 
        __metadata('design:paramtypes', [])
    ], LoggerFactory);
    return LoggerFactory;
})();
exports.LoggerFactory = LoggerFactory;
var Logger = (function () {
    function Logger(name, logging) {
        this.name = name;
        this.logging = logging;
    }
    Logger.prototype.log = function (message) {
        if (this.logging) {
            console.log('ag-Grid.' + this.name + ': ' + message);
        }
    };
    return Logger;
})();
exports.Logger = Logger;

},{"./context/context":87,"./gridOptionsWrapper":109}],125:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var columnController_1 = require("./columnController/columnController");
var gridPanel_1 = require("./gridPanel/gridPanel");
var eventService_1 = require("./eventService");
var logger_1 = require("./logger");
var events_1 = require("./events");
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var context_3 = require("./context/context");
var context_4 = require("./context/context");
var MasterSlaveService = (function () {
    function MasterSlaveService() {
        // flag to mark if we are consuming. to avoid cyclic events (ie slave firing back to master
        // while processing a master event) we mark this if consuming an event, and if we are, then
        // we don't fire back any events.
        this.consuming = false;
    }
    MasterSlaveService.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('MasterSlaveService');
    };
    MasterSlaveService.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));
    };
    // common logic across all the fire methods
    MasterSlaveService.prototype.fireEvent = function (callback) {
        // if we are already consuming, then we are acting on an event from a master,
        // so we don't cause a cyclic firing of events
        if (this.consuming) {
            return;
        }
        // iterate through the slave grids, and pass each slave service to the callback
        var slaveGrids = this.gridOptionsWrapper.getSlaveGrids();
        if (slaveGrids) {
            slaveGrids.forEach(function (slaveGridOptions) {
                if (slaveGridOptions.api) {
                    var slaveService = slaveGridOptions.api.__getMasterSlaveService();
                    callback(slaveService);
                }
            });
        }
    };
    // common logic across all consume methods. very little common logic, however extracting
    // guarantees consistency across the methods.
    MasterSlaveService.prototype.onEvent = function (callback) {
        this.consuming = true;
        callback();
        this.consuming = false;
    };
    MasterSlaveService.prototype.fireColumnEvent = function (event) {
        this.fireEvent(function (slaveService) {
            slaveService.onColumnEvent(event);
        });
    };
    MasterSlaveService.prototype.fireHorizontalScrollEvent = function (horizontalScroll) {
        this.fireEvent(function (slaveService) {
            slaveService.onScrollEvent(horizontalScroll);
        });
    };
    MasterSlaveService.prototype.onScrollEvent = function (horizontalScroll) {
        var _this = this;
        this.onEvent(function () {
            _this.gridPanel.setHorizontalScrollPosition(horizontalScroll);
        });
    };
    MasterSlaveService.prototype.getMasterColumns = function (event) {
        var result = [];
        if (event.getColumn()) {
            result.push(event.getColumn());
        }
        if (event.getColumns()) {
            event.getColumns().forEach(function (column) {
                result.push(column);
            });
        }
        return result;
    };
    MasterSlaveService.prototype.getColumnIds = function (event) {
        var result = [];
        if (event.getColumn()) {
            result.push(event.getColumn().getColId());
        }
        else if (event.getColumns()) {
            event.getColumns().forEach(function (column) {
                result.push(column.getColId());
            });
        }
        return result;
    };
    MasterSlaveService.prototype.onColumnEvent = function (event) {
        var _this = this;
        this.onEvent(function () {
            // the column in the event is from the master grid. need to
            // look up the equivalent from this (slave) grid
            var masterColumn = event.getColumn();
            var slaveColumn;
            if (masterColumn) {
                slaveColumn = _this.columnController.getOriginalColumn(masterColumn.getColId());
            }
            // if event was with respect to a master column, that is not present in this
            // grid, then we ignore the event
            if (masterColumn && !slaveColumn) {
                return;
            }
            // likewise for column group
            var masterColumnGroup = event.getColumnGroup();
            var slaveColumnGroup;
            if (masterColumnGroup) {
                var colId = masterColumnGroup.getGroupId();
                var instanceId = masterColumnGroup.getInstanceId();
                slaveColumnGroup = _this.columnController.getColumnGroup(colId, instanceId);
            }
            if (masterColumnGroup && !slaveColumnGroup) {
                return;
            }
            // in time, all the methods below should use the column ids, it's a more generic way
            // of handling columns, and also allows for single or multi column events
            var columnIds = _this.getColumnIds(event);
            var masterColumns = _this.getMasterColumns(event);
            switch (event.getType()) {
                case events_1.Events.EVENT_COLUMN_PIVOT_CHANGED:
                    // we cannot support pivoting with master / slave as the columns will be out of sync as the
                    // grids will have columns created based on the row data of the grid.
                    console.warn('ag-Grid: pivoting is not supported with Master / Slave grids. ' +
                        'You can only use one of these features at a time in a grid.');
                    break;
                case events_1.Events.EVENT_COLUMN_MOVED:
                    _this.logger.log('onColumnEvent-> processing ' + event + ' toIndex = ' + event.getToIndex());
                    _this.columnController.moveColumns(columnIds, event.getToIndex());
                    break;
                case events_1.Events.EVENT_COLUMN_VISIBLE:
                    _this.logger.log('onColumnEvent-> processing ' + event + ' visible = ' + event.isVisible());
                    _this.columnController.setColumnsVisible(columnIds, event.isVisible());
                    break;
                case events_1.Events.EVENT_COLUMN_PINNED:
                    _this.logger.log('onColumnEvent-> processing ' + event + ' pinned = ' + event.getPinned());
                    _this.columnController.setColumnsPinned(columnIds, event.getPinned());
                    break;
                case events_1.Events.EVENT_COLUMN_GROUP_OPENED:
                    _this.logger.log('onColumnEvent-> processing ' + event + ' expanded = ' + masterColumnGroup.isExpanded());
                    _this.columnController.setColumnGroupOpened(slaveColumnGroup, masterColumnGroup.isExpanded());
                    break;
                case events_1.Events.EVENT_COLUMN_RESIZED:
                    masterColumns.forEach(function (masterColumn) {
                        _this.logger.log('onColumnEvent-> processing ' + event + ' actualWidth = ' + masterColumn.getActualWidth());
                        _this.columnController.setColumnWidth(masterColumn.getColId(), masterColumn.getActualWidth(), event.isFinished());
                    });
                    break;
            }
        });
    };
    __decorate([
        context_3.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], MasterSlaveService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_3.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], MasterSlaveService.prototype, "columnController", void 0);
    __decorate([
        context_3.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], MasterSlaveService.prototype, "gridPanel", void 0);
    __decorate([
        context_3.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], MasterSlaveService.prototype, "eventService", void 0);
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], MasterSlaveService.prototype, "setBeans", null);
    __decorate([
        context_4.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], MasterSlaveService.prototype, "init", null);
    MasterSlaveService = __decorate([
        context_1.Bean('masterSlaveService'), 
        __metadata('design:paramtypes', [])
    ], MasterSlaveService);
    return MasterSlaveService;
})();
exports.MasterSlaveService = MasterSlaveService;

},{"./columnController/columnController":77,"./context/context":87,"./eventService":98,"./events":99,"./gridOptionsWrapper":109,"./gridPanel/gridPanel":110,"./logger":124}],126:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var utils_1 = require('../utils');
var gridCore_1 = require("../gridCore");
var columnController_1 = require("../columnController/columnController");
var constants_1 = require("../constants");
var gridCell_1 = require("../entities/gridCell");
// tracks when focus goes into a cell. cells listen to this, so they know to stop editing
// if focus goes into another cell.
var FocusService = (function () {
    function FocusService() {
        this.destroyMethods = [];
        this.listeners = [];
    }
    FocusService.prototype.addListener = function (listener) {
        this.listeners.push(listener);
    };
    FocusService.prototype.removeListener = function (listener) {
        utils_1.Utils.removeFromArray(this.listeners, listener);
    };
    FocusService.prototype.init = function () {
        var _this = this;
        var focusListener = function (focusEvent) {
            var gridCell = _this.getCellForFocus(focusEvent);
            if (gridCell) {
                _this.informListeners({ gridCell: gridCell });
            }
        };
        var eRootGui = this.gridCore.getRootGui();
        eRootGui.addEventListener('focus', focusListener, true);
        this.destroyMethods.push(function () {
            eRootGui.removeEventListener('focus', focusListener);
        });
    };
    FocusService.prototype.getCellForFocus = function (focusEvent) {
        var column = null;
        var row = null;
        var floating = null;
        var that = this;
        var eTarget = focusEvent.target;
        while (eTarget) {
            checkRow(eTarget);
            checkColumn(eTarget);
            eTarget = eTarget.parentNode;
        }
        if (utils_1.Utils.exists(column) && utils_1.Utils.exists(row)) {
            var gridCell = new gridCell_1.GridCell(row, floating, column);
            return gridCell;
        }
        else {
            return null;
        }
        function checkRow(eTarget) {
            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
            var rowId = utils_1.Utils.getElementAttribute(eTarget, 'row');
            if (utils_1.Utils.exists(rowId) && utils_1.Utils.containsClass(eTarget, 'ag-row')) {
                if (rowId.indexOf('ft') === 0) {
                    floating = constants_1.Constants.FLOATING_TOP;
                    rowId = rowId.substr(3);
                }
                else if (rowId.indexOf('fb') === 0) {
                    floating = constants_1.Constants.FLOATING_BOTTOM;
                    rowId = rowId.substr(3);
                }
                else {
                    floating = null;
                }
                row = parseInt(rowId);
            }
        }
        function checkColumn(eTarget) {
            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
            var colId = utils_1.Utils.getElementAttribute(eTarget, 'colid');
            if (utils_1.Utils.exists(colId) && utils_1.Utils.containsClass(eTarget, 'ag-cell')) {
                var foundColumn = that.columnController.getOriginalColumn(colId);
                if (foundColumn) {
                    column = foundColumn;
                }
            }
        }
    };
    FocusService.prototype.informListeners = function (event) {
        this.listeners.forEach(function (listener) { return listener(event); });
    };
    FocusService.prototype.destroy = function () {
        this.destroyMethods.forEach(function (destroyMethod) { return destroyMethod(); });
    };
    __decorate([
        context_1.Autowired('gridCore'), 
        __metadata('design:type', gridCore_1.GridCore)
    ], FocusService.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], FocusService.prototype, "columnController", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], FocusService.prototype, "init", null);
    __decorate([
        context_1.PreDestroy, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], FocusService.prototype, "destroy", null);
    FocusService = __decorate([
        context_1.Bean('focusService'), 
        __metadata('design:paramtypes', [])
    ], FocusService);
    return FocusService;
})();
exports.FocusService = FocusService;

},{"../columnController/columnController":77,"../constants":86,"../context/context":87,"../entities/gridCell":94,"../gridCore":108,"../utils":156}],127:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var rowRenderer_1 = require("./rowRenderer");
var gridPanel_1 = require("../gridPanel/gridPanel");
var context_1 = require("../context/context");
var context_2 = require("../context/context");
var AutoWidthCalculator = (function () {
    function AutoWidthCalculator() {
    }
    // this is the trick: we create a dummy container and clone all the cells
    // into the dummy, then check the dummy's width. then destroy the dummy
    // as we don't need it any more.
    // drawback: only the cells visible on the screen are considered
    AutoWidthCalculator.prototype.getPreferredWidthForColumn = function (column) {
        var eDummyContainer = document.createElement('span');
        // position fixed, so it isn't restricted to the boundaries of the parent
        eDummyContainer.style.position = 'fixed';
        // we put the dummy into the body container, so it will inherit all the
        // css styles that the real cells are inheriting
        var eBodyContainer = this.gridPanel.getBodyContainer();
        eBodyContainer.appendChild(eDummyContainer);
        // get all the cells that are currently displayed (this only brings back
        // rendered cells, rows not rendered due to row visualisation will not be here)
        var eOriginalCells = this.rowRenderer.getAllCellsForColumn(column);
        eOriginalCells.forEach(function (eCell, index) {
            // make a deep clone of the cell
            var eCellClone = eCell.cloneNode(true);
            // the original has a fixed width, we remove this to allow the natural width based on content
            eCellClone.style.width = '';
            // the original has position = absolute, we need to remove this so it's positioned normally
            eCellClone.style.position = 'static';
            eCellClone.style.left = '';
            // we put the cell into a containing div, as otherwise the cells would just line up
            // on the same line, standard flow layout, by putting them into divs, they are laid
            // out one per line
            var eCloneParent = document.createElement('div');
            // table-row, so that each cell is on a row. i also tried display='block', but this
            // didn't work in IE
            eCloneParent.style.display = 'table-row';
            // the twig on the branch, the branch on the tree, the tree in the hole,
            // the hole in the bog, the bog in the clone, the clone in the parent,
            // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....
            eCloneParent.appendChild(eCellClone);
            eDummyContainer.appendChild(eCloneParent);
        });
        // at this point, all the clones are lined up vertically with natural widths. the dummy
        // container will have a width wide enough just to fit the largest.
        var dummyContainerWidth = eDummyContainer.offsetWidth;
        // we are finished with the dummy container, so get rid of it
        eBodyContainer.removeChild(eDummyContainer);
        // we add 4 as I found without it, the gui still put '...' after some of the texts
        return dummyContainerWidth + 4;
    };
    __decorate([
        context_2.Autowired('rowRenderer'), 
        __metadata('design:type', rowRenderer_1.RowRenderer)
    ], AutoWidthCalculator.prototype, "rowRenderer", void 0);
    __decorate([
        context_2.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], AutoWidthCalculator.prototype, "gridPanel", void 0);
    AutoWidthCalculator = __decorate([
        context_1.Bean('autoWidthCalculator'), 
        __metadata('design:paramtypes', [])
    ], AutoWidthCalculator);
    return AutoWidthCalculator;
})();
exports.AutoWidthCalculator = AutoWidthCalculator;

},{"../context/context":87,"../gridPanel/gridPanel":110,"./rowRenderer":143}],128:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var utils_1 = require('../utils');
var textCellEditor_1 = require("./cellEditors/textCellEditor");
var selectCellEditor_1 = require("./cellEditors/selectCellEditor");
var popupEditorWrapper_1 = require("./cellEditors/popupEditorWrapper");
var popupTextCellEditor_1 = require("./cellEditors/popupTextCellEditor");
var popupSelectCellEditor_1 = require("./cellEditors/popupSelectCellEditor");
var dateCellEditor_1 = require("./cellEditors/dateCellEditor");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var CellEditorFactory = (function () {
    function CellEditorFactory() {
        this.cellEditorMap = {};
    }
    CellEditorFactory.prototype.init = function () {
        this.cellEditorMap[CellEditorFactory.TEXT] = textCellEditor_1.TextCellEditor;
        this.cellEditorMap[CellEditorFactory.SELECT] = selectCellEditor_1.SelectCellEditor;
        this.cellEditorMap[CellEditorFactory.POPUP_TEXT] = popupTextCellEditor_1.PopupTextCellEditor;
        this.cellEditorMap[CellEditorFactory.POPUP_SELECT] = popupSelectCellEditor_1.PopupSelectCellEditor;
        this.cellEditorMap[CellEditorFactory.DATE] = dateCellEditor_1.DateCellEditor;
    };
    CellEditorFactory.prototype.addCellEditor = function (key, cellEditor) {
        this.cellEditorMap[key] = cellEditor;
    };
    // private registerEditorsFromGridOptions(): void {
    //     var userProvidedCellEditors = this.gridOptionsWrapper.getCellEditors();
    //     _.iterateObject(userProvidedCellEditors, (key: string, cellEditor: {new(): ICellEditor})=> {
    //         this.addCellEditor(key, cellEditor);
    //     });
    // }
    CellEditorFactory.prototype.createCellEditor = function (key) {
        var CellEditorClass;
        if (utils_1.Utils.missing(key)) {
            CellEditorClass = this.cellEditorMap[CellEditorFactory.TEXT];
        }
        else if (typeof key === 'string') {
            CellEditorClass = this.cellEditorMap[key];
            if (utils_1.Utils.missing(CellEditorClass)) {
                console.warn('ag-Grid: unable to find cellEditor for key ' + key);
                CellEditorClass = this.cellEditorMap[CellEditorFactory.TEXT];
            }
        }
        else {
            CellEditorClass = key;
        }
        var cellEditor = new CellEditorClass();
        this.context.wireBean(cellEditor);
        if (cellEditor.isPopup && cellEditor.isPopup()) {
            cellEditor = new popupEditorWrapper_1.PopupEditorWrapper(cellEditor);
        }
        return cellEditor;
    };
    CellEditorFactory.TEXT = 'text';
    CellEditorFactory.SELECT = 'select';
    CellEditorFactory.DATE = 'date';
    CellEditorFactory.POPUP_TEXT = 'popupText';
    CellEditorFactory.POPUP_SELECT = 'popupSelect';
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], CellEditorFactory.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], CellEditorFactory.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], CellEditorFactory.prototype, "init", null);
    CellEditorFactory = __decorate([
        context_1.Bean('cellEditorFactory'), 
        __metadata('design:paramtypes', [])
    ], CellEditorFactory);
    return CellEditorFactory;
})();
exports.CellEditorFactory = CellEditorFactory;

},{"../context/context":87,"../gridOptionsWrapper":109,"../utils":156,"./cellEditors/dateCellEditor":129,"./cellEditors/popupEditorWrapper":130,"./cellEditors/popupSelectCellEditor":131,"./cellEditors/popupTextCellEditor":132,"./cellEditors/selectCellEditor":133,"./cellEditors/textCellEditor":134}],129:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var component_1 = require("../../widgets/component");
var context_1 = require("../../context/context");
var popupService_1 = require("../../widgets/popupService");
var utils_1 = require('../../utils');
var DateCellEditor = (function (_super) {
    __extends(DateCellEditor, _super);
    function DateCellEditor() {
        _super.call(this, DateCellEditor.TEMPLATE);
        this.eText = this.queryForHtmlInputElement('input');
        this.eButton = this.queryForHtmlElement('button');
        this.eButton.addEventListener('click', this.onBtPush.bind(this));
    }
    DateCellEditor.prototype.getValue = function () {
        return this.eText.value;
    };
    DateCellEditor.prototype.onBtPush = function () {
        var ePopup = utils_1.Utils.loadTemplate('<div style="position: absolute; border: 1px solid darkgreen; background: lightcyan">' +
            '<div>This is the popup</div>' +
            '<div><input/></div>' +
            '<div>Under the input</div>' +
            '</div>');
        this.popupService.addAsModalPopup(ePopup, true, function () {
            console.log('popup was closed');
        });
        this.popupService.positionPopupUnderComponent({
            eventSource: this.getGui(),
            ePopup: ePopup
        });
        var eText = ePopup.querySelector('input');
        eText.focus();
    };
    DateCellEditor.prototype.afterGuiAttached = function () {
        this.eText.focus();
    };
    DateCellEditor.TEMPLATE = '<span>' +
        '<input type="text" style="width: 80%"/>' +
        '<button style="width: 20%">+</button>' +
        '</span>';
    __decorate([
        context_1.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], DateCellEditor.prototype, "popupService", void 0);
    return DateCellEditor;
})(component_1.Component);
exports.DateCellEditor = DateCellEditor;

},{"../../context/context":87,"../../utils":156,"../../widgets/component":158,"../../widgets/popupService":161}],130:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var component_1 = require("../../widgets/component");
var PopupEditorWrapper = (function (_super) {
    __extends(PopupEditorWrapper, _super);
    function PopupEditorWrapper(cellEditor) {
        _super.call(this, '<div class="ag-popup-editor"/>');
        this.getGuiCalledOnChild = false;
        this.cellEditor = cellEditor;
        this.addDestroyFunc(function () { return cellEditor.destroy(); });
        this.addDestroyableEventListener(
        // this needs to be 'super' and not 'this' as if we call 'this',
        // it ends up called 'getGui()' on the child before 'init' was called,
        // which is not good
        _super.prototype.getGui.call(this), 'keydown', this.onKeyDown.bind(this));
    }
    PopupEditorWrapper.prototype.onKeyDown = function (event) {
        this.params.onKeyDown(event);
    };
    PopupEditorWrapper.prototype.getGui = function () {
        // we call getGui() on child here (rather than in the constructor)
        // as we should wait for 'init' to be called on child first.
        if (!this.getGuiCalledOnChild) {
            this.appendChild(this.cellEditor.getGui());
            this.getGuiCalledOnChild = true;
        }
        return _super.prototype.getGui.call(this);
    };
    PopupEditorWrapper.prototype.init = function (params) {
        this.params = params;
        if (this.cellEditor.init) {
            this.cellEditor.init(params);
        }
    };
    PopupEditorWrapper.prototype.afterGuiAttached = function () {
        if (this.cellEditor.afterGuiAttached) {
            this.cellEditor.afterGuiAttached();
        }
    };
    PopupEditorWrapper.prototype.getValue = function () {
        return this.cellEditor.getValue();
    };
    PopupEditorWrapper.prototype.isPopup = function () {
        return true;
    };
    return PopupEditorWrapper;
})(component_1.Component);
exports.PopupEditorWrapper = PopupEditorWrapper;

},{"../../widgets/component":158}],131:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var selectCellEditor_1 = require("./selectCellEditor");
var PopupSelectCellEditor = (function (_super) {
    __extends(PopupSelectCellEditor, _super);
    function PopupSelectCellEditor() {
        _super.apply(this, arguments);
    }
    PopupSelectCellEditor.prototype.isPopup = function () {
        return true;
    };
    return PopupSelectCellEditor;
})(selectCellEditor_1.SelectCellEditor);
exports.PopupSelectCellEditor = PopupSelectCellEditor;

},{"./selectCellEditor":133}],132:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var textCellEditor_1 = require("./textCellEditor");
var PopupTextCellEditor = (function (_super) {
    __extends(PopupTextCellEditor, _super);
    function PopupTextCellEditor() {
        _super.apply(this, arguments);
    }
    PopupTextCellEditor.prototype.isPopup = function () {
        return true;
    };
    return PopupTextCellEditor;
})(textCellEditor_1.TextCellEditor);
exports.PopupTextCellEditor = PopupTextCellEditor;

},{"./textCellEditor":134}],133:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var component_1 = require("../../widgets/component");
var utils_1 = require('../../utils');
var SelectCellEditor = (function (_super) {
    __extends(SelectCellEditor, _super);
    function SelectCellEditor() {
        _super.call(this, '<div class="ag-cell-edit-input"><select class="ag-cell-edit-input"/></div>');
    }
    SelectCellEditor.prototype.init = function (params) {
        var eSelect = this.getGui().querySelector('select');
        if (utils_1.Utils.missing(params.values)) {
            console.log('ag-Grid: no values found for select cellEditor');
            return;
        }
        params.values.forEach(function (value) {
            var option = document.createElement('option');
            option.value = value;
            option.text = value;
            if (params.value === value) {
                option.selected = true;
            }
            eSelect.appendChild(option);
        });
        this.addDestroyableEventListener(eSelect, 'change', function () { return params.stopEditing(); });
    };
    SelectCellEditor.prototype.afterGuiAttached = function () {
        var eSelect = this.getGui().querySelector('select');
        eSelect.focus();
    };
    SelectCellEditor.prototype.getValue = function () {
        var eSelect = this.getGui().querySelector('select');
        return eSelect.value;
    };
    return SelectCellEditor;
})(component_1.Component);
exports.SelectCellEditor = SelectCellEditor;

},{"../../utils":156,"../../widgets/component":158}],134:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var constants_1 = require("../../constants");
var component_1 = require("../../widgets/component");
var utils_1 = require('../../utils');
var TextCellEditor = (function (_super) {
    __extends(TextCellEditor, _super);
    function TextCellEditor() {
        _super.call(this, TextCellEditor.TEMPLATE);
    }
    TextCellEditor.prototype.init = function (params) {
        var eInput = this.getGui();
        var startValue;
        var keyPressBackspaceOrDelete = params.keyPress === constants_1.Constants.KEY_BACKSPACE
            || params.keyPress === constants_1.Constants.KEY_DELETE;
        if (keyPressBackspaceOrDelete) {
            startValue = '';
        }
        else if (params.charPress) {
            startValue = params.charPress;
        }
        else {
            startValue = params.value;
            if (params.keyPress === constants_1.Constants.KEY_F2) {
                this.putCursorAtEndOnFocus = true;
            }
            else {
                this.highlightAllOnFocus = true;
            }
        }
        if (utils_1.Utils.exists(startValue)) {
            eInput.value = startValue;
        }
        this.addDestroyableEventListener(eInput, 'keydown', function (event) {
            var isNavigationKey = event.keyCode === constants_1.Constants.KEY_LEFT || event.keyCode === constants_1.Constants.KEY_RIGHT;
            if (isNavigationKey) {
                event.stopPropagation();
            }
        });
    };
    TextCellEditor.prototype.afterGuiAttached = function () {
        var eInput = this.getGui();
        eInput.focus();
        if (this.highlightAllOnFocus) {
            eInput.select();
        }
        else {
            // when we started editing, we want the carot at the end, not the start.
            // this comes into play in two scenarios: a) when user hits F2 and b)
            // when user hits a printable character, then on IE (and only IE) the carot
            // was placed after the first character, thus 'apply' would end up as 'pplea'
            var length = eInput.value ? eInput.value.length : 0;
            if (length > 0) {
                eInput.setSelectionRange(length, length);
            }
        }
    };
    TextCellEditor.prototype.getValue = function () {
        var eInput = this.getGui();
        return eInput.value;
    };
    TextCellEditor.TEMPLATE = '<input class="ag-cell-edit-input" type="text"/>';
    return TextCellEditor;
})(component_1.Component);
exports.TextCellEditor = TextCellEditor;

},{"../../constants":86,"../../utils":156,"../../widgets/component":158}],135:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var utils_1 = require('../utils');
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var eventService_1 = require("../eventService");
var expressionService_1 = require("../expressionService");
var animateSlideCellRenderer_1 = require("./cellRenderers/animateSlideCellRenderer");
var animateShowChangeCellRenderer_1 = require("./cellRenderers/animateShowChangeCellRenderer");
var groupCellRenderer_1 = require("./cellRenderers/groupCellRenderer");
var CellRendererFactory = (function () {
    function CellRendererFactory() {
        this.cellRendererMap = {};
    }
    CellRendererFactory.prototype.init = function () {
        this.cellRendererMap[CellRendererFactory.ANIMATE_SLIDE] = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
        this.cellRendererMap[CellRendererFactory.ANIMATE_SHOW_CHANGE] = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
        this.cellRendererMap[CellRendererFactory.GROUP] = groupCellRenderer_1.GroupCellRenderer;
        // this.registerRenderersFromGridOptions();
    };
    // private registerRenderersFromGridOptions(): void {
    //     var userProvidedCellRenderers = this.gridOptionsWrapper.getCellRenderers();
    //     _.iterateObject(userProvidedCellRenderers, (key: string, cellRenderer: {new(): ICellRenderer} | ICellRendererFunc)=> {
    //         this.addCellRenderer(key, cellRenderer);
    //     });
    // }
    CellRendererFactory.prototype.addCellRenderer = function (key, cellRenderer) {
        this.cellRendererMap[key] = cellRenderer;
    };
    CellRendererFactory.prototype.getCellRenderer = function (key) {
        var result = this.cellRendererMap[key];
        if (utils_1.Utils.missing(result)) {
            console.warn('ag-Grid: unable to find cellRenderer for key ' + key);
            return null;
        }
        return result;
    };
    CellRendererFactory.ANIMATE_SLIDE = 'animateSlide';
    CellRendererFactory.ANIMATE_SHOW_CHANGE = 'animateShowChange';
    CellRendererFactory.GROUP = 'group';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], CellRendererFactory.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'), 
        __metadata('design:type', expressionService_1.ExpressionService)
    ], CellRendererFactory.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], CellRendererFactory.prototype, "eventService", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], CellRendererFactory.prototype, "init", null);
    CellRendererFactory = __decorate([
        context_1.Bean('cellRendererFactory'), 
        __metadata('design:paramtypes', [])
    ], CellRendererFactory);
    return CellRendererFactory;
})();
exports.CellRendererFactory = CellRendererFactory;

},{"../context/context":87,"../eventService":98,"../expressionService":100,"../gridOptionsWrapper":109,"../utils":156,"./cellRenderers/animateShowChangeCellRenderer":137,"./cellRenderers/animateSlideCellRenderer":138,"./cellRenderers/groupCellRenderer":139}],136:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var context_1 = require("../context/context");
var cellRendererFactory_1 = require("./cellRendererFactory");
/** Class to use a cellRenderer. */
var CellRendererService = (function () {
    function CellRendererService() {
    }
    /** Uses a cellRenderer, and returns the cellRenderer object if it is a class implementing ICellRenderer.
     * @cellRendererKey: The cellRenderer to use. Can be: a) a class that we call 'new' on b) a function we call
     *                   or c) a string that we use to look up the cellRenderer.
     * @params: The params to pass to the cell renderer if it's a function or a class.
     * @eTarget: The DOM element we will put the results of the html element into *
     * @return: If options a, it returns the created class instance */
    CellRendererService.prototype.useCellRenderer = function (cellRendererKey, eTarget, params) {
        var cellRenderer = this.lookUpCellRenderer(cellRendererKey);
        if (utils_1.Utils.missing(cellRenderer)) {
            // this is a bug in users config, they specified a cellRenderer that doesn't exist,
            // the factory already printed to console, so here we just skip
            return;
        }
        var resultFromRenderer;
        var iCellRendererInstance = null;
        this.checkForDeprecatedItems(cellRenderer);
        // we check if the class has the 'getGui' method to know if it's a component
        var rendererIsAComponent = this.doesImplementICellRenderer(cellRenderer);
        // if it's a component, we create and initialise it
        if (rendererIsAComponent) {
            var CellRendererClass = cellRenderer;
            iCellRendererInstance = new CellRendererClass();
            this.context.wireBean(iCellRendererInstance);
            if (iCellRendererInstance.init) {
                iCellRendererInstance.init(params);
            }
            resultFromRenderer = iCellRendererInstance.getGui();
        }
        else {
            // otherwise it's a function, so we just use it
            var cellRendererFunc = cellRenderer;
            resultFromRenderer = cellRendererFunc(params);
        }
        if (resultFromRenderer === null || resultFromRenderer === '') {
            return;
        }
        if (utils_1.Utils.isNodeOrElement(resultFromRenderer)) {
            // a dom node or element was returned, so add child
            eTarget.appendChild(resultFromRenderer);
        }
        else {
            // otherwise assume it was html, so just insert
            eTarget.innerHTML = resultFromRenderer;
        }
        return iCellRendererInstance;
    };
    CellRendererService.prototype.checkForDeprecatedItems = function (cellRenderer) {
        if (cellRenderer && cellRenderer.renderer) {
            console.warn('ag-grid: colDef.cellRenderer should not be an object, it should be a string, function or class. this ' +
                'changed in v4.1.x, please check the documentation on Cell Rendering, or if you are doing grouping, look at the grouping examples.');
        }
    };
    CellRendererService.prototype.doesImplementICellRenderer = function (cellRenderer) {
        // see if the class has a prototype that defines a getGui method. this is very rough,
        // but javascript doesn't have types, so is the only way!
        return cellRenderer.prototype && 'getGui' in cellRenderer.prototype;
    };
    CellRendererService.prototype.lookUpCellRenderer = function (cellRendererKey) {
        if (typeof cellRendererKey === 'string') {
            return this.cellRendererFactory.getCellRenderer(cellRendererKey);
        }
        else {
            return cellRendererKey;
        }
    };
    __decorate([
        context_1.Autowired('cellRendererFactory'), 
        __metadata('design:type', cellRendererFactory_1.CellRendererFactory)
    ], CellRendererService.prototype, "cellRendererFactory", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], CellRendererService.prototype, "context", void 0);
    CellRendererService = __decorate([
        context_1.Bean('cellRendererService'), 
        __metadata('design:paramtypes', [])
    ], CellRendererService);
    return CellRendererService;
})();
exports.CellRendererService = CellRendererService;

},{"../context/context":87,"../utils":156,"./cellRendererFactory":135}],137:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utils_1 = require("../../utils");
var component_1 = require("../../widgets/component");
var ARROW_UP = '&#65514;';
var ARROW_DOWN = '&#65516;';
var AnimateShowChangeCellRenderer = (function (_super) {
    __extends(AnimateShowChangeCellRenderer, _super);
    function AnimateShowChangeCellRenderer() {
        _super.call(this, AnimateShowChangeCellRenderer.TEMPLATE);
        this.refreshCount = 0;
    }
    AnimateShowChangeCellRenderer.prototype.init = function (params) {
        this.params = params;
        this.eValue = this.queryForHtmlElement('.ag-value-change-value');
        this.eDelta = this.queryForHtmlElement('.ag-value-change-delta');
        this.refresh(params);
    };
    AnimateShowChangeCellRenderer.prototype.showDelta = function (params, delta) {
        var absDelta = Math.abs(delta);
        var valueFormatted = params.formatValue(absDelta);
        var valueToUse = utils_1.Utils.exists(valueFormatted) ? valueFormatted : absDelta;
        var deltaUp = (delta >= 0);
        if (deltaUp) {
            this.eDelta.innerHTML = ARROW_UP + valueToUse;
        }
        else {
            // because negative, use ABS to remove sign
            this.eDelta.innerHTML = ARROW_DOWN + valueToUse;
        }
        // class makes it green (in ag-fresh)
        utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-up', deltaUp);
        // class makes it red (in ag-fresh)
        utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-down', !deltaUp);
    };
    AnimateShowChangeCellRenderer.prototype.setTimerToRemoveDelta = function () {
        var _this = this;
        // the refreshCount makes sure that if the value updates again while
        // the below timer is waiting, then the below timer will realise it
        // is not the most recent and will not try to remove the delta value.
        this.refreshCount++;
        var refreshCountCopy = this.refreshCount;
        setTimeout(function () {
            if (refreshCountCopy === _this.refreshCount) {
                _this.hideDeltaValue();
            }
        }, 2000);
    };
    AnimateShowChangeCellRenderer.prototype.hideDeltaValue = function () {
        utils_1.Utils.removeCssClass(this.eValue, 'ag-value-change-value-highlight');
        this.eDelta.innerHTML = '';
    };
    AnimateShowChangeCellRenderer.prototype.refresh = function (params) {
        var value = params.value;
        if (value === this.lastValue) {
            return;
        }
        if (utils_1.Utils.exists(params.valueFormatted)) {
            this.eValue.innerHTML = params.valueFormatted;
        }
        else if (utils_1.Utils.exists(params.value)) {
            this.eValue.innerHTML = value;
        }
        else {
            this.eValue.innerHTML = '';
        }
        if (typeof value === 'number' && typeof this.lastValue === 'number') {
            var delta = value - this.lastValue;
            this.showDelta(params, delta);
        }
        // highlight the current value, but only if it's not new, otherwise it
        // would get highlighted first time the value is shown
        if (this.lastValue) {
            utils_1.Utils.addCssClass(this.eValue, 'ag-value-change-value-highlight');
        }
        this.setTimerToRemoveDelta();
        this.lastValue = value;
    };
    AnimateShowChangeCellRenderer.TEMPLATE = '<span>' +
        '<span class="ag-value-change-delta"></span>' +
        '<span class="ag-value-change-value"></span>' +
        '</span>';
    return AnimateShowChangeCellRenderer;
})(component_1.Component);
exports.AnimateShowChangeCellRenderer = AnimateShowChangeCellRenderer;

},{"../../utils":156,"../../widgets/component":158}],138:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utils_1 = require("../../utils");
var component_1 = require("../../widgets/component");
var AnimateSlideCellRenderer = (function (_super) {
    __extends(AnimateSlideCellRenderer, _super);
    function AnimateSlideCellRenderer() {
        _super.call(this, AnimateSlideCellRenderer.TEMPLATE);
        this.refreshCount = 0;
        this.eCurrent = this.queryForHtmlElement('.ag-value-slide-current');
    }
    AnimateSlideCellRenderer.prototype.init = function (params) {
        this.params = params;
        this.refresh(params);
    };
    AnimateSlideCellRenderer.prototype.addSlideAnimation = function () {
        var _this = this;
        this.refreshCount++;
        // below we keep checking this, and stop working on the animation
        // if it no longer matches - this means another animation has started
        // and this one is stale.
        var refreshCountCopy = this.refreshCount;
        // if old animation, remove it
        if (this.ePrevious) {
            this.getGui().removeChild(this.ePrevious);
        }
        this.ePrevious = utils_1.Utils.loadTemplate('<span class="ag-value-slide-previous ag-fade-out"></span>');
        this.ePrevious.innerHTML = this.eCurrent.innerHTML;
        this.getGui().insertBefore(this.ePrevious, this.eCurrent);
        // having timeout of 0 allows use to skip to the next css turn,
        // so we know the previous css classes have been applied. so the
        // complex set of setTimeout below creates the animation
        setTimeout(function () {
            if (refreshCountCopy !== _this.refreshCount) {
                return;
            }
            utils_1.Utils.addCssClass(_this.ePrevious, 'ag-fade-out-end');
        }, 50);
        setTimeout(function () {
            if (refreshCountCopy !== _this.refreshCount) {
                return;
            }
            _this.getGui().removeChild(_this.ePrevious);
            _this.ePrevious = null;
        }, 3000);
    };
    AnimateSlideCellRenderer.prototype.refresh = function (params) {
        var value = params.value;
        if (utils_1.Utils.missing(value)) {
            value = '';
        }
        if (value === this.lastValue) {
            return;
        }
        this.addSlideAnimation();
        this.lastValue = value;
        if (utils_1.Utils.exists(params.valueFormatted)) {
            this.eCurrent.innerHTML = params.valueFormatted;
        }
        else if (utils_1.Utils.exists(params.value)) {
            this.eCurrent.innerHTML = value;
        }
        else {
            this.eCurrent.innerHTML = '';
        }
    };
    AnimateSlideCellRenderer.TEMPLATE = '<span>' +
        '<span class="ag-value-slide-current"></span>' +
        '</span>';
    return AnimateSlideCellRenderer;
})(component_1.Component);
exports.AnimateSlideCellRenderer = AnimateSlideCellRenderer;

},{"../../utils":156,"../../widgets/component":158}],139:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var svgFactory_1 = require("../../svgFactory");
var gridOptionsWrapper_1 = require("../../gridOptionsWrapper");
var expressionService_1 = require("../../expressionService");
var eventService_1 = require("../../eventService");
var constants_1 = require("../../constants");
var utils_1 = require("../../utils");
var events_1 = require("../../events");
var context_1 = require("../../context/context");
var component_1 = require("../../widgets/component");
var cellRendererService_1 = require("../cellRendererService");
var valueFormatterService_1 = require("../valueFormatterService");
var checkboxSelectionComponent_1 = require("../checkboxSelectionComponent");
var columnController_1 = require("../../columnController/columnController");
var svgFactory = svgFactory_1.SvgFactory.getInstance();
var GroupCellRenderer = (function (_super) {
    __extends(GroupCellRenderer, _super);
    function GroupCellRenderer() {
        _super.call(this, GroupCellRenderer.TEMPLATE);
        this.eExpanded = this.queryForHtmlElement('.ag-group-expanded');
        this.eContracted = this.queryForHtmlElement('.ag-group-contracted');
        this.eCheckbox = this.queryForHtmlElement('.ag-group-checkbox');
        this.eValue = this.queryForHtmlElement('.ag-group-value');
        this.eChildCount = this.queryForHtmlElement('.ag-group-child-count');
    }
    GroupCellRenderer.prototype.init = function (params) {
        this.rowNode = params.node;
        this.rowIndex = params.rowIndex;
        this.gridApi = params.api;
        this.addExpandAndContract(params.eGridCell);
        this.addCheckboxIfNeeded(params);
        this.addValueElement(params);
        this.addPadding(params);
    };
    GroupCellRenderer.prototype.addPadding = function (params) {
        // only do this if an indent - as this overwrites the padding that
        // the theme set, which will make things look 'not aligned' for the
        // first group level.
        var node = this.rowNode;
        var suppressPadding = params.suppressPadding;
        if (!suppressPadding && (node.footer || node.level > 0)) {
            var paddingFactor;
            if (params.colDef && params.padding >= 0) {
                paddingFactor = params.padding;
            }
            else {
                paddingFactor = 10;
            }
            var paddingPx = node.level * paddingFactor;
            var reducedLeafNode = this.columnController.isReduce() && this.rowNode.leafGroup;
            if (node.footer) {
                paddingPx += 15;
            }
            else if (!node.group || reducedLeafNode) {
                paddingPx += 10;
            }
            this.getGui().style.paddingLeft = paddingPx + 'px';
        }
    };
    GroupCellRenderer.prototype.addValueElement = function (params) {
        if (params.innerRenderer) {
            this.createFromInnerRenderer(params);
        }
        else if (this.rowNode.footer) {
            this.createFooterCell(params);
        }
        else if (this.rowNode.group) {
            this.createGroupCell(params);
            this.addChildCount(params);
        }
        else {
            this.createLeafCell(params);
        }
    };
    GroupCellRenderer.prototype.createFromInnerRenderer = function (params) {
        this.cellRendererService.useCellRenderer(params.innerRenderer, this.eValue, params);
    };
    GroupCellRenderer.prototype.createFooterCell = function (params) {
        var footerValue;
        var groupName = this.getGroupName(params);
        if (params.footerValueGetter) {
            var footerValueGetter = params.footerValueGetter;
            // params is same as we were given, except we set the value as the item to display
            var paramsClone = utils_1.Utils.cloneObject(params);
            paramsClone.value = groupName;
            if (typeof footerValueGetter === 'function') {
                footerValue = footerValueGetter(paramsClone);
            }
            else if (typeof footerValueGetter === 'string') {
                footerValue = this.expressionService.evaluate(footerValueGetter, paramsClone);
            }
            else {
                console.warn('ag-Grid: footerValueGetter should be either a function or a string (expression)');
            }
        }
        else {
            footerValue = 'Total ' + groupName;
        }
        this.eValue.innerHTML = footerValue;
    };
    GroupCellRenderer.prototype.createGroupCell = function (params) {
        // pull out the column that the grouping is on
        var rowGroupColumns = params.columnApi.getRowGroupColumns();
        // if we are using in memory grid grouping, then we try to look up the column that
        // we did the grouping on. however if it is not possible (happens when user provides
        // the data already grouped) then we just the current col, ie use cellrenderer of current col
        var columnOfGroupedCol = rowGroupColumns[params.node.level];
        if (utils_1.Utils.missing(columnOfGroupedCol)) {
            columnOfGroupedCol = params.column;
        }
        var colDefOfGroupedCol = columnOfGroupedCol.getColDef();
        var groupName = this.getGroupName(params);
        var valueFormatted = this.valueFormatterService.formatValue(columnOfGroupedCol, params.node, params.scope, this.rowIndex, groupName);
        // reuse the params but change the value
        if (colDefOfGroupedCol && typeof colDefOfGroupedCol.cellRenderer === 'function') {
            // reuse the params but change the value
            params.value = groupName;
            params.valueFormatted = valueFormatted;
            // because we are talking about the different column to the original, any user provided params
            // are for the wrong column, so need to copy them in again.
            if (colDefOfGroupedCol.cellRendererParams) {
                utils_1.Utils.assign(params, colDefOfGroupedCol.cellRendererParams);
            }
            this.cellRendererService.useCellRenderer(colDefOfGroupedCol.cellRenderer, this.eValue, params);
        }
        else {
            var valueToRender = utils_1.Utils.exists(valueFormatted) ? valueFormatted : groupName;
            if (utils_1.Utils.exists(valueToRender) && valueToRender !== '') {
                this.eValue.appendChild(document.createTextNode(valueToRender));
            }
        }
    };
    GroupCellRenderer.prototype.addChildCount = function (params) {
        // only include the child count if it's included, eg if user doing custom aggregation,
        // then this could be left out, or set to -1, ie no child count
        var suppressCount = params.suppressCount;
        if (!suppressCount && params.node.allChildrenCount >= 0) {
            this.eChildCount.innerHTML = "(" + params.node.allChildrenCount + ")";
        }
    };
    GroupCellRenderer.prototype.getGroupName = function (params) {
        if (params.keyMap && typeof params.keyMap === 'object') {
            var valueFromMap = params.keyMap[params.node.key];
            if (valueFromMap) {
                return valueFromMap;
            }
            else {
                return params.node.key;
            }
        }
        else {
            return params.node.key;
        }
    };
    GroupCellRenderer.prototype.createLeafCell = function (params) {
        if (utils_1.Utils.exists(params.value)) {
            this.eValue.innerHTML = params.value;
        }
    };
    GroupCellRenderer.prototype.addCheckboxIfNeeded = function (params) {
        var checkboxNeeded = params.checkbox && !this.rowNode.footer && !this.rowNode.floating;
        if (checkboxNeeded) {
            var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
            this.context.wireBean(cbSelectionComponent);
            cbSelectionComponent.init({ rowNode: this.rowNode });
            this.eCheckbox.appendChild(cbSelectionComponent.getGui());
            this.addDestroyFunc(function () { return cbSelectionComponent.destroy(); });
        }
    };
    GroupCellRenderer.prototype.addExpandAndContract = function (eGroupCell) {
        var eExpandedIcon = utils_1.Utils.createIconNoSpan('groupExpanded', this.gridOptionsWrapper, null, svgFactory.createGroupContractedIcon);
        var eContractedIcon = utils_1.Utils.createIconNoSpan('groupContracted', this.gridOptionsWrapper, null, svgFactory.createGroupExpandedIcon);
        this.eExpanded.appendChild(eExpandedIcon);
        this.eContracted.appendChild(eContractedIcon);
        this.addDestroyableEventListener(this.eExpanded, 'click', this.onExpandOrContract.bind(this));
        this.addDestroyableEventListener(this.eContracted, 'click', this.onExpandOrContract.bind(this));
        this.addDestroyableEventListener(eGroupCell, 'dblclick', this.onExpandOrContract.bind(this));
        // expand / contract as the user hits enter
        this.addDestroyableEventListener(eGroupCell, 'keydown', this.onKeyDown.bind(this));
        this.showExpandAndContractIcons();
    };
    GroupCellRenderer.prototype.onKeyDown = function (event) {
        if (utils_1.Utils.isKeyPressed(event, constants_1.Constants.KEY_ENTER)) {
            this.onExpandOrContract();
            event.preventDefault();
        }
    };
    GroupCellRenderer.prototype.onExpandOrContract = function () {
        this.rowNode.expanded = !this.rowNode.expanded;
        var refreshIndex = this.getRefreshFromIndex();
        this.gridApi.onGroupExpandedOrCollapsed(refreshIndex);
        this.showExpandAndContractIcons();
        var event = { node: this.rowNode };
        this.eventService.dispatchEvent(events_1.Events.EVENT_ROW_GROUP_OPENED, event);
    };
    GroupCellRenderer.prototype.showExpandAndContractIcons = function () {
        var reducedLeafNode = this.columnController.isReduce() && this.rowNode.leafGroup;
        var expandable = this.rowNode.group && !this.rowNode.footer && !reducedLeafNode;
        if (expandable) {
            // if expandable, show one based on expand state
            utils_1.Utils.setVisible(this.eExpanded, this.rowNode.expanded);
            utils_1.Utils.setVisible(this.eContracted, !this.rowNode.expanded);
        }
        else {
            // it not expandable, show neither
            utils_1.Utils.setVisible(this.eExpanded, false);
            utils_1.Utils.setVisible(this.eContracted, false);
        }
    };
    // if we are showing footers, then opening / closing the group also changes the group
    // row, as the 'summaries' move to and from the header and footer. if not using footers,
    // then we only need to refresh from this row down.
    GroupCellRenderer.prototype.getRefreshFromIndex = function () {
        if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
            return this.rowIndex;
        }
        else {
            return this.rowIndex + 1;
        }
    };
    GroupCellRenderer.TEMPLATE = '<span>' +
        '<span class="ag-group-expanded"></span>' +
        '<span class="ag-group-contracted"></span>' +
        '<span class="ag-group-checkbox"></span>' +
        '<span class="ag-group-value"></span>' +
        '<span class="ag-group-child-count"></span>' +
        '</span>';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], GroupCellRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'), 
        __metadata('design:type', expressionService_1.ExpressionService)
    ], GroupCellRenderer.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], GroupCellRenderer.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('cellRendererService'), 
        __metadata('design:type', cellRendererService_1.CellRendererService)
    ], GroupCellRenderer.prototype, "cellRendererService", void 0);
    __decorate([
        context_1.Autowired('valueFormatterService'), 
        __metadata('design:type', valueFormatterService_1.ValueFormatterService)
    ], GroupCellRenderer.prototype, "valueFormatterService", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], GroupCellRenderer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], GroupCellRenderer.prototype, "columnController", void 0);
    return GroupCellRenderer;
})(component_1.Component);
exports.GroupCellRenderer = GroupCellRenderer;

},{"../../columnController/columnController":77,"../../constants":86,"../../context/context":87,"../../eventService":98,"../../events":99,"../../expressionService":100,"../../gridOptionsWrapper":109,"../../svgFactory":154,"../../utils":156,"../../widgets/component":158,"../cellRendererService":136,"../checkboxSelectionComponent":140,"../valueFormatterService":144}],140:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var component_1 = require("../widgets/component");
var rowNode_1 = require("../entities/rowNode");
var utils_1 = require('../utils');
var context_1 = require("../context/context");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var svgFactory_1 = require("../svgFactory");
var svgFactory = svgFactory_1.SvgFactory.getInstance();
var CheckboxSelectionComponent = (function (_super) {
    __extends(CheckboxSelectionComponent, _super);
    function CheckboxSelectionComponent() {
        _super.call(this, "<span class=\"ag-selection-checkbox\"/>");
    }
    CheckboxSelectionComponent.prototype.createAndAddIcons = function () {
        this.eCheckedIcon = utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedIcon);
        this.eUncheckedIcon = utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedIcon);
        this.eIndeterminateIcon = utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateIcon);
        var eGui = this.getGui();
        eGui.appendChild(this.eCheckedIcon);
        eGui.appendChild(this.eUncheckedIcon);
        eGui.appendChild(this.eIndeterminateIcon);
    };
    CheckboxSelectionComponent.prototype.onSelectionChanged = function () {
        var state = this.rowNode.isSelected();
        utils_1.Utils.setVisible(this.eCheckedIcon, state === true);
        utils_1.Utils.setVisible(this.eUncheckedIcon, state === false);
        utils_1.Utils.setVisible(this.eIndeterminateIcon, typeof state !== 'boolean');
    };
    CheckboxSelectionComponent.prototype.onCheckedClicked = function () {
        this.rowNode.setSelected(false);
    };
    CheckboxSelectionComponent.prototype.onUncheckedClicked = function (event) {
        this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey });
    };
    CheckboxSelectionComponent.prototype.onIndeterminateClicked = function (event) {
        this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey });
    };
    CheckboxSelectionComponent.prototype.init = function (params) {
        this.createAndAddIcons();
        this.rowNode = params.rowNode;
        this.onSelectionChanged();
        // we don't want the row clicked event to fire when selecting the checkbox, otherwise the row
        // would possibly get selected twice
        this.addGuiEventListener('click', function (event) { return event.stopPropagation(); });
        // likewise we don't want double click on this icon to open a group
        this.addGuiEventListener('dblclick', function (event) { return event.stopPropagation(); });
        this.addDestroyableEventListener(this.eCheckedIcon, 'click', this.onCheckedClicked.bind(this));
        this.addDestroyableEventListener(this.eUncheckedIcon, 'click', this.onUncheckedClicked.bind(this));
        this.addDestroyableEventListener(this.eIndeterminateIcon, 'click', this.onIndeterminateClicked.bind(this));
        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this));
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], CheckboxSelectionComponent.prototype, "gridOptionsWrapper", void 0);
    return CheckboxSelectionComponent;
})(component_1.Component);
exports.CheckboxSelectionComponent = CheckboxSelectionComponent;

},{"../context/context":87,"../entities/rowNode":97,"../gridOptionsWrapper":109,"../svgFactory":154,"../utils":156,"../widgets/component":158}],141:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var column_1 = require("../entities/column");
var rowNode_1 = require("../entities/rowNode");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var expressionService_1 = require("../expressionService");
var rowRenderer_1 = require("./rowRenderer");
var templateService_1 = require("../templateService");
var columnController_1 = require("../columnController/columnController");
var valueService_1 = require("../valueService");
var eventService_1 = require("../eventService");
var constants_1 = require("../constants");
var events_1 = require("../events");
var context_1 = require("../context/context");
var gridApi_1 = require("../gridApi");
var focusedCellController_1 = require("../focusedCellController");
var gridCell_1 = require("../entities/gridCell");
var focusService_1 = require("../misc/focusService");
var cellEditorFactory_1 = require("./cellEditorFactory");
var component_1 = require("../widgets/component");
var popupService_1 = require("../widgets/popupService");
var cellRendererFactory_1 = require("./cellRendererFactory");
var cellRendererService_1 = require("./cellRendererService");
var valueFormatterService_1 = require("./valueFormatterService");
var checkboxSelectionComponent_1 = require("./checkboxSelectionComponent");
var RenderedCell = (function (_super) {
    __extends(RenderedCell, _super);
    function RenderedCell(column, node, rowIndex, scope, renderedRow) {
        _super.call(this, '<div/>');
        this.firstRightPinned = false;
        this.lastLeftPinned = false;
        // because we reference eGridCell everywhere in this class,
        // we keep a local reference
        this.eGridCell = this.getGui();
        this.column = column;
        this.node = node;
        this.rowIndex = rowIndex;
        this.scope = scope;
        this.renderedRow = renderedRow;
        this.gridCell = new gridCell_1.GridCell(rowIndex, node.floating, column);
    }
    RenderedCell.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.cellEditor && this.cellEditor.destroy) {
            this.cellEditor.destroy();
        }
        if (this.cellRenderer && this.cellRenderer.destroy) {
            this.cellRenderer.destroy();
        }
    };
    RenderedCell.prototype.setPinnedClasses = function () {
        var _this = this;
        var firstPinnedChangedListener = function () {
            if (_this.firstRightPinned !== _this.column.isFirstRightPinned()) {
                _this.firstRightPinned = _this.column.isFirstRightPinned();
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-first-right-pinned', _this.firstRightPinned);
            }
            if (_this.lastLeftPinned !== _this.column.isLastLeftPinned()) {
                _this.lastLeftPinned = _this.column.isLastLeftPinned();
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-last-left-pinned', _this.lastLeftPinned);
            }
        };
        this.column.addEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstPinnedChangedListener);
        this.column.addEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, firstPinnedChangedListener);
        this.addDestroyFunc(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstPinnedChangedListener);
            _this.column.removeEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, firstPinnedChangedListener);
        });
        firstPinnedChangedListener();
    };
    RenderedCell.prototype.getParentRow = function () {
        return this.eParentRow;
    };
    RenderedCell.prototype.setParentRow = function (eParentRow) {
        this.eParentRow = eParentRow;
    };
    RenderedCell.prototype.calculateCheckboxSelection = function () {
        // never allow selection on floating rows
        if (this.node.floating) {
            return false;
        }
        // if boolean set, then just use it
        var colDef = this.column.getColDef();
        if (typeof colDef.checkboxSelection === 'boolean') {
            return colDef.checkboxSelection;
        }
        // if function, then call the function to find out. we first check colDef for
        // a function, and if missing then check gridOptions, so colDef has precedence
        var selectionFunc;
        if (typeof colDef.checkboxSelection === 'function') {
            selectionFunc = colDef.checkboxSelection;
        }
        if (!selectionFunc && this.gridOptionsWrapper.getCheckboxSelection()) {
            selectionFunc = this.gridOptionsWrapper.getCheckboxSelection();
        }
        if (selectionFunc) {
            var params = this.createParams();
            return selectionFunc(params);
        }
        return false;
    };
    RenderedCell.prototype.getColumn = function () {
        return this.column;
    };
    RenderedCell.prototype.getValue = function () {
        var data = this.getDataForRow();
        return this.valueService.getValueUsingSpecificData(this.column, data, this.node);
    };
    RenderedCell.prototype.getDataForRow = function () {
        if (this.node.footer) {
            // if footer, we always show the data
            return this.node.data;
        }
        else if (this.node.group) {
            // if header and header is expanded, we show data in footer only
            var footersEnabled = this.gridOptionsWrapper.isGroupIncludeFooter();
            var suppressHideHeader = this.gridOptionsWrapper.isGroupSuppressBlankHeader();
            if (this.node.expanded && footersEnabled && !suppressHideHeader) {
                return undefined;
            }
            else {
                return this.node.data;
            }
        }
        else {
            // otherwise it's a normal node, just return data as normal
            return this.node.data;
        }
    };
    RenderedCell.prototype.setLeftOnCell = function () {
        var _this = this;
        var leftChangedListener = function () {
            var newLeft = _this.column.getLeft();
            if (utils_1.Utils.exists(newLeft)) {
                _this.eGridCell.style.left = _this.column.getLeft() + 'px';
            }
            else {
                _this.eGridCell.style.left = '';
            }
        };
        this.column.addEventListener(column_1.Column.EVENT_LEFT_CHANGED, leftChangedListener);
        this.addDestroyFunc(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_LEFT_CHANGED, leftChangedListener);
        });
        leftChangedListener();
    };
    RenderedCell.prototype.addRangeSelectedListener = function () {
        var _this = this;
        if (!this.rangeController) {
            return;
        }
        var rangeCountLastTime = 0;
        var rangeSelectedListener = function () {
            var rangeCount = _this.rangeController.getCellRangeCount(_this.gridCell);
            if (rangeCountLastTime !== rangeCount) {
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected', rangeCount !== 0);
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-1', rangeCount === 1);
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-2', rangeCount === 2);
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-3', rangeCount === 3);
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-4', rangeCount >= 4);
                rangeCountLastTime = rangeCount;
            }
        };
        this.eventService.addEventListener(events_1.Events.EVENT_RANGE_SELECTION_CHANGED, rangeSelectedListener);
        this.addDestroyFunc(function () {
            _this.eventService.removeEventListener(events_1.Events.EVENT_RANGE_SELECTION_CHANGED, rangeSelectedListener);
        });
        rangeSelectedListener();
    };
    RenderedCell.prototype.addHighlightListener = function () {
        var _this = this;
        if (!this.rangeController) {
            return;
        }
        var clipboardListener = function (event) {
            var cellId = _this.gridCell.createId();
            var shouldFlash = event.cells[cellId];
            if (shouldFlash) {
                _this.animateCellWithHighlight();
            }
        };
        this.eventService.addEventListener(events_1.Events.EVENT_FLASH_CELLS, clipboardListener);
        this.addDestroyFunc(function () {
            _this.eventService.removeEventListener(events_1.Events.EVENT_FLASH_CELLS, clipboardListener);
        });
    };
    RenderedCell.prototype.addChangeListener = function () {
        var _this = this;
        var cellChangeListener = function (event) {
            if (event.column === _this.column) {
                _this.refreshCell();
                _this.animateCellWithDataChanged();
            }
        };
        this.addDestroyableEventListener(this.node, rowNode_1.RowNode.EVENT_CELL_CHANGED, cellChangeListener);
    };
    RenderedCell.prototype.animateCellWithDataChanged = function () {
        if (this.gridOptionsWrapper.isEnableCellChangeFlash() || this.column.getColDef().enableCellChangeFlash) {
            this.animateCell('data-changed');
        }
    };
    RenderedCell.prototype.animateCellWithHighlight = function () {
        this.animateCell('highlight');
    };
    RenderedCell.prototype.animateCell = function (cssName) {
        var _this = this;
        var fullName = 'ag-cell-' + cssName;
        var animationFullName = 'ag-cell-' + cssName + '-animation';
        // we want to highlight the cells, without any animation
        utils_1.Utils.addCssClass(this.eGridCell, fullName);
        utils_1.Utils.removeCssClass(this.eGridCell, animationFullName);
        // then once that is applied, we remove the highlight with animation
        setTimeout(function () {
            utils_1.Utils.removeCssClass(_this.eGridCell, fullName);
            utils_1.Utils.addCssClass(_this.eGridCell, animationFullName);
            setTimeout(function () {
                // and then to leave things as we got them, we remove the animation
                utils_1.Utils.removeCssClass(_this.eGridCell, animationFullName);
            }, 1000);
        }, 500);
    };
    RenderedCell.prototype.addCellFocusedListener = function () {
        var _this = this;
        // set to null, not false, as we need to set 'ag-cell-no-focus' first time around
        var cellFocusedLastTime = null;
        var cellFocusedListener = function (event) {
            var cellFocused = _this.focusedCellController.isCellFocused(_this.gridCell);
            // see if we need to change the classes on this cell
            if (cellFocused !== cellFocusedLastTime) {
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-focus', cellFocused);
                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-no-focus', !cellFocused);
                cellFocusedLastTime = cellFocused;
            }
            // if this cell was just focused, see if we need to force browser focus, his can
            // happen if focus is programmatically set.
            if (cellFocused && event && event.forceBrowserFocus) {
                _this.eGridCell.focus();
            }
            // if another cell was focused, and we are editing, then stop editing
            if (_this.editingCell && !cellFocused) {
                _this.stopEditing();
            }
        };
        this.eventService.addEventListener(events_1.Events.EVENT_CELL_FOCUSED, cellFocusedListener);
        this.addDestroyFunc(function () {
            _this.eventService.removeEventListener(events_1.Events.EVENT_CELL_FOCUSED, cellFocusedListener);
        });
        cellFocusedListener();
    };
    RenderedCell.prototype.setWidthOnCell = function () {
        var _this = this;
        var widthChangedListener = function () {
            _this.eGridCell.style.width = _this.column.getActualWidth() + "px";
        };
        this.column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
        this.addDestroyFunc(function () {
            _this.column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
        });
        widthChangedListener();
    };
    RenderedCell.prototype.init = function () {
        this.value = this.getValue();
        this.checkboxSelection = this.calculateCheckboxSelection();
        this.setLeftOnCell();
        this.setWidthOnCell();
        this.setPinnedClasses();
        this.addRangeSelectedListener();
        this.addHighlightListener();
        this.addChangeListener();
        this.addCellFocusedListener();
        this.addKeyDownListener();
        this.addKeyPressListener();
        // this.addFocusListener();
        // only set tab index if cell selection is enabled
        if (!this.gridOptionsWrapper.isSuppressCellSelection()) {
            this.eGridCell.setAttribute("tabindex", "-1");
        }
        // these are the grid styles, don't change between soft refreshes
        this.addClasses();
        this.setInlineEditingClass();
        this.createParentOfValue();
        this.populateCell();
    };
    RenderedCell.prototype.onEnterKeyDown = function () {
        if (this.editingCell) {
            this.stopEditing();
            this.focusCell(true);
        }
        else {
            this.startEditingIfEnabled(constants_1.Constants.KEY_ENTER);
        }
    };
    RenderedCell.prototype.onF2KeyDown = function () {
        if (!this.editingCell) {
            this.startEditingIfEnabled(constants_1.Constants.KEY_F2);
        }
    };
    RenderedCell.prototype.onEscapeKeyDown = function () {
        if (this.editingCell) {
            this.stopEditing(true);
            this.focusCell(true);
        }
    };
    RenderedCell.prototype.onPopupEditorClosed = function () {
        if (this.editingCell) {
            this.stopEditing(true);
            // we only focus cell again if this cell is still focused. it is possible
            // it is not focused if the user cancelled the edit by clicking on another
            // cell outside of this one
            if (this.focusedCellController.isCellFocused(this.gridCell)) {
                this.focusCell(true);
            }
        }
    };
    RenderedCell.prototype.onTabKeyDown = function (event) {
        var editNextCell;
        if (this.editingCell) {
            // if editing, we stop editing, then start editing next cell
            this.stopEditing();
            editNextCell = true;
        }
        else {
            // otherwise we just move to the next cell
            editNextCell = false;
        }
        var foundCell = this.rowRenderer.moveFocusToNextCell(this.rowIndex, this.column, this.node.floating, event.shiftKey, editNextCell);
        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default
        // to the normal tabbing so user can exit the grid.
        if (foundCell) {
            event.preventDefault();
        }
    };
    RenderedCell.prototype.onBackspaceOrDeleteKeyPressed = function (key) {
        if (!this.editingCell) {
            this.startEditingIfEnabled(key);
        }
    };
    RenderedCell.prototype.onSpaceKeyPressed = function () {
        if (!this.editingCell && this.gridOptionsWrapper.isRowSelection()) {
            var selected = this.node.isSelected();
            this.node.setSelected(!selected);
        }
        // prevent default as space key, by default, moves browser scroll down
        event.preventDefault();
    };
    RenderedCell.prototype.onNavigationKeyPressed = function (event, key) {
        if (this.editingCell) {
            this.stopEditing();
        }
        this.rowRenderer.navigateToNextCell(key, this.rowIndex, this.column, this.node.floating);
        // if we don't prevent default, the grid will scroll with the navigation keys
        event.preventDefault();
    };
    RenderedCell.prototype.addKeyPressListener = function () {
        var _this = this;
        var that = this;
        var keyPressListener = function (event) {
            if (that.isCellEditable()) {
                var pressedChar = String.fromCharCode(event.charCode);
                if (pressedChar === ' ') {
                    that.onSpaceKeyPressed();
                }
                else {
                    if (RenderedCell.PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0) {
                        that.startEditingIfEnabled(null, pressedChar);
                        // if we don't prevent default, then the keypress also gets applied to the text field
                        // (at least when doing the default editor), but we need to allow the editor to decide
                        // what it wants to do.
                        event.preventDefault();
                    }
                }
            }
        };
        this.eGridCell.addEventListener('keypress', keyPressListener);
        this.addDestroyFunc(function () {
            _this.eGridCell.removeEventListener('keypress', keyPressListener);
        });
    };
    RenderedCell.prototype.onKeyDown = function (event) {
        var key = event.which || event.keyCode;
        switch (key) {
            case constants_1.Constants.KEY_ENTER:
                this.onEnterKeyDown();
                break;
            case constants_1.Constants.KEY_F2:
                this.onF2KeyDown();
                break;
            case constants_1.Constants.KEY_ESCAPE:
                this.onEscapeKeyDown();
                break;
            case constants_1.Constants.KEY_TAB:
                this.onTabKeyDown(event);
                break;
            case constants_1.Constants.KEY_BACKSPACE:
            case constants_1.Constants.KEY_DELETE:
                this.onBackspaceOrDeleteKeyPressed(key);
                break;
            case constants_1.Constants.KEY_DOWN:
            case constants_1.Constants.KEY_UP:
            case constants_1.Constants.KEY_RIGHT:
            case constants_1.Constants.KEY_LEFT:
                this.onNavigationKeyPressed(event, key);
                break;
        }
    };
    RenderedCell.prototype.addKeyDownListener = function () {
        var _this = this;
        var editingKeyListener = this.onKeyDown.bind(this);
        this.eGridCell.addEventListener('keydown', editingKeyListener);
        this.addDestroyFunc(function () {
            _this.eGridCell.removeEventListener('keydown', editingKeyListener);
        });
    };
    RenderedCell.prototype.createCellEditor = function (keyPress, charPress) {
        var colDef = this.column.getColDef();
        var cellEditor = this.cellEditorFactory.createCellEditor(colDef.cellEditor);
        if (cellEditor.init) {
            var params = {
                value: this.getValue(),
                keyPress: keyPress,
                charPress: charPress,
                column: this.column,
                node: this.node,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext(),
                onKeyDown: this.onKeyDown.bind(this),
                stopEditing: this.stopEditingAndFocus.bind(this)
            };
            if (colDef.cellEditorParams) {
                utils_1.Utils.assign(params, colDef.cellEditorParams);
            }
            if (cellEditor.init) {
                cellEditor.init(params);
            }
        }
        return cellEditor;
    };
    // cell editors call this, when they want to stop for reasons other
    // than what we pick up on. eg selecting from a dropdown ends editing.
    RenderedCell.prototype.stopEditingAndFocus = function () {
        this.stopEditing();
        this.focusCell(true);
    };
    // called by rowRenderer when user navigates via tab key
    RenderedCell.prototype.startEditingIfEnabled = function (keyPress, charPress) {
        if (!this.isCellEditable()) {
            return;
        }
        var cellEditor = this.createCellEditor(keyPress, charPress);
        if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {
            if (cellEditor.destroy) {
                cellEditor.destroy();
            }
            return;
        }
        if (!cellEditor.getGui) {
            console.warn("ag-Grid: cellEditor for column " + this.column.getId() + " is missing getGui() method");
            return;
        }
        this.cellEditor = cellEditor;
        this.editingCell = true;
        this.cellEditorInPopup = this.cellEditor.isPopup && this.cellEditor.isPopup();
        this.setInlineEditingClass();
        if (this.cellEditorInPopup) {
            this.addPopupCellEditor();
        }
        else {
            this.addInCellEditor();
        }
        if (cellEditor.afterGuiAttached) {
            cellEditor.afterGuiAttached();
        }
    };
    RenderedCell.prototype.addInCellEditor = function () {
        utils_1.Utils.removeAllChildren(this.eGridCell);
        this.eGridCell.appendChild(this.cellEditor.getGui());
        if (this.gridOptionsWrapper.isAngularCompileRows()) {
            this.$compile(this.eGridCell)(this.scope);
        }
    };
    RenderedCell.prototype.addPopupCellEditor = function () {
        var _this = this;
        var ePopupGui = this.cellEditor.getGui();
        this.hideEditorPopup = this.popupService.addAsModalPopup(ePopupGui, true, 
        // callback for when popup disappears
        function () {
            // we only call stopEditing if we are editing, as
            // it's possible the popup called 'stop editing'
            // before this, eg if 'enter key' was pressed on
            // the editor
            if (_this.editingCell) {
                _this.onPopupEditorClosed();
            }
        });
        this.popupService.positionPopupOverComponent({
            eventSource: this.eGridCell,
            ePopup: ePopupGui,
            keepWithinBounds: true
        });
        if (this.gridOptionsWrapper.isAngularCompileRows()) {
            this.$compile(ePopupGui)(this.scope);
        }
    };
    RenderedCell.prototype.focusCell = function (forceBrowserFocus) {
        this.focusedCellController.setFocusedCell(this.rowIndex, this.column, this.node.floating, forceBrowserFocus);
    };
    // pass in 'true' to cancel the editing.
    RenderedCell.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        if (!this.editingCell) {
            return;
        }
        this.editingCell = false;
        // also have another option here to cancel after editing, so for example user could have a popup editor and
        // it is closed by user clicking outside the editor. then the editor will close automatically (with false
        // passed above) and we need to see if the editor wants to accept the new value.
        var cancelAfterEnd = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();
        var acceptNewValue = !cancel && !cancelAfterEnd;
        if (acceptNewValue) {
            var newValue = this.cellEditor.getValue();
            this.valueService.setValue(this.node, this.column, newValue);
            this.value = this.getValue();
        }
        if (this.cellEditor.destroy) {
            this.cellEditor.destroy();
        }
        if (this.cellEditorInPopup) {
            this.hideEditorPopup();
            this.hideEditorPopup = null;
        }
        else {
            utils_1.Utils.removeAllChildren(this.eGridCell);
            // put the cell back the way it was before editing
            if (this.checkboxSelection) {
                // if wrapper, then put the wrapper back
                this.eGridCell.appendChild(this.eCellWrapper);
            }
            else {
                // if cellRenderer, then put the gui back in. if the renderer has
                // a refresh, it will be called. however if it doesn't, then later
                // the renderer will be destroyed and a new one will be created.
                if (this.cellRenderer) {
                    this.eGridCell.appendChild(this.cellRenderer.getGui());
                }
            }
        }
        this.setInlineEditingClass();
        this.refreshCell();
    };
    RenderedCell.prototype.createParams = function () {
        var params = {
            node: this.node,
            data: this.node.data,
            value: this.value,
            rowIndex: this.rowIndex,
            colDef: this.column.getColDef(),
            $scope: this.scope,
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridApi,
            columnApi: this.columnApi
        };
        return params;
    };
    RenderedCell.prototype.createEvent = function (event, eventSource) {
        var agEvent = this.createParams();
        agEvent.event = event;
        //agEvent.eventSource = eventSource;
        return agEvent;
    };
    RenderedCell.prototype.isCellEditable = function () {
        if (this.editingCell) {
            return false;
        }
        // never allow editing of groups
        if (this.node.group) {
            return false;
        }
        return this.column.isCellEditable(this.node);
    };
    RenderedCell.prototype.onMouseEvent = function (eventName, mouseEvent, eventSource) {
        switch (eventName) {
            case 'click':
                this.onCellClicked(mouseEvent);
                break;
            case 'mousedown':
                this.onMouseDown();
                break;
            case 'dblclick':
                this.onCellDoubleClicked(mouseEvent, eventSource);
                break;
            case 'contextmenu':
                this.onContextMenu(mouseEvent);
                break;
        }
    };
    RenderedCell.prototype.onContextMenu = function (mouseEvent) {
        // to allow us to debug in chrome, we ignore the event if ctrl is pressed,
        // thus the normal menu is displayed
        if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
            return;
        }
        var colDef = this.column.getColDef();
        var agEvent = this.createEvent(mouseEvent);
        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_CONTEXT_MENU, agEvent);
        if (colDef.onCellContextMenu) {
            colDef.onCellContextMenu(agEvent);
        }
        if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {
            this.contextMenuFactory.showMenu(this.node, this.column, this.value, mouseEvent);
            mouseEvent.preventDefault();
        }
    };
    RenderedCell.prototype.onCellDoubleClicked = function (mouseEvent, eventSource) {
        var colDef = this.column.getColDef();
        // always dispatch event to eventService
        var agEvent = this.createEvent(mouseEvent, eventSource);
        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_DOUBLE_CLICKED, agEvent);
        // check if colDef also wants to handle event
        if (typeof colDef.onCellDoubleClicked === 'function') {
            colDef.onCellDoubleClicked(agEvent);
        }
        if (!this.gridOptionsWrapper.isSingleClickEdit()) {
            this.startEditingIfEnabled();
        }
    };
    RenderedCell.prototype.onMouseDown = function () {
        // we pass false to focusCell, as we don't want the cell to focus
        // also get the browser focus. if we did, then the cellRenderer could
        // have a text field in it, for example, and as the user clicks on the
        // text field, the text field, the focus doesn't get to the text
        // field, instead to goes to the div behind, making it impossible to
        // select the text field.
        this.focusCell(false);
        // if it's a right click, then if the cell is already in range,
        // don't change the range, however if the cell is not in a range,
        // we set a new range
        if (this.rangeController) {
            var thisCell = this.gridCell;
            var cellAlreadyInRange = this.rangeController.isCellInAnyRange(thisCell);
            if (!cellAlreadyInRange) {
                this.rangeController.setRangeToCell(thisCell);
            }
        }
    };
    RenderedCell.prototype.onCellClicked = function (mouseEvent) {
        var agEvent = this.createEvent(mouseEvent, this);
        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_CLICKED, agEvent);
        var colDef = this.column.getColDef();
        if (colDef.onCellClicked) {
            colDef.onCellClicked(agEvent);
        }
        if (this.gridOptionsWrapper.isSingleClickEdit()) {
            this.startEditingIfEnabled();
        }
    };
    // if we are editing inline, then we don't have the padding in the cell (set in the themes)
    // to allow the text editor full access to the entire cell
    RenderedCell.prototype.setInlineEditingClass = function () {
        var editingInline = this.editingCell && !this.cellEditorInPopup;
        utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-inline-editing', editingInline);
        utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-not-inline-editing', !editingInline);
    };
    RenderedCell.prototype.populateCell = function () {
        // populate
        this.putDataIntoCell();
        // style
        this.addStylesFromColDef();
        this.addClassesFromColDef();
        this.addClassesFromRules();
    };
    RenderedCell.prototype.addStylesFromColDef = function () {
        var colDef = this.column.getColDef();
        if (colDef.cellStyle) {
            var cssToUse;
            if (typeof colDef.cellStyle === 'function') {
                var cellStyleParams = {
                    value: this.value,
                    data: this.node.data,
                    node: this.node,
                    colDef: colDef,
                    column: this.column,
                    $scope: this.scope,
                    context: this.gridOptionsWrapper.getContext(),
                    api: this.gridOptionsWrapper.getApi()
                };
                var cellStyleFunc = colDef.cellStyle;
                cssToUse = cellStyleFunc(cellStyleParams);
            }
            else {
                cssToUse = colDef.cellStyle;
            }
            if (cssToUse) {
                utils_1.Utils.addStylesToElement(this.eGridCell, cssToUse);
            }
        }
    };
    RenderedCell.prototype.addClassesFromColDef = function () {
        var _this = this;
        var colDef = this.column.getColDef();
        if (colDef.cellClass) {
            var classToUse;
            if (typeof colDef.cellClass === 'function') {
                var cellClassParams = {
                    value: this.value,
                    data: this.node.data,
                    node: this.node,
                    colDef: colDef,
                    $scope: this.scope,
                    context: this.gridOptionsWrapper.getContext(),
                    api: this.gridOptionsWrapper.getApi()
                };
                var cellClassFunc = colDef.cellClass;
                classToUse = cellClassFunc(cellClassParams);
            }
            else {
                classToUse = colDef.cellClass;
            }
            if (typeof classToUse === 'string') {
                utils_1.Utils.addCssClass(this.eGridCell, classToUse);
            }
            else if (Array.isArray(classToUse)) {
                classToUse.forEach(function (cssClassItem) {
                    utils_1.Utils.addCssClass(_this.eGridCell, cssClassItem);
                });
            }
        }
    };
    RenderedCell.prototype.addClassesFromRules = function () {
        var colDef = this.column.getColDef();
        var classRules = colDef.cellClassRules;
        if (typeof classRules === 'object' && classRules !== null) {
            var params = {
                value: this.value,
                data: this.node.data,
                node: this.node,
                colDef: colDef,
                rowIndex: this.rowIndex,
                api: this.gridOptionsWrapper.getApi(),
                context: this.gridOptionsWrapper.getContext()
            };
            var classNames = Object.keys(classRules);
            for (var i = 0; i < classNames.length; i++) {
                var className = classNames[i];
                var rule = classRules[className];
                var resultOfRule;
                if (typeof rule === 'string') {
                    resultOfRule = this.expressionService.evaluate(rule, params);
                }
                else if (typeof rule === 'function') {
                    resultOfRule = rule(params);
                }
                if (resultOfRule) {
                    utils_1.Utils.addCssClass(this.eGridCell, className);
                }
                else {
                    utils_1.Utils.removeCssClass(this.eGridCell, className);
                }
            }
        }
    };
    RenderedCell.prototype.createParentOfValue = function () {
        if (this.checkboxSelection) {
            this.eCellWrapper = document.createElement('span');
            utils_1.Utils.addCssClass(this.eCellWrapper, 'ag-cell-wrapper');
            this.eGridCell.appendChild(this.eCellWrapper);
            var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
            this.context.wireBean(cbSelectionComponent);
            cbSelectionComponent.init({ rowNode: this.node });
            this.eCellWrapper.appendChild(cbSelectionComponent.getGui());
            this.addDestroyFunc(function () { return cbSelectionComponent.destroy(); });
            // eventually we call eSpanWithValue.innerHTML = xxx, so cannot include the checkbox (above) in this span
            this.eSpanWithValue = document.createElement('span');
            utils_1.Utils.addCssClass(this.eSpanWithValue, 'ag-cell-value');
            this.eCellWrapper.appendChild(this.eSpanWithValue);
            this.eParentOfValue = this.eSpanWithValue;
        }
        else {
            utils_1.Utils.addCssClass(this.eGridCell, 'ag-cell-value');
            this.eParentOfValue = this.eGridCell;
        }
    };
    RenderedCell.prototype.isVolatile = function () {
        return this.column.getColDef().volatile;
    };
    RenderedCell.prototype.refreshCell = function (animate, newData) {
        if (animate === void 0) { animate = false; }
        if (newData === void 0) { newData = false; }
        this.value = this.getValue();
        // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.
        // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')
        // then we are not showing a movement in the stock price, rather we are showing different stock.
        if (!newData && this.cellRenderer && this.cellRenderer.refresh) {
            // if the cell renderer has a refresh method, we call this instead of doing a refresh
            // note: should pass in params here instead of value?? so that client has formattedValue
            var valueFormatted = this.formatValue(this.value);
            var cellRendererParams = this.column.getColDef().cellRendererParams;
            var params = this.createRendererAndRefreshParams(valueFormatted, cellRendererParams);
            this.cellRenderer.refresh(params);
            // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static
            this.addClassesFromRules();
        }
        else {
            // otherwise we rip out the cell and replace it
            utils_1.Utils.removeAllChildren(this.eParentOfValue);
            // remove old renderer component if it exists
            if (this.cellRenderer && this.cellRenderer.destroy) {
                this.cellRenderer.destroy();
            }
            this.cellRenderer = null;
            this.populateCell();
            // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)
            if (this.gridOptionsWrapper.isAngularCompileRows()) {
                this.$compile(this.eGridCell)(this.scope);
            }
        }
        if (animate) {
            this.animateCellWithDataChanged();
        }
    };
    RenderedCell.prototype.putDataIntoCell = function () {
        // template gets preference, then cellRenderer, then do it ourselves
        var colDef = this.column.getColDef();
        var valueFormatted = this.valueFormatterService.formatValue(this.column, this.node, this.scope, this.rowIndex, this.value);
        if (colDef.template) {
            this.eParentOfValue.innerHTML = colDef.template;
        }
        else if (colDef.templateUrl) {
            var template = this.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));
            if (template) {
                this.eParentOfValue.innerHTML = template;
            }
        }
        else if (colDef.floatingCellRenderer && this.node.floating) {
            this.useCellRenderer(colDef.floatingCellRenderer, colDef.floatingCellRendererParams, valueFormatted);
        }
        else if (colDef.cellRenderer) {
            this.useCellRenderer(colDef.cellRenderer, colDef.cellRendererParams, valueFormatted);
        }
        else {
            // if we insert undefined, then it displays as the string 'undefined', ugly!
            var valueToRender = utils_1.Utils.exists(valueFormatted) ? valueFormatted : this.value;
            if (utils_1.Utils.exists(valueToRender) && valueToRender !== '') {
                this.eParentOfValue.innerHTML = valueToRender.toString();
            }
        }
        if (colDef.tooltipField) {
            var data = this.getDataForRow();
            var tooltip = data[colDef.tooltipField];
            this.eParentOfValue.setAttribute('title', tooltip);
        }
    };
    RenderedCell.prototype.formatValue = function (value) {
        return this.valueFormatterService.formatValue(this.column, this.node, this.scope, this.rowIndex, value);
    };
    RenderedCell.prototype.createRendererAndRefreshParams = function (valueFormatted, cellRendererParams) {
        var params = {
            value: this.value,
            valueFormatted: valueFormatted,
            valueGetter: this.getValue,
            formatValue: this.formatValue.bind(this),
            data: this.node.data,
            node: this.node,
            colDef: this.column.getColDef(),
            column: this.column,
            $scope: this.scope,
            rowIndex: this.rowIndex,
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi(),
            context: this.gridOptionsWrapper.getContext(),
            refreshCell: this.refreshCell.bind(this),
            eGridCell: this.eGridCell,
            eParentOfValue: this.eParentOfValue,
            addRenderedRowListener: this.renderedRow.addEventListener.bind(this.renderedRow)
        };
        if (cellRendererParams) {
            utils_1.Utils.assign(params, cellRendererParams);
        }
        return params;
    };
    RenderedCell.prototype.useCellRenderer = function (cellRendererKey, cellRendererParams, valueFormatted) {
        var params = this.createRendererAndRefreshParams(valueFormatted, cellRendererParams);
        this.cellRenderer = this.cellRendererService.useCellRenderer(cellRendererKey, this.eParentOfValue, params);
    };
    RenderedCell.prototype.addClasses = function () {
        utils_1.Utils.addCssClass(this.eGridCell, 'ag-cell');
        this.eGridCell.setAttribute("colId", this.column.getColId());
        if (this.node.group && this.node.footer) {
            utils_1.Utils.addCssClass(this.eGridCell, 'ag-footer-cell');
        }
        if (this.node.group && !this.node.footer) {
            utils_1.Utils.addCssClass(this.eGridCell, 'ag-group-cell');
        }
    };
    RenderedCell.PRINTABLE_CHARACTERS = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!"£$%^&*()_+-=[];\'#,./\|<>?:@~{}';
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], RenderedCell.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnApi'), 
        __metadata('design:type', columnController_1.ColumnApi)
    ], RenderedCell.prototype, "columnApi", void 0);
    __decorate([
        context_1.Autowired('gridApi'), 
        __metadata('design:type', gridApi_1.GridApi)
    ], RenderedCell.prototype, "gridApi", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], RenderedCell.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('expressionService'), 
        __metadata('design:type', expressionService_1.ExpressionService)
    ], RenderedCell.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('rowRenderer'), 
        __metadata('design:type', rowRenderer_1.RowRenderer)
    ], RenderedCell.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('$compile'), 
        __metadata('design:type', Object)
    ], RenderedCell.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('templateService'), 
        __metadata('design:type', templateService_1.TemplateService)
    ], RenderedCell.prototype, "templateService", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], RenderedCell.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], RenderedCell.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], RenderedCell.prototype, "columnController", void 0);
    __decorate([
        context_1.Optional('rangeController'), 
        __metadata('design:type', Object)
    ], RenderedCell.prototype, "rangeController", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'), 
        __metadata('design:type', focusedCellController_1.FocusedCellController)
    ], RenderedCell.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Optional('contextMenuFactory'), 
        __metadata('design:type', Object)
    ], RenderedCell.prototype, "contextMenuFactory", void 0);
    __decorate([
        context_1.Autowired('focusService'), 
        __metadata('design:type', focusService_1.FocusService)
    ], RenderedCell.prototype, "focusService", void 0);
    __decorate([
        context_1.Autowired('cellEditorFactory'), 
        __metadata('design:type', cellEditorFactory_1.CellEditorFactory)
    ], RenderedCell.prototype, "cellEditorFactory", void 0);
    __decorate([
        context_1.Autowired('cellRendererFactory'), 
        __metadata('design:type', cellRendererFactory_1.CellRendererFactory)
    ], RenderedCell.prototype, "cellRendererFactory", void 0);
    __decorate([
        context_1.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], RenderedCell.prototype, "popupService", void 0);
    __decorate([
        context_1.Autowired('cellRendererService'), 
        __metadata('design:type', cellRendererService_1.CellRendererService)
    ], RenderedCell.prototype, "cellRendererService", void 0);
    __decorate([
        context_1.Autowired('valueFormatterService'), 
        __metadata('design:type', valueFormatterService_1.ValueFormatterService)
    ], RenderedCell.prototype, "valueFormatterService", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], RenderedCell.prototype, "init", null);
    return RenderedCell;
})(component_1.Component);
exports.RenderedCell = RenderedCell;

},{"../columnController/columnController":77,"../constants":86,"../context/context":87,"../entities/column":92,"../entities/gridCell":94,"../entities/rowNode":97,"../eventService":98,"../events":99,"../expressionService":100,"../focusedCellController":104,"../gridApi":107,"../gridOptionsWrapper":109,"../misc/focusService":126,"../templateService":155,"../utils":156,"../valueService":157,"../widgets/component":158,"../widgets/popupService":161,"./cellEditorFactory":128,"./cellRendererFactory":135,"./cellRendererService":136,"./checkboxSelectionComponent":140,"./rowRenderer":143,"./valueFormatterService":144}],142:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var renderedCell_1 = require("./renderedCell");
var rowNode_1 = require("../entities/rowNode");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var columnController_1 = require("../columnController/columnController");
var column_1 = require("../entities/column");
var events_1 = require("../events");
var eventService_1 = require("../eventService");
var context_1 = require("../context/context");
var focusedCellController_1 = require("../focusedCellController");
var constants_1 = require("../constants");
var cellRendererService_1 = require("./cellRendererService");
var cellRendererFactory_1 = require("./cellRendererFactory");
var RenderedRow = (function () {
    function RenderedRow(parentScope, rowRenderer, eBodyContainer, ePinnedLeftContainer, ePinnedRightContainer, node, rowIndex) {
        this.renderedCells = {};
        this.destroyFunctions = [];
        this.parentScope = parentScope;
        this.rowRenderer = rowRenderer;
        this.eBodyContainer = eBodyContainer;
        this.ePinnedLeftContainer = ePinnedLeftContainer;
        this.ePinnedRightContainer = ePinnedRightContainer;
        this.rowIndex = rowIndex;
        this.rowNode = node;
    }
    RenderedRow.prototype.init = function () {
        var _this = this;
        this.createContainers();
        var groupHeaderTakesEntireRow = this.gridOptionsWrapper.isGroupUseEntireRow();
        this.rowIsHeaderThatSpans = this.rowNode.group && groupHeaderTakesEntireRow;
        this.scope = this.createChildScopeOrNull(this.rowNode.data);
        if (this.rowIsHeaderThatSpans) {
            this.refreshGroupRow();
        }
        else {
            this.refreshCellsIntoRow();
        }
        this.addDynamicStyles();
        this.addDynamicClasses();
        this.addRowIds();
        this.setTopAndHeightCss();
        this.addRowSelectedListener();
        this.addCellFocusedListener();
        this.addNodeDataChangedListener();
        this.addColumnListener();
        this.addHoverFunctionality();
        this.attachContainers();
        this.gridOptionsWrapper.executeProcessRowPostCreateFunc({
            eRow: this.eBodyRow,
            ePinnedLeftRow: this.ePinnedLeftRow,
            ePinnedRightRow: this.ePinnedRightRow,
            node: this.rowNode,
            api: this.gridOptionsWrapper.getApi(),
            rowIndex: this.rowIndex,
            addRenderedRowListener: this.addEventListener.bind(this),
            columnApi: this.gridOptionsWrapper.getColumnApi(),
            context: this.gridOptionsWrapper.getContext()
        });
        if (this.scope) {
            this.eLeftCenterAndRightRows.forEach(function (row) { return _this.$compile(row)(_this.scope); });
        }
    };
    RenderedRow.prototype.addColumnListener = function () {
        var _this = this;
        var columnListener = this.onColumnChanged.bind(this);
        this.mainEventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, columnListener);
        //this.mainEventService.addEventListener(Events.EVENT_COLUMN_MOVED, columnListener);
        //this.mainEventService.addEventListener(Events.EVENT_COLUMN_ROW_GROUP_CHANGE, columnListener);
        //this.mainEventService.addEventListener(Events.EVENT_COLUMN_RESIZED, columnListener);
        //this.mainEventService.addEventListener(Events.EVENT_COLUMN_VALUE_CHANGE, columnListener);
        this.mainEventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, columnListener);
        this.mainEventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, columnListener);
        this.destroyFunctions.push(function () {
            _this.mainEventService.removeEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, columnListener);
            //this.mainEventService.removeEventListener(Events.EVENT_COLUMN_MOVED, columnListener);
            //this.mainEventService.removeEventListener(Events.EVENT_COLUMN_ROW_GROUP_CHANGE, columnListener);
            //this.mainEventService.removeEventListener(Events.EVENT_COLUMN_RESIZED, columnListener);
            //this.mainEventService.removeEventListener(Events.EVENT_COLUMN_VALUE_CHANGE, columnListener);
            _this.mainEventService.removeEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, columnListener);
            _this.mainEventService.removeEventListener(events_1.Events.EVENT_COLUMN_PINNED, columnListener);
        });
    };
    RenderedRow.prototype.onColumnChanged = function (event) {
        // if row is a group row that spans, then it's not impacted by column changes, with exception of pinning
        if (this.rowIsHeaderThatSpans) {
            var columnPinned = event.getType() === events_1.Events.EVENT_COLUMN_PINNED;
            if (columnPinned) {
                this.refreshGroupRow();
            }
        }
        else {
            this.refreshCellsIntoRow();
        }
    };
    // method makes sure the right cells are present, and are in the right container. so when this gets called for
    // the first time, it sets up all the cells. but then over time the cells might appear / dissappear or move
    // container (ie into pinned)
    RenderedRow.prototype.refreshCellsIntoRow = function () {
        var _this = this;
        var columns = this.columnController.getAllDisplayedColumns();
        var renderedCellKeys = Object.keys(this.renderedCells);
        columns.forEach(function (column) {
            var renderedCell = _this.getOrCreateCell(column);
            _this.ensureCellInCorrectRow(renderedCell);
            utils_1.Utils.removeFromArray(renderedCellKeys, column.getColId());
        });
        // remove old cells from gui, but we don't destroy them, we might use them again
        renderedCellKeys.forEach(function (key) {
            var renderedCell = _this.renderedCells[key];
            // could be old reference, ie removed cell
            if (!renderedCell) {
                return;
            }
            if (renderedCell.getParentRow()) {
                renderedCell.getParentRow().removeChild(renderedCell.getGui());
                renderedCell.setParentRow(null);
            }
            renderedCell.destroy();
            _this.renderedCells[key] = null;
        });
    };
    RenderedRow.prototype.ensureCellInCorrectRow = function (renderedCell) {
        var eRowGui = renderedCell.getGui();
        var column = renderedCell.getColumn();
        var rowWeWant;
        switch (column.getPinned()) {
            case column_1.Column.PINNED_LEFT:
                rowWeWant = this.ePinnedLeftRow;
                break;
            case column_1.Column.PINNED_RIGHT:
                rowWeWant = this.ePinnedRightRow;
                break;
            default:
                rowWeWant = this.eBodyRow;
                break;
        }
        // if in wrong container, remove it
        var oldRow = renderedCell.getParentRow();
        var inWrongRow = oldRow !== rowWeWant;
        if (inWrongRow) {
            // take out from old row
            if (oldRow) {
                oldRow.removeChild(eRowGui);
            }
            rowWeWant.appendChild(eRowGui);
            renderedCell.setParentRow(rowWeWant);
        }
    };
    RenderedRow.prototype.getOrCreateCell = function (column) {
        var colId = column.getColId();
        if (this.renderedCells[colId]) {
            return this.renderedCells[colId];
        }
        else {
            var renderedCell = new renderedCell_1.RenderedCell(column, this.rowNode, this.rowIndex, this.scope, this);
            this.context.wireBean(renderedCell);
            this.renderedCells[colId] = renderedCell;
            return renderedCell;
        }
    };
    RenderedRow.prototype.addRowSelectedListener = function () {
        var _this = this;
        var rowSelectedListener = function () {
            var selected = _this.rowNode.isSelected();
            _this.eLeftCenterAndRightRows.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-selected', selected); });
        };
        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_ROW_SELECTED, rowSelectedListener);
        this.destroyFunctions.push(function () {
            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_ROW_SELECTED, rowSelectedListener);
        });
    };
    RenderedRow.prototype.addHoverFunctionality = function () {
        var _this = this;
        var onGuiMouseEnter = this.rowNode.onMouseEnter.bind(this.rowNode);
        var onGuiMouseLeave = this.rowNode.onMouseLeave.bind(this.rowNode);
        this.eLeftCenterAndRightRows.forEach(function (eRow) {
            eRow.addEventListener('mouseenter', onGuiMouseEnter);
            eRow.addEventListener('mouseleave', onGuiMouseLeave);
        });
        var onNodeMouseEnter = this.addHoverClass.bind(this, true);
        var onNodeMouseLeave = this.addHoverClass.bind(this, false);
        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_MOUSE_ENTER, onNodeMouseEnter);
        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_MOUSE_LEAVE, onNodeMouseLeave);
        this.destroyFunctions.push(function () {
            _this.eLeftCenterAndRightRows.forEach(function (eRow) {
                eRow.removeEventListener('mouseenter', onGuiMouseEnter);
                eRow.removeEventListener('mouseleave', onGuiMouseLeave);
            });
            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_MOUSE_ENTER, onNodeMouseEnter);
            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_MOUSE_LEAVE, onNodeMouseLeave);
        });
    };
    RenderedRow.prototype.addHoverClass = function (hover) {
        this.eLeftCenterAndRightRows.forEach(function (eRow) { return utils_1.Utils.addOrRemoveCssClass(eRow, 'ag-row-hover', hover); });
    };
    RenderedRow.prototype.addCellFocusedListener = function () {
        var _this = this;
        var rowFocusedLastTime = null;
        var rowFocusedListener = function () {
            var rowFocused = _this.focusedCellController.isRowFocused(_this.rowIndex, _this.rowNode.floating);
            if (rowFocused !== rowFocusedLastTime) {
                _this.eLeftCenterAndRightRows.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-focus', rowFocused); });
                _this.eLeftCenterAndRightRows.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-no-focus', !rowFocused); });
                rowFocusedLastTime = rowFocused;
            }
        };
        this.mainEventService.addEventListener(events_1.Events.EVENT_CELL_FOCUSED, rowFocusedListener);
        this.destroyFunctions.push(function () {
            _this.mainEventService.removeEventListener(events_1.Events.EVENT_CELL_FOCUSED, rowFocusedListener);
        });
        rowFocusedListener();
    };
    RenderedRow.prototype.forEachRenderedCell = function (callback) {
        utils_1.Utils.iterateObject(this.renderedCells, function (key, renderedCell) {
            if (renderedCell) {
                callback(renderedCell);
            }
        });
    };
    RenderedRow.prototype.addNodeDataChangedListener = function () {
        var _this = this;
        var nodeDataChangedListener = function () {
            var animate = false;
            var newData = true;
            _this.forEachRenderedCell(function (renderedCell) { return renderedCell.refreshCell(animate, newData); });
        };
        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, nodeDataChangedListener);
        this.destroyFunctions.push(function () {
            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, nodeDataChangedListener);
        });
    };
    RenderedRow.prototype.createContainers = function () {
        this.eBodyRow = this.createRowContainer();
        this.eLeftCenterAndRightRows = [this.eBodyRow];
        if (!this.gridOptionsWrapper.isForPrint()) {
            this.ePinnedLeftRow = this.createRowContainer();
            this.ePinnedRightRow = this.createRowContainer();
            this.eLeftCenterAndRightRows.push(this.ePinnedLeftRow);
            this.eLeftCenterAndRightRows.push(this.ePinnedRightRow);
        }
    };
    RenderedRow.prototype.attachContainers = function () {
        this.eBodyContainer.appendChild(this.eBodyRow);
        if (!this.gridOptionsWrapper.isForPrint()) {
            this.ePinnedLeftContainer.appendChild(this.ePinnedLeftRow);
            this.ePinnedRightContainer.appendChild(this.ePinnedRightRow);
        }
    };
    RenderedRow.prototype.onMouseEvent = function (eventName, mouseEvent, eventSource, cell) {
        var renderedCell = this.renderedCells[cell.column.getId()];
        if (renderedCell) {
            renderedCell.onMouseEvent(eventName, mouseEvent, eventSource);
        }
    };
    RenderedRow.prototype.setTopAndHeightCss = function () {
        // if showing scrolls, position on the container
        if (!this.gridOptionsWrapper.isForPrint()) {
            var topPx = this.rowNode.rowTop + "px";
            this.eLeftCenterAndRightRows.forEach(function (row) { return row.style.top = topPx; });
        }
        var heightPx = this.rowNode.rowHeight + 'px';
        this.eLeftCenterAndRightRows.forEach(function (row) { return row.style.height = heightPx; });
    };
    // adds in row and row-id attributes to the row
    RenderedRow.prototype.addRowIds = function () {
        var rowStr = this.rowIndex.toString();
        if (this.rowNode.floating === constants_1.Constants.FLOATING_BOTTOM) {
            rowStr = 'fb-' + rowStr;
        }
        else if (this.rowNode.floating === constants_1.Constants.FLOATING_TOP) {
            rowStr = 'ft-' + rowStr;
        }
        this.eLeftCenterAndRightRows.forEach(function (row) { return row.setAttribute('row', rowStr); });
        if (typeof this.gridOptionsWrapper.getBusinessKeyForNodeFunc() === 'function') {
            var businessKey = this.gridOptionsWrapper.getBusinessKeyForNodeFunc()(this.rowNode);
            if (typeof businessKey === 'string' || typeof businessKey === 'number') {
                this.eLeftCenterAndRightRows.forEach(function (row) { return row.setAttribute('row-id', businessKey); });
            }
        }
    };
    RenderedRow.prototype.addEventListener = function (eventType, listener) {
        if (!this.renderedRowEventService) {
            this.renderedRowEventService = new eventService_1.EventService();
        }
        this.renderedRowEventService.addEventListener(eventType, listener);
    };
    RenderedRow.prototype.removeEventListener = function (eventType, listener) {
        this.renderedRowEventService.removeEventListener(eventType, listener);
    };
    RenderedRow.prototype.getRenderedCellForColumn = function (column) {
        return this.renderedCells[column.getColId()];
    };
    RenderedRow.prototype.getCellForCol = function (column) {
        var renderedCell = this.renderedCells[column.getColId()];
        if (renderedCell) {
            return renderedCell.getGui();
        }
        else {
            return null;
        }
    };
    RenderedRow.prototype.destroy = function () {
        this.destroyFunctions.forEach(function (func) { return func(); });
        this.destroyScope();
        this.eBodyContainer.removeChild(this.eBodyRow);
        if (!this.gridOptionsWrapper.isForPrint()) {
            this.ePinnedLeftContainer.removeChild(this.ePinnedLeftRow);
            this.ePinnedRightContainer.removeChild(this.ePinnedRightRow);
        }
        this.forEachRenderedCell(function (renderedCell) { return renderedCell.destroy(); });
        if (this.renderedRowEventService) {
            this.renderedRowEventService.dispatchEvent(RenderedRow.EVENT_RENDERED_ROW_REMOVED, { node: this.rowNode });
        }
    };
    RenderedRow.prototype.destroyScope = function () {
        if (this.scope) {
            this.scope.$destroy();
            this.scope = null;
        }
    };
    RenderedRow.prototype.isDataInList = function (rows) {
        return rows.indexOf(this.rowNode.data) >= 0;
    };
    RenderedRow.prototype.isGroup = function () {
        return this.rowNode.group === true;
    };
    RenderedRow.prototype.refreshGroupRow = function () {
        // where the components go changes with pinning, it's easiest ot just remove from all containers
        // and start again if the pinning changes
        utils_1.Utils.removeAllChildren(this.ePinnedLeftRow);
        utils_1.Utils.removeAllChildren(this.ePinnedRightRow);
        utils_1.Utils.removeAllChildren(this.eBodyRow);
        // create main component if not already existing from previous refresh
        if (!this.eGroupRow) {
            this.eGroupRow = this.createGroupSpanningEntireRowCell(false);
        }
        var pinningLeft = this.columnController.isPinningLeft();
        var pinningRight = this.columnController.isPinningRight();
        // if pinning left, then main component goes into left and we pad centre, otherwise it goes into centre
        if (pinningLeft) {
            this.ePinnedLeftRow.appendChild(this.eGroupRow);
            if (!this.eGroupRowPaddingCentre) {
                this.eGroupRowPaddingCentre = this.createGroupSpanningEntireRowCell(true);
            }
            this.eBodyRow.appendChild(this.eGroupRowPaddingCentre);
        }
        else {
            this.eBodyRow.appendChild(this.eGroupRow);
        }
        // main component is never in right, but if pinning right, we put padding into the right
        if (pinningRight) {
            if (!this.eGroupRowPaddingRight) {
                this.eGroupRowPaddingRight = this.createGroupSpanningEntireRowCell(true);
            }
            this.ePinnedRightRow.appendChild(this.eGroupRowPaddingRight);
        }
    };
    RenderedRow.prototype.createGroupSpanningEntireRowCell = function (padding) {
        var eRow = document.createElement('span');
        // padding means we are on the right hand side of a pinned table, ie
        // in the main body.
        if (!padding) {
            var cellRenderer = this.gridOptionsWrapper.getGroupRowRenderer();
            var cellRendererParams = this.gridOptionsWrapper.getGroupRowRendererParams();
            if (!cellRenderer) {
                cellRenderer = cellRendererFactory_1.CellRendererFactory.GROUP;
                cellRendererParams = {
                    innerRenderer: this.gridOptionsWrapper.getGroupRowInnerRenderer(),
                };
            }
            var params = {
                data: this.rowNode.data,
                node: this.rowNode,
                $scope: this.scope,
                rowIndex: this.rowIndex,
                api: this.gridOptionsWrapper.getApi(),
                columnApi: this.gridOptionsWrapper.getColumnApi(),
                context: this.gridOptionsWrapper.getContext(),
                eGridCell: eRow,
                eParentOfValue: eRow,
                addRenderedRowListener: this.addEventListener.bind(this),
                colDef: {
                    cellRenderer: cellRenderer,
                    cellRendererParams: cellRendererParams
                }
            };
            if (cellRendererParams) {
                utils_1.Utils.assign(params, cellRendererParams);
            }
            var cellComponent = this.cellRendererService.useCellRenderer(cellRenderer, eRow, params);
            if (cellComponent && cellComponent.destroy) {
                this.destroyFunctions.push(function () { return cellComponent.destroy(); });
            }
        }
        if (this.rowNode.footer) {
            utils_1.Utils.addCssClass(eRow, 'ag-footer-cell-entire-row');
        }
        else {
            utils_1.Utils.addCssClass(eRow, 'ag-group-cell-entire-row');
        }
        return eRow;
    };
    RenderedRow.prototype.createChildScopeOrNull = function (data) {
        if (this.gridOptionsWrapper.isAngularCompileRows()) {
            var newChildScope = this.parentScope.$new();
            newChildScope.data = data;
            newChildScope.context = this.gridOptionsWrapper.getContext();
            return newChildScope;
        }
        else {
            return null;
        }
    };
    RenderedRow.prototype.addDynamicStyles = function () {
        var rowStyle = this.gridOptionsWrapper.getRowStyle();
        if (rowStyle) {
            if (typeof rowStyle === 'function') {
                console.log('ag-Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead');
            }
            else {
                this.eLeftCenterAndRightRows.forEach(function (row) { return utils_1.Utils.addStylesToElement(row, rowStyle); });
            }
        }
        var rowStyleFunc = this.gridOptionsWrapper.getRowStyleFunc();
        if (rowStyleFunc) {
            var params = {
                data: this.rowNode.data,
                node: this.rowNode,
                api: this.gridOptionsWrapper.getApi(),
                context: this.gridOptionsWrapper.getContext(),
                $scope: this.scope
            };
            var cssToUseFromFunc = rowStyleFunc(params);
            this.eLeftCenterAndRightRows.forEach(function (row) { return utils_1.Utils.addStylesToElement(row, cssToUseFromFunc); });
        }
    };
    RenderedRow.prototype.createParams = function () {
        var params = {
            node: this.rowNode,
            data: this.rowNode.data,
            rowIndex: this.rowIndex,
            $scope: this.scope,
            context: this.gridOptionsWrapper.getContext(),
            api: this.gridOptionsWrapper.getApi()
        };
        return params;
    };
    RenderedRow.prototype.createEvent = function (event, eventSource) {
        var agEvent = this.createParams();
        agEvent.event = event;
        agEvent.eventSource = eventSource;
        return agEvent;
    };
    RenderedRow.prototype.createRowContainer = function () {
        var _this = this;
        var eRow = document.createElement('div');
        eRow.addEventListener("click", this.onRowClicked.bind(this));
        eRow.addEventListener("dblclick", function (event) {
            var agEvent = _this.createEvent(event, _this);
            _this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_DOUBLE_CLICKED, agEvent);
        });
        return eRow;
    };
    RenderedRow.prototype.onRowClicked = function (event) {
        var agEvent = this.createEvent(event, this);
        this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_CLICKED, agEvent);
        // ctrlKey for windows, metaKey for Apple
        var multiSelectKeyPressed = event.ctrlKey || event.metaKey;
        var shiftKeyPressed = event.shiftKey;
        // we do not allow selecting groups by clicking (as the click here expands the group)
        // so return if it's a group row
        if (this.rowNode.group) {
            return;
        }
        // we also don't allow selection of floating rows
        if (this.rowNode.floating) {
            return;
        }
        // making local variables to make the below more readable
        var gridOptionsWrapper = this.gridOptionsWrapper;
        // if no selection method enabled, do nothing
        if (!gridOptionsWrapper.isRowSelection()) {
            return;
        }
        // if click selection suppressed, do nothing
        if (gridOptionsWrapper.isSuppressRowClickSelection()) {
            return;
        }
        if (this.rowNode.isSelected()) {
            if (multiSelectKeyPressed) {
                if (gridOptionsWrapper.isRowDeselection()) {
                    this.rowNode.setSelectedParams({ newValue: false });
                }
            }
            else {
                // selected with no multi key, must make sure anything else is unselected
                this.rowNode.setSelectedParams({ newValue: true, clearSelection: true });
            }
        }
        else {
            this.rowNode.setSelectedParams({ newValue: true, clearSelection: !multiSelectKeyPressed, rangeSelect: shiftKeyPressed });
        }
    };
    RenderedRow.prototype.getRowNode = function () {
        return this.rowNode;
    };
    RenderedRow.prototype.getRowIndex = function () {
        return this.rowIndex;
    };
    RenderedRow.prototype.refreshCells = function (colIds, animate) {
        if (!colIds) {
            return;
        }
        var columnsToRefresh = this.columnController.getGridColumns(colIds);
        this.forEachRenderedCell(function (renderedCell) {
            var colForCel = renderedCell.getColumn();
            if (columnsToRefresh.indexOf(colForCel) >= 0) {
                renderedCell.refreshCell(animate);
            }
        });
    };
    RenderedRow.prototype.addDynamicClasses = function () {
        var _this = this;
        var classes = [];
        classes.push('ag-row');
        classes.push('ag-row-no-focus');
        classes.push(this.rowIndex % 2 == 0 ? "ag-row-even" : "ag-row-odd");
        if (this.rowNode.isSelected()) {
            classes.push("ag-row-selected");
        }
        if (this.rowNode.group) {
            classes.push("ag-row-group");
            // if a group, put the level of the group in
            classes.push("ag-row-level-" + this.rowNode.level);
            if (!this.rowNode.footer && this.rowNode.expanded) {
                classes.push("ag-row-group-expanded");
            }
            if (!this.rowNode.footer && !this.rowNode.expanded) {
                // opposite of expanded is contracted according to the internet.
                classes.push("ag-row-group-contracted");
            }
            if (this.rowNode.footer) {
                classes.push("ag-row-footer");
            }
        }
        else {
            // if a leaf, and a parent exists, put a level of the parent, else put level of 0 for top level item
            if (this.rowNode.parent) {
                classes.push("ag-row-level-" + (this.rowNode.parent.level + 1));
            }
            else {
                classes.push("ag-row-level-0");
            }
        }
        // add in extra classes provided by the config
        var gridOptionsRowClass = this.gridOptionsWrapper.getRowClass();
        if (gridOptionsRowClass) {
            if (typeof gridOptionsRowClass === 'function') {
                console.warn('ag-Grid: rowClass should not be a function, please use getRowClass instead');
            }
            else {
                if (typeof gridOptionsRowClass === 'string') {
                    classes.push(gridOptionsRowClass);
                }
                else if (Array.isArray(gridOptionsRowClass)) {
                    gridOptionsRowClass.forEach(function (classItem) {
                        classes.push(classItem);
                    });
                }
            }
        }
        var gridOptionsRowClassFunc = this.gridOptionsWrapper.getRowClassFunc();
        if (gridOptionsRowClassFunc) {
            var params = {
                node: this.rowNode,
                data: this.rowNode.data,
                rowIndex: this.rowIndex,
                context: this.gridOptionsWrapper.getContext(),
                api: this.gridOptionsWrapper.getApi()
            };
            var classToUseFromFunc = gridOptionsRowClassFunc(params);
            if (classToUseFromFunc) {
                if (typeof classToUseFromFunc === 'string') {
                    classes.push(classToUseFromFunc);
                }
                else if (Array.isArray(classToUseFromFunc)) {
                    classToUseFromFunc.forEach(function (classItem) {
                        classes.push(classItem);
                    });
                }
            }
        }
        classes.forEach(function (classStr) {
            _this.eLeftCenterAndRightRows.forEach(function (row) { return utils_1.Utils.addCssClass(row, classStr); });
        });
    };
    RenderedRow.EVENT_RENDERED_ROW_REMOVED = 'renderedRowRemoved';
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], RenderedRow.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], RenderedRow.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('$compile'), 
        __metadata('design:type', Object)
    ], RenderedRow.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], RenderedRow.prototype, "mainEventService", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], RenderedRow.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'), 
        __metadata('design:type', focusedCellController_1.FocusedCellController)
    ], RenderedRow.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Autowired('cellRendererService'), 
        __metadata('design:type', cellRendererService_1.CellRendererService)
    ], RenderedRow.prototype, "cellRendererService", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], RenderedRow.prototype, "init", null);
    return RenderedRow;
})();
exports.RenderedRow = RenderedRow;

},{"../columnController/columnController":77,"../constants":86,"../context/context":87,"../entities/column":92,"../entities/rowNode":97,"../eventService":98,"../events":99,"../focusedCellController":104,"../gridOptionsWrapper":109,"../utils":156,"./cellRendererFactory":135,"./cellRendererService":136,"./renderedCell":141}],143:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var utils_1 = require("../utils");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var gridPanel_1 = require("../gridPanel/gridPanel");
var expressionService_1 = require("../expressionService");
var templateService_1 = require("../templateService");
var valueService_1 = require("../valueService");
var eventService_1 = require("../eventService");
var floatingRowModel_1 = require("../rowControllers/floatingRowModel");
var renderedRow_1 = require("./renderedRow");
var events_1 = require("../events");
var constants_1 = require("../constants");
var context_1 = require("../context/context");
var gridCore_1 = require("../gridCore");
var columnController_1 = require("../columnController/columnController");
var logger_1 = require("../logger");
var focusedCellController_1 = require("../focusedCellController");
var cellNavigationService_1 = require("../cellNavigationService");
var gridCell_1 = require("../entities/gridCell");
var RowRenderer = (function () {
    function RowRenderer() {
        // map of row ids to row objects. keeps track of which elements
        // are rendered for which rows in the dom.
        this.renderedRows = {};
        this.renderedTopFloatingRows = [];
        this.renderedBottomFloatingRows = [];
    }
    RowRenderer.prototype.agWire = function (loggerFactory) {
        this.logger = this.loggerFactory.create('RowRenderer');
        this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
    };
    RowRenderer.prototype.init = function () {
        this.getContainersFromGridPanel();
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.onColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.onColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.onColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnEvent.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_MODEL_UPDATED, this.refreshView.bind(this));
        this.eventService.addEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, this.refreshView.bind(this, null));
        //this.eventService.addEventListener(Events.EVENT_COLUMN_VALUE_CHANGE, this.refreshView.bind(this, null));
        //this.eventService.addEventListener(Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refreshView.bind(this, null));
        //this.eventService.addEventListener(Events.EVENT_COLUMN_ROW_GROUP_CHANGE, this.refreshView.bind(this, null));
        this.refreshView();
    };
    RowRenderer.prototype.onColumnEvent = function (event) {
        if (event.isContainerWidthImpacted()) {
            this.setMainRowWidths();
        }
    };
    RowRenderer.prototype.getContainersFromGridPanel = function () {
        this.eBodyContainer = this.gridPanel.getBodyContainer();
        this.ePinnedLeftColsContainer = this.gridPanel.getPinnedLeftColsContainer();
        this.ePinnedRightColsContainer = this.gridPanel.getPinnedRightColsContainer();
        this.eFloatingTopContainer = this.gridPanel.getFloatingTopContainer();
        this.eFloatingTopPinnedLeftContainer = this.gridPanel.getPinnedLeftFloatingTop();
        this.eFloatingTopPinnedRightContainer = this.gridPanel.getPinnedRightFloatingTop();
        this.eFloatingBottomContainer = this.gridPanel.getFloatingBottomContainer();
        this.eFloatingBottomPinnedLeftContainer = this.gridPanel.getPinnedLeftFloatingBottom();
        this.eFloatingBottomPinnedRightContainer = this.gridPanel.getPinnedRightFloatingBottom();
        this.eBodyViewport = this.gridPanel.getBodyViewport();
        this.eAllBodyContainers = [this.eBodyContainer, this.eFloatingBottomContainer,
            this.eFloatingTopContainer];
        this.eAllPinnedLeftContainers = [
            this.ePinnedLeftColsContainer,
            this.eFloatingBottomPinnedLeftContainer,
            this.eFloatingTopPinnedLeftContainer];
        this.eAllPinnedRightContainers = [
            this.ePinnedRightColsContainer,
            this.eFloatingBottomPinnedRightContainer,
            this.eFloatingTopPinnedRightContainer];
    };
    RowRenderer.prototype.setRowModel = function (rowModel) {
        this.rowModel = rowModel;
    };
    RowRenderer.prototype.getAllCellsForColumn = function (column) {
        var eCells = [];
        utils_1.Utils.iterateObject(this.renderedRows, callback);
        utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
        utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
        function callback(key, renderedRow) {
            var eCell = renderedRow.getCellForCol(column);
            if (eCell) {
                eCells.push(eCell);
            }
        }
        return eCells;
    };
    RowRenderer.prototype.setMainRowWidths = function () {
        var mainRowWidth = this.columnController.getBodyContainerWidth() + "px";
        this.eAllBodyContainers.forEach(function (container) {
            var unpinnedRows = container.querySelectorAll(".ag-row");
            for (var i = 0; i < unpinnedRows.length; i++) {
                unpinnedRows[i].style.width = mainRowWidth;
            }
        });
    };
    RowRenderer.prototype.refreshAllFloatingRows = function () {
        this.refreshFloatingRows(this.renderedTopFloatingRows, this.floatingRowModel.getFloatingTopRowData(), this.eFloatingTopPinnedLeftContainer, this.eFloatingTopPinnedRightContainer, this.eFloatingTopContainer);
        this.refreshFloatingRows(this.renderedBottomFloatingRows, this.floatingRowModel.getFloatingBottomRowData(), this.eFloatingBottomPinnedLeftContainer, this.eFloatingBottomPinnedRightContainer, this.eFloatingBottomContainer);
    };
    RowRenderer.prototype.refreshFloatingRows = function (renderedRows, rowNodes, pinnedLeftContainer, pinnedRightContainer, bodyContainer) {
        var _this = this;
        renderedRows.forEach(function (row) {
            row.destroy();
        });
        renderedRows.length = 0;
        // if no cols, don't draw row - can we get rid of this???
        var columns = this.columnController.getAllDisplayedColumns();
        if (!columns || columns.length == 0) {
            return;
        }
        if (rowNodes) {
            rowNodes.forEach(function (node, rowIndex) {
                var renderedRow = new renderedRow_1.RenderedRow(_this.$scope, _this, bodyContainer, pinnedLeftContainer, pinnedRightContainer, node, rowIndex);
                _this.context.wireBean(renderedRow);
                renderedRows.push(renderedRow);
            });
        }
    };
    RowRenderer.prototype.refreshView = function (refreshEvent) {
        this.logger.log('refreshView');
        var focusedCell = this.focusedCellController.getFocusCellIfBrowserFocused();
        this.focusedCellController.getFocusedCell();
        var refreshFromIndex = refreshEvent ? refreshEvent.fromIndex : null;
        if (!this.gridOptionsWrapper.isForPrint()) {
            var containerHeight = this.rowModel.getRowCombinedHeight();
            this.eBodyContainer.style.height = containerHeight + "px";
            this.ePinnedLeftColsContainer.style.height = containerHeight + "px";
            this.ePinnedRightColsContainer.style.height = containerHeight + "px";
        }
        this.refreshAllVirtualRows(refreshFromIndex);
        this.refreshAllFloatingRows();
        this.restoreFocusedCell(focusedCell);
    };
    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
    // edited cell).
    RowRenderer.prototype.restoreFocusedCell = function (gridCell) {
        if (gridCell) {
            this.focusedCellController.setFocusedCell(gridCell.rowIndex, gridCell.column, gridCell.floating, true);
        }
    };
    RowRenderer.prototype.softRefreshView = function () {
        var focusedCell = this.focusedCellController.getFocusCellIfBrowserFocused();
        this.forEachRenderedCell(function (renderedCell) {
            if (renderedCell.isVolatile()) {
                renderedCell.refreshCell();
            }
        });
        this.restoreFocusedCell(focusedCell);
    };
    RowRenderer.prototype.stopEditing = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        this.forEachRenderedCell(function (renderedCell) {
            renderedCell.stopEditing(cancel);
        });
    };
    RowRenderer.prototype.forEachRenderedCell = function (callback) {
        utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
            renderedRow.forEachRenderedCell(callback);
        });
    };
    RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
        var renderedRow = this.renderedRows[rowIndex];
        renderedRow.addEventListener(eventName, callback);
    };
    RowRenderer.prototype.refreshRows = function (rowNodes) {
        if (!rowNodes || rowNodes.length == 0) {
            return;
        }
        var focusedCell = this.focusedCellController.getFocusCellIfBrowserFocused();
        // we only need to be worried about rendered rows, as this method is
        // called to whats rendered. if the row isn't rendered, we don't care
        var indexesToRemove = [];
        utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
            var rowNode = renderedRow.getRowNode();
            if (rowNodes.indexOf(rowNode) >= 0) {
                indexesToRemove.push(key);
            }
        });
        // remove the rows
        this.removeVirtualRow(indexesToRemove);
        // add draw them again
        this.drawVirtualRows();
        this.restoreFocusedCell(focusedCell);
    };
    RowRenderer.prototype.refreshCells = function (rowNodes, colIds, animate) {
        if (animate === void 0) { animate = false; }
        if (!rowNodes || rowNodes.length == 0) {
            return;
        }
        // we only need to be worried about rendered rows, as this method is
        // called to whats rendered. if the row isn't rendered, we don't care
        utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
            var rowNode = renderedRow.getRowNode();
            if (rowNodes.indexOf(rowNode) >= 0) {
                renderedRow.refreshCells(colIds, animate);
            }
        });
    };
    RowRenderer.prototype.rowDataChanged = function (rows) {
        // we only need to be worried about rendered rows, as this method is
        // called to whats rendered. if the row isn't rendered, we don't care
        var indexesToRemove = [];
        var renderedRows = this.renderedRows;
        Object.keys(renderedRows).forEach(function (key) {
            var renderedRow = renderedRows[key];
            // see if the rendered row is in the list of rows we have to update
            if (renderedRow.isDataInList(rows)) {
                indexesToRemove.push(key);
            }
        });
        // remove the rows
        this.removeVirtualRow(indexesToRemove);
        // add draw them again
        this.drawVirtualRows();
    };
    RowRenderer.prototype.destroy = function () {
        var rowsToRemove = Object.keys(this.renderedRows);
        this.removeVirtualRow(rowsToRemove);
    };
    RowRenderer.prototype.refreshAllVirtualRows = function (fromIndex) {
        // remove all current virtual rows, as they have old data
        var rowsToRemove = Object.keys(this.renderedRows);
        this.removeVirtualRow(rowsToRemove, fromIndex);
        // add in new rows
        this.drawVirtualRows();
    };
    // public - removes the group rows and then redraws them again
    RowRenderer.prototype.refreshGroupRows = function () {
        // find all the group rows
        var rowsToRemove = [];
        var that = this;
        Object.keys(this.renderedRows).forEach(function (key) {
            var renderedRow = that.renderedRows[key];
            if (renderedRow.isGroup()) {
                rowsToRemove.push(key);
            }
        });
        // remove the rows
        this.removeVirtualRow(rowsToRemove);
        // and draw them back again
        this.ensureRowsRendered();
    };
    // takes array of row indexes
    RowRenderer.prototype.removeVirtualRow = function (rowsToRemove, fromIndex) {
        var that = this;
        // if no fromIndex then set to -1, which will refresh everything
        var realFromIndex = (typeof fromIndex === 'number') ? fromIndex : -1;
        rowsToRemove.forEach(function (indexToRemove) {
            if (indexToRemove >= realFromIndex) {
                that.unbindVirtualRow(indexToRemove);
            }
        });
    };
    RowRenderer.prototype.unbindVirtualRow = function (indexToRemove) {
        var renderedRow = this.renderedRows[indexToRemove];
        renderedRow.destroy();
        var event = { node: renderedRow.getRowNode(), rowIndex: indexToRemove };
        this.eventService.dispatchEvent(events_1.Events.EVENT_VIRTUAL_ROW_REMOVED, event);
        delete this.renderedRows[indexToRemove];
    };
    RowRenderer.prototype.drawVirtualRows = function () {
        this.workOutFirstAndLastRowsToRender();
        this.ensureRowsRendered();
    };
    RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {
        var newFirst;
        var newLast;
        if (!this.rowModel.isRowsToRender()) {
            newFirst = 0;
            newLast = -1; // setting to -1 means nothing in range
        }
        else {
            var rowCount = this.rowModel.getRowCount();
            if (this.gridOptionsWrapper.isForPrint()) {
                newFirst = 0;
                newLast = rowCount;
            }
            else {
                var topPixel = this.eBodyViewport.scrollTop;
                var bottomPixel = topPixel + this.eBodyViewport.offsetHeight;
                var first = this.rowModel.getRowIndexAtPixel(topPixel);
                var last = this.rowModel.getRowIndexAtPixel(bottomPixel);
                //add in buffer
                var buffer = this.gridOptionsWrapper.getRowBuffer();
                first = first - buffer;
                last = last + buffer;
                // adjust, in case buffer extended actual size
                if (first < 0) {
                    first = 0;
                }
                if (last > rowCount - 1) {
                    last = rowCount - 1;
                }
                newFirst = first;
                newLast = last;
            }
        }
        var firstDiffers = newFirst !== this.firstRenderedRow;
        var lastDiffers = newLast !== this.lastRenderedRow;
        if (firstDiffers || lastDiffers) {
            this.firstRenderedRow = newFirst;
            this.lastRenderedRow = newLast;
            var event = { firstRow: newFirst, lastRow: newLast };
            this.eventService.dispatchEvent(events_1.Events.EVENT_VIEWPORT_CHANGED, event);
        }
    };
    RowRenderer.prototype.getFirstVirtualRenderedRow = function () {
        return this.firstRenderedRow;
    };
    RowRenderer.prototype.getLastVirtualRenderedRow = function () {
        return this.lastRenderedRow;
    };
    RowRenderer.prototype.ensureRowsRendered = function () {
        //var start = new Date().getTime();
        var _this = this;
        // at the end, this array will contain the items we need to remove
        var rowsToRemove = Object.keys(this.renderedRows);
        // add in new rows
        for (var rowIndex = this.firstRenderedRow; rowIndex <= this.lastRenderedRow; rowIndex++) {
            // see if item already there, and if yes, take it out of the 'to remove' array
            if (rowsToRemove.indexOf(rowIndex.toString()) >= 0) {
                rowsToRemove.splice(rowsToRemove.indexOf(rowIndex.toString()), 1);
                continue;
            }
            // check this row actually exists (in case overflow buffer window exceeds real data)
            var node = this.rowModel.getRow(rowIndex);
            if (node) {
                this.insertRow(node, rowIndex);
            }
        }
        // at this point, everything in our 'rowsToRemove' . . .
        this.removeVirtualRow(rowsToRemove);
        // if we are doing angular compiling, then do digest the scope here
        if (this.gridOptionsWrapper.isAngularCompileRows()) {
            // we do it in a timeout, in case we are already in an apply
            setTimeout(function () { _this.$scope.$apply(); }, 0);
        }
        //var end = new Date().getTime();
        //console.log(end-start);
    };
    RowRenderer.prototype.onMouseEvent = function (eventName, mouseEvent, eventSource, cell) {
        var renderedRow;
        switch (cell.floating) {
            case constants_1.Constants.FLOATING_TOP:
                renderedRow = this.renderedTopFloatingRows[cell.rowIndex];
                break;
            case constants_1.Constants.FLOATING_BOTTOM:
                renderedRow = this.renderedBottomFloatingRows[cell.rowIndex];
                break;
            default:
                renderedRow = this.renderedRows[cell.rowIndex];
                break;
        }
        if (renderedRow) {
            renderedRow.onMouseEvent(eventName, mouseEvent, eventSource, cell);
        }
    };
    RowRenderer.prototype.insertRow = function (node, rowIndex) {
        var columns = this.columnController.getAllDisplayedColumns();
        // if no cols, don't draw row
        if (!columns || columns.length == 0) {
            return;
        }
        var renderedRow = new renderedRow_1.RenderedRow(this.$scope, this, this.eBodyContainer, this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, node, rowIndex);
        this.context.wireBean(renderedRow);
        this.renderedRows[rowIndex] = renderedRow;
    };
    RowRenderer.prototype.getRenderedNodes = function () {
        var renderedRows = this.renderedRows;
        return Object.keys(renderedRows).map(function (key) {
            return renderedRows[key].getRowNode();
        });
    };
    // we use index for rows, but column object for columns, as the next column (by index) might not
    // be visible (header grouping) so it's not reliable, so using the column object instead.
    RowRenderer.prototype.navigateToNextCell = function (key, rowIndex, column, floating) {
        var nextCell = new gridCell_1.GridCell(rowIndex, floating, column);
        // we keep searching for a next cell until we find one. this is how the group rows get skipped
        while (true) {
            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
            if (utils_1.Utils.missing(nextCell)) {
                break;
            }
            var skipGroupRows = this.gridOptionsWrapper.isGroupUseEntireRow();
            if (skipGroupRows) {
                var rowNode = this.rowModel.getRow(nextCell.rowIndex);
                if (!rowNode.group) {
                    break;
                }
            }
            else {
                break;
            }
        }
        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid
        if (!nextCell) {
            return;
        }
        // this scrolls the row into view
        if (utils_1.Utils.missing(nextCell.floating)) {
            this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
        }
        if (!nextCell.column.isPinned()) {
            this.gridPanel.ensureColumnVisible(nextCell.column);
        }
        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
        // floating cell, the scrolls get out of sync
        this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
        this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.floating, true);
        if (this.rangeController) {
            this.rangeController.setRangeToCell(new gridCell_1.GridCell(nextCell.rowIndex, nextCell.floating, nextCell.column));
        }
    };
    RowRenderer.prototype.getComponentForCell = function (gridCell) {
        var rowComponent;
        switch (gridCell.floating) {
            case constants_1.Constants.FLOATING_TOP:
                rowComponent = this.renderedTopFloatingRows[gridCell.rowIndex];
                break;
            case constants_1.Constants.FLOATING_BOTTOM:
                rowComponent = this.renderedBottomFloatingRows[gridCell.rowIndex];
                break;
            default:
                rowComponent = this.renderedRows[gridCell.rowIndex];
                break;
        }
        if (!rowComponent) {
            return null;
        }
        var cellComponent = rowComponent.getRenderedCellForColumn(gridCell.column);
        return cellComponent;
    };
    // called by the cell, when tab is pressed while editing.
    // @return: true when navigation successful, otherwise false
    RowRenderer.prototype.moveFocusToNextCell = function (rowIndex, column, floating, shiftKey, startEditing) {
        var nextCell = new gridCell_1.GridCell(rowIndex, floating, column);
        while (true) {
            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, shiftKey);
            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,
            // so bottom right cell going forwards, or top left going backwards
            if (!nextCell) {
                return false;
            }
            var nextRenderedCell = this.getComponentForCell(nextCell);
            // if editing, but cell not editable, skip cell
            if (startEditing && !nextRenderedCell.isCellEditable()) {
                continue;
            }
            // this scrolls the row into view
            var cellIsNotFloating = utils_1.Utils.missing(nextCell.floating);
            if (cellIsNotFloating) {
                this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
            }
            this.gridPanel.ensureColumnVisible(nextCell.column);
            // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
            // floating cell, the scrolls get out of sync
            this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
            if (startEditing) {
                nextRenderedCell.startEditingIfEnabled();
                nextRenderedCell.focusCell(false);
            }
            else {
                nextRenderedCell.focusCell(true);
            }
            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation
            // consistent, we set into range here also.
            if (this.rangeController) {
                this.rangeController.setRangeToCell(new gridCell_1.GridCell(nextCell.rowIndex, nextCell.floating, nextCell.column));
            }
            // we successfully tabbed onto a grid cell, so return true
            return true;
        }
    };
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], RowRenderer.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], RowRenderer.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('gridCore'), 
        __metadata('design:type', gridCore_1.GridCore)
    ], RowRenderer.prototype, "gridCore", void 0);
    __decorate([
        context_1.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], RowRenderer.prototype, "gridPanel", void 0);
    __decorate([
        context_1.Autowired('$compile'), 
        __metadata('design:type', Object)
    ], RowRenderer.prototype, "$compile", void 0);
    __decorate([
        context_1.Autowired('$scope'), 
        __metadata('design:type', Object)
    ], RowRenderer.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('expressionService'), 
        __metadata('design:type', expressionService_1.ExpressionService)
    ], RowRenderer.prototype, "expressionService", void 0);
    __decorate([
        context_1.Autowired('templateService'), 
        __metadata('design:type', templateService_1.TemplateService)
    ], RowRenderer.prototype, "templateService", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], RowRenderer.prototype, "valueService", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], RowRenderer.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('floatingRowModel'), 
        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
    ], RowRenderer.prototype, "floatingRowModel", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], RowRenderer.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('loggerFactory'), 
        __metadata('design:type', logger_1.LoggerFactory)
    ], RowRenderer.prototype, "loggerFactory", void 0);
    __decorate([
        context_1.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], RowRenderer.prototype, "rowModel", void 0);
    __decorate([
        context_1.Autowired('focusedCellController'), 
        __metadata('design:type', focusedCellController_1.FocusedCellController)
    ], RowRenderer.prototype, "focusedCellController", void 0);
    __decorate([
        context_1.Optional('rangeController'), 
        __metadata('design:type', Object)
    ], RowRenderer.prototype, "rangeController", void 0);
    __decorate([
        context_1.Autowired('cellNavigationService'), 
        __metadata('design:type', cellNavigationService_1.CellNavigationService)
    ], RowRenderer.prototype, "cellNavigationService", void 0);
    __decorate([
        __param(0, context_1.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], RowRenderer.prototype, "agWire", null);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], RowRenderer.prototype, "init", null);
    __decorate([
        context_1.PreDestroy, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], RowRenderer.prototype, "destroy", null);
    RowRenderer = __decorate([
        context_1.Bean('rowRenderer'), 
        __metadata('design:paramtypes', [])
    ], RowRenderer);
    return RowRenderer;
})();
exports.RowRenderer = RowRenderer;

},{"../cellNavigationService":73,"../columnController/columnController":77,"../constants":86,"../context/context":87,"../entities/gridCell":94,"../eventService":98,"../events":99,"../expressionService":100,"../focusedCellController":104,"../gridCore":108,"../gridOptionsWrapper":109,"../gridPanel/gridPanel":110,"../logger":124,"../rowControllers/floatingRowModel":145,"../templateService":155,"../utils":156,"../valueService":157,"./renderedRow":142}],144:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../context/context");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var ValueFormatterService = (function () {
    function ValueFormatterService() {
    }
    ValueFormatterService.prototype.formatValue = function (column, rowNode, $scope, rowIndex, value) {
        var formatter;
        var colDef = column.getColDef();
        // if floating, give preference to the floating formatter
        if (rowNode.floating) {
            formatter = colDef.floatingCellFormatter ? colDef.floatingCellFormatter : colDef.cellFormatter;
        }
        else {
            formatter = colDef.cellFormatter;
        }
        var result = null;
        if (formatter) {
            var params = {
                value: value,
                node: rowNode,
                column: column,
                $scope: $scope,
                rowIndex: rowIndex,
                api: this.gridOptionsWrapper.getApi(),
                context: this.gridOptionsWrapper.getContext()
            };
            result = formatter(params);
        }
        return result;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], ValueFormatterService.prototype, "gridOptionsWrapper", void 0);
    ValueFormatterService = __decorate([
        context_1.Bean('valueFormatterService'), 
        __metadata('design:paramtypes', [])
    ], ValueFormatterService);
    return ValueFormatterService;
})();
exports.ValueFormatterService = ValueFormatterService;

},{"../context/context":87,"../gridOptionsWrapper":109}],145:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var rowNode_1 = require("../entities/rowNode");
var context_1 = require("../context/context");
var eventService_1 = require("../eventService");
var context_2 = require("../context/context");
var events_1 = require("../events");
var context_3 = require("../context/context");
var constants_1 = require("../constants");
var utils_1 = require('../utils');
var FloatingRowModel = (function () {
    function FloatingRowModel() {
    }
    FloatingRowModel.prototype.init = function () {
        this.setFloatingTopRowData(this.gridOptionsWrapper.getFloatingTopRowData());
        this.setFloatingBottomRowData(this.gridOptionsWrapper.getFloatingBottomRowData());
    };
    FloatingRowModel.prototype.isEmpty = function (floating) {
        var rows = floating === constants_1.Constants.FLOATING_TOP ? this.floatingTopRows : this.floatingBottomRows;
        return utils_1.Utils.missingOrEmpty(rows);
    };
    FloatingRowModel.prototype.isRowsToRender = function (floating) {
        return !this.isEmpty(floating);
    };
    FloatingRowModel.prototype.getRowAtPixel = function (pixel, floating) {
        var rows = floating === constants_1.Constants.FLOATING_TOP ? this.floatingTopRows : this.floatingBottomRows;
        if (utils_1.Utils.missingOrEmpty(rows)) {
            return 0; // this should never happen, just in case, 0 is graceful failure
        }
        for (var i = 0; i < rows.length; i++) {
            var rowNode = rows[i];
            var rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
            // only need to range check against the top pixel, as we are going through the list
            // in order, first row to hit the pixel wins
            if (rowTopPixel >= pixel) {
                return i;
            }
        }
        return rows.length - 1;
    };
    FloatingRowModel.prototype.setFloatingTopRowData = function (rowData) {
        this.floatingTopRows = this.createNodesFromData(rowData, true);
        this.eventService.dispatchEvent(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED);
    };
    FloatingRowModel.prototype.setFloatingBottomRowData = function (rowData) {
        this.floatingBottomRows = this.createNodesFromData(rowData, false);
        this.eventService.dispatchEvent(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED);
    };
    FloatingRowModel.prototype.createNodesFromData = function (allData, isTop) {
        var _this = this;
        var rowNodes = [];
        if (allData) {
            var nextRowTop = 0;
            allData.forEach(function (dataItem) {
                var rowNode = new rowNode_1.RowNode();
                _this.context.wireBean(rowNode);
                rowNode.data = dataItem;
                rowNode.floating = isTop ? constants_1.Constants.FLOATING_TOP : constants_1.Constants.FLOATING_BOTTOM;
                rowNode.rowTop = nextRowTop;
                rowNode.rowHeight = _this.gridOptionsWrapper.getRowHeightForNode(rowNode);
                nextRowTop += rowNode.rowHeight;
                rowNodes.push(rowNode);
            });
        }
        return rowNodes;
    };
    FloatingRowModel.prototype.getFloatingTopRowData = function () {
        return this.floatingTopRows;
    };
    FloatingRowModel.prototype.getFloatingBottomRowData = function () {
        return this.floatingBottomRows;
    };
    FloatingRowModel.prototype.getFloatingTopTotalHeight = function () {
        return this.getTotalHeight(this.floatingTopRows);
    };
    FloatingRowModel.prototype.getFloatingBottomTotalHeight = function () {
        return this.getTotalHeight(this.floatingBottomRows);
    };
    FloatingRowModel.prototype.getTotalHeight = function (rowNodes) {
        if (!rowNodes || rowNodes.length === 0) {
            return 0;
        }
        else {
            var lastNode = rowNodes[rowNodes.length - 1];
            return lastNode.rowTop + lastNode.rowHeight;
        }
    };
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], FloatingRowModel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_2.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], FloatingRowModel.prototype, "eventService", void 0);
    __decorate([
        context_2.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], FloatingRowModel.prototype, "context", void 0);
    __decorate([
        context_3.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], FloatingRowModel.prototype, "init", null);
    FloatingRowModel = __decorate([
        context_1.Bean('floatingRowModel'), 
        __metadata('design:paramtypes', [])
    ], FloatingRowModel);
    return FloatingRowModel;
})();
exports.FloatingRowModel = FloatingRowModel;

},{"../constants":86,"../context/context":87,"../entities/rowNode":97,"../eventService":98,"../events":99,"../gridOptionsWrapper":109,"../utils":156}],146:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../../context/context");
var context_2 = require("../../context/context");
var gridOptionsWrapper_1 = require("../../gridOptionsWrapper");
var filterManager_1 = require("../../filter/filterManager");
var FilterStage = (function () {
    function FilterStage() {
    }
    FilterStage.prototype.execute = function (rowNode) {
        var filterActive;
        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
            filterActive = false;
        }
        else {
            filterActive = this.filterManager.isAnyFilterPresent();
        }
        this.recursivelyFilter(rowNode, filterActive);
    };
    FilterStage.prototype.recursivelyFilter = function (rowNode, filterActive) {
        var _this = this;
        // recursively get all children that are groups to also filter
        rowNode.childrenAfterGroup.forEach(function (child) {
            if (child.group) {
                _this.recursivelyFilter(child, filterActive);
            }
        });
        // result of filter for this node
        var filterResult;
        if (filterActive) {
            filterResult = [];
            rowNode.childrenAfterGroup.forEach(function (childNode) {
                if (childNode.group) {
                    // a group is included in the result if it has any children of it's own.
                    // by this stage, the child groups are already filtered
                    if (childNode.childrenAfterFilter.length > 0) {
                        filterResult.push(childNode);
                    }
                }
                else {
                    // a leaf level node is included if it passes the filter
                    if (_this.filterManager.doesRowPassFilter(childNode)) {
                        filterResult.push(childNode);
                    }
                }
            });
        }
        else {
            // if not filtering, the result is the original list
            filterResult = rowNode.childrenAfterGroup;
        }
        rowNode.childrenAfterFilter = filterResult;
        this.setAllChildrenCount(rowNode);
    };
    FilterStage.prototype.setAllChildrenCount = function (rowNode) {
        var allChildrenCount = 0;
        rowNode.childrenAfterFilter.forEach(function (child) {
            if (child.group) {
                allChildrenCount += child.allChildrenCount;
            }
            else {
                allChildrenCount++;
            }
        });
        rowNode.allChildrenCount = allChildrenCount;
    };
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], FilterStage.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_2.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], FilterStage.prototype, "filterManager", void 0);
    FilterStage = __decorate([
        context_1.Bean('filterStage'), 
        __metadata('design:paramtypes', [])
    ], FilterStage);
    return FilterStage;
})();
exports.FilterStage = FilterStage;

},{"../../context/context":87,"../../filter/filterManager":101,"../../gridOptionsWrapper":109}],147:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../../context/context");
var rowNode_1 = require("../../entities/rowNode");
var utils_1 = require("../../utils");
var gridOptionsWrapper_1 = require("../../gridOptionsWrapper");
var selectionController_1 = require("../../selectionController");
var eventService_1 = require("../../eventService");
var columnController_1 = require("../../columnController/columnController");
var FlattenStage = (function () {
    function FlattenStage() {
    }
    FlattenStage.prototype.execute = function (rootNode) {
        // even if not doing grouping, we do the mapping, as the client might
        // of passed in data that already has a grouping in it somewhere
        var result = [];
        // putting value into a wrapper so it's passed by reference
        var nextRowTop = { value: 0 };
        // if we are reducing, and not grouping, then we want to show the root node, as that
        // is where the pivot values are
        var showRootNode = this.columnController.isReduce() && rootNode.leafGroup;
        var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
        this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop);
        return result;
    };
    FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop) {
        if (utils_1.Utils.missingOrEmpty(rowsToFlatten)) {
            return;
        }
        var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();
        for (var i = 0; i < rowsToFlatten.length; i++) {
            var rowNode = rowsToFlatten[i];
            var skipGroupNode = groupSuppressRow && rowNode.group;
            if (!skipGroupNode) {
                this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop);
            }
            if (rowNode.group && rowNode.expanded) {
                this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop);
                // put a footer in if user is looking for it
                if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
                    var footerNode = this.createFooterNode(rowNode);
                    this.addRowNodeToRowsToDisplay(footerNode, result, nextRowTop);
                }
            }
        }
    };
    // duplicated method, it's also in floatingRowModel
    FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop) {
        result.push(rowNode);
        rowNode.rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);
        rowNode.rowTop = nextRowTop.value;
        nextRowTop.value += rowNode.rowHeight;
    };
    FlattenStage.prototype.createFooterNode = function (groupNode) {
        var footerNode = new rowNode_1.RowNode();
        this.context.wireBean(footerNode);
        Object.keys(groupNode).forEach(function (key) {
            footerNode[key] = groupNode[key];
        });
        footerNode.footer = true;
        // get both header and footer to reference each other as siblings. this is never undone,
        // only overwritten. so if a group is expanded, then contracted, it will have a ghost
        // sibling - but that's fine, as we can ignore this if the header is contracted.
        footerNode.sibling = groupNode;
        groupNode.sibling = footerNode;
        return footerNode;
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], FlattenStage.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], FlattenStage.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], FlattenStage.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], FlattenStage.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], FlattenStage.prototype, "columnController", void 0);
    FlattenStage = __decorate([
        context_1.Bean('flattenStage'), 
        __metadata('design:paramtypes', [])
    ], FlattenStage);
    return FlattenStage;
})();
exports.FlattenStage = FlattenStage;

},{"../../columnController/columnController":77,"../../context/context":87,"../../entities/rowNode":97,"../../eventService":98,"../../gridOptionsWrapper":109,"../../selectionController":152,"../../utils":156}],148:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../../utils");
var constants_1 = require("../../constants");
var gridOptionsWrapper_1 = require("../../gridOptionsWrapper");
var columnController_1 = require("../../columnController/columnController");
var filterManager_1 = require("../../filter/filterManager");
var rowNode_1 = require("../../entities/rowNode");
var eventService_1 = require("../../eventService");
var events_1 = require("../../events");
var context_1 = require("../../context/context");
var selectionController_1 = require("../../selectionController");
var pivotService_1 = require("../../columnController/pivotService");
var RecursionType;
(function (RecursionType) {
    RecursionType[RecursionType["Normal"] = 0] = "Normal";
    RecursionType[RecursionType["AfterFilter"] = 1] = "AfterFilter";
    RecursionType[RecursionType["AfterFilterAndSort"] = 2] = "AfterFilterAndSort";
})(RecursionType || (RecursionType = {}));
;
var InMemoryRowModel = (function () {
    function InMemoryRowModel() {
    }
    InMemoryRowModel.prototype.init = function () {
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_EVERYTHING));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_EVERYTHING));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_AGGREGATE));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_PIVOT));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_FILTER_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_FILTER));
        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_SORT_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_SORT));
        this.rootNode = new rowNode_1.RowNode();
        this.rootNode.group = true;
        this.rootNode.allLeafChildren = [];
        this.context.wireBean(this.rootNode);
        if (this.gridOptionsWrapper.isRowModelDefault()) {
            this.setRowData(this.gridOptionsWrapper.getRowData(), this.columnController.isReady());
        }
    };
    InMemoryRowModel.prototype.getType = function () {
        return constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
    };
    InMemoryRowModel.prototype.refreshModel = function (step, fromIndex, groupState) {
        // this goes through the pipeline of stages. what's in my head is similar
        // to the diagram on this page:
        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html
        // however we want to keep the results of each stage, hence we manually call
        // each step rather than have them chain each other.
        var _this = this;
        // fallthrough in below switch is on purpose,
        // eg if STEP_FILTER, then all steps below this
        // step get done
        // var start: number;
        // console.log('======= start =======');
        switch (step) {
            case constants_1.Constants.STEP_EVERYTHING:
                // start = new Date().getTime();
                this.doRowGrouping(groupState);
            // console.log('rowGrouping = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_FILTER:
                // start = new Date().getTime();
                this.doFilter();
            // console.log('filter = ' + (new Date().getTime() - start));
            // case constants.STEP_PIVOT:
            //     this.doPivot();
            case constants_1.Constants.STEP_AGGREGATE:
                // start = new Date().getTime();
                this.doAggregate();
            // console.log('aggregation = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_SORT:
                // start = new Date().getTime();
                this.doSort();
            // console.log('sort = ' + (new Date().getTime() - start));
            case constants_1.Constants.STEP_MAP:
                // start = new Date().getTime();
                this.doRowsToDisplay();
        }
        this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED, { fromIndex: fromIndex });
        if (this.$scope) {
            setTimeout(function () {
                _this.$scope.$apply();
            }, 0);
        }
    };
    InMemoryRowModel.prototype.isEmpty = function () {
        return utils_1.Utils.missing(this.rootNode) || utils_1.Utils.missing(this.rootNode.allLeafChildren)
            || this.rootNode.allLeafChildren.length === 0 || !this.columnController.isReady();
    };
    InMemoryRowModel.prototype.isRowsToRender = function () {
        return utils_1.Utils.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
    };
    InMemoryRowModel.prototype.setDatasource = function (datasource) {
        console.error('ag-Grid: should never call setDatasource on inMemoryRowController');
    };
    InMemoryRowModel.prototype.getTopLevelNodes = function () {
        return this.rootNode ? this.rootNode.childrenAfterGroup : null;
    };
    InMemoryRowModel.prototype.getRow = function (index) {
        return this.rowsToDisplay[index];
    };
    InMemoryRowModel.prototype.getVirtualRowCount = function () {
        console.warn('ag-Grid: rowModel.getVirtualRowCount() is not longer a function, use rowModel.getRowCount() instead');
        return this.getRowCount();
    };
    InMemoryRowModel.prototype.getRowCount = function () {
        if (this.rowsToDisplay) {
            return this.rowsToDisplay.length;
        }
        else {
            return 0;
        }
    };
    InMemoryRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {
        if (this.isEmpty()) {
            return -1;
        }
        // do binary search of tree
        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
        var bottomPointer = 0;
        var topPointer = this.rowsToDisplay.length - 1;
        // quick check, if the pixel is out of bounds, then return last row
        if (pixelToMatch <= 0) {
            // if pixel is less than or equal zero, it's always the first row
            return 0;
        }
        var lastNode = this.rowsToDisplay[this.rowsToDisplay.length - 1];
        if (lastNode.rowTop <= pixelToMatch) {
            return this.rowsToDisplay.length - 1;
        }
        while (true) {
            var midPointer = Math.floor((bottomPointer + topPointer) / 2);
            var currentRowNode = this.rowsToDisplay[midPointer];
            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
                return midPointer;
            }
            else if (currentRowNode.rowTop < pixelToMatch) {
                bottomPointer = midPointer + 1;
            }
            else if (currentRowNode.rowTop > pixelToMatch) {
                topPointer = midPointer - 1;
            }
        }
    };
    InMemoryRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {
        var topPixel = rowNode.rowTop;
        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;
        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
        return pixelInRow;
    };
    InMemoryRowModel.prototype.getRowCombinedHeight = function () {
        if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {
            var lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];
            var lastPixel = lastRow.rowTop + lastRow.rowHeight;
            return lastPixel;
        }
        else {
            return 0;
        }
    };
    InMemoryRowModel.prototype.forEachLeafNode = function (callback) {
        if (this.rootNode.allLeafChildren) {
            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });
        }
    };
    InMemoryRowModel.prototype.forEachNode = function (callback) {
        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);
    };
    InMemoryRowModel.prototype.forEachNodeAfterFilter = function (callback) {
        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);
    };
    InMemoryRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {
        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);
    };
    // iterates through each item in memory, and calls the callback function
    // nodes - the rowNodes to traverse
    // callback - the user provided callback
    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
    // index - works similar to the index in forEach in javascripts array function
    InMemoryRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {
        if (nodes) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                callback(node, index++);
                // go to the next level if it is a group
                if (node.group) {
                    // depending on the recursion type, we pick a difference set of children
                    var nodeChildren;
                    switch (recursionType) {
                        case RecursionType.Normal:
                            nodeChildren = node.childrenAfterGroup;
                            break;
                        case RecursionType.AfterFilter:
                            nodeChildren = node.childrenAfterFilter;
                            break;
                        case RecursionType.AfterFilterAndSort:
                            nodeChildren = node.childrenAfterSort;
                            break;
                    }
                    if (nodeChildren) {
                        index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);
                    }
                }
            }
        }
        return index;
    };
    // it's possible to recompute the aggregate without doing the other parts
    // + gridApi.recomputeAggregates()
    InMemoryRowModel.prototype.doAggregate = function () {
        if (this.aggregationStage) {
            this.aggregationStage.execute(this.rootNode);
        }
    };
    // + gridApi.expandAll()
    // + gridApi.collapseAll()
    InMemoryRowModel.prototype.expandOrCollapseAll = function (expand) {
        if (this.rootNode) {
            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
        }
        function recursiveExpandOrCollapse(rowNodes) {
            if (!rowNodes) {
                return;
            }
            rowNodes.forEach(function (rowNode) {
                if (rowNode.group) {
                    rowNode.expanded = expand;
                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
                }
            });
        }
        this.refreshModel(constants_1.Constants.STEP_MAP);
    };
    InMemoryRowModel.prototype.doSort = function () {
        this.sortStage.execute(this.rootNode);
    };
    InMemoryRowModel.prototype.doRowGrouping = function (groupState) {
        // grouping is enterprise only, so if service missing, skip the step
        var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
        if (rowsAlreadyGrouped) {
            return;
        }
        if (this.groupStage) {
            // remove old groups from the selection model, as we are about to replace them
            // with new groups
            this.selectionController.removeGroupsFromSelection();
            this.groupStage.execute(this.rootNode);
            this.restoreGroupState(groupState);
            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {
                this.selectionController.updateGroupsFromChildrenSelections();
            }
        }
        else {
            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
        }
    };
    InMemoryRowModel.prototype.restoreGroupState = function (groupState) {
        if (!groupState) {
            return;
        }
        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {
            // if the group was open last time, then open it this time. however
            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'
            // setting will take effect.
            if (typeof groupState[key] === 'boolean') {
                node.expanded = groupState[key];
            }
        });
    };
    InMemoryRowModel.prototype.doFilter = function () {
        this.filterStage.execute(this.rootNode);
    };
    InMemoryRowModel.prototype.doPivot = function () {
        this.pivotService.execute(this.rootNode);
        // fire event here???
        // pivotService.createPivotColumns()
        // do pivot - create pivot columns?
    };
    // rows: the rows to put into the model
    // firstId: the first id to use, used for paging, where we are not on the first page
    InMemoryRowModel.prototype.setRowData = function (rowData, refresh, firstId) {
        // remember group state, so we can expand groups that should be expanded
        var groupState = this.getGroupState();
        // place each row into a wrapper
        this.createRowNodesFromData(rowData, firstId);
        // this event kicks off:
        // - clears selection
        // - updates filters
        // - shows 'no rows' overlay if needed
        this.eventService.dispatchEvent(events_1.Events.EVENT_ROW_DATA_CHANGED);
        if (refresh) {
            this.refreshModel(constants_1.Constants.STEP_EVERYTHING, null, groupState);
        }
    };
    InMemoryRowModel.prototype.getGroupState = function () {
        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {
            return null;
        }
        var result = {};
        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });
        return result;
    };
    InMemoryRowModel.prototype.createRowNodesFromData = function (rowData, firstId) {
        this.rootNode.childrenAfterFilter = null;
        this.rootNode.childrenAfterGroup = null;
        this.rootNode.childrenAfterSort = null;
        this.rootNode.childrenMapped = null;
        var context = this.context;
        if (!rowData) {
            this.rootNode.allLeafChildren = [];
            return;
        }
        var rowNodeId = utils_1.Utils.exists(firstId) ? firstId : 0;
        // func below doesn't have 'this' pointer, so need to pull out these bits
        var nodeChildDetailsFunc = this.gridOptionsWrapper.getNodeChildDetailsFunc();
        var suppressParentsInRowNodes = this.gridOptionsWrapper.isSuppressParentsInRowNodes();
        var rowsAlreadyGrouped = utils_1.Utils.exists(nodeChildDetailsFunc);
        // kick off recursion
        var result = recursiveFunction(rowData, null, 0);
        if (rowsAlreadyGrouped) {
            this.rootNode.childrenAfterGroup = result;
            setLeafChildren(this.rootNode);
        }
        else {
            this.rootNode.allLeafChildren = result;
        }
        function setLeafChildren(node) {
            node.allLeafChildren = [];
            if (node.childrenAfterGroup) {
                node.childrenAfterGroup.forEach(function (childAfterGroup) {
                    if (childAfterGroup.group) {
                        if (childAfterGroup.allLeafChildren) {
                            childAfterGroup.allLeafChildren.forEach(function (leafChild) { return node.allLeafChildren.push(leafChild); });
                        }
                    }
                    else {
                        node.allLeafChildren.push(childAfterGroup);
                    }
                });
            }
        }
        function recursiveFunction(rowData, parent, level) {
            var rowNodes = [];
            rowData.forEach(function (dataItem) {
                var node = new rowNode_1.RowNode();
                context.wireBean(node);
                var nodeChildDetails = nodeChildDetailsFunc ? nodeChildDetailsFunc(dataItem) : null;
                if (nodeChildDetails && nodeChildDetails.group) {
                    node.group = true;
                    node.childrenAfterGroup = recursiveFunction(nodeChildDetails.children, node, level + 1);
                    node.expanded = nodeChildDetails.expanded === true;
                    node.field = nodeChildDetails.field;
                    node.key = nodeChildDetails.key;
                    // pull out all the leaf children and add to our node
                    setLeafChildren(node);
                }
                if (parent && !suppressParentsInRowNodes) {
                    node.parent = parent;
                }
                node.level = level;
                node.id = rowNodeId++;
                node.data = dataItem;
                rowNodes.push(node);
            });
            return rowNodes;
        }
    };
    InMemoryRowModel.prototype.doRowsToDisplay = function () {
        // this.rowsToDisplay = this.flattenStage.execute(this.rowsAfterSort);
        this.rowsToDisplay = this.flattenStage.execute(this.rootNode);
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], InMemoryRowModel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], InMemoryRowModel.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], InMemoryRowModel.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('$scope'), 
        __metadata('design:type', Object)
    ], InMemoryRowModel.prototype, "$scope", void 0);
    __decorate([
        context_1.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], InMemoryRowModel.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], InMemoryRowModel.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], InMemoryRowModel.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('pivotService'), 
        __metadata('design:type', pivotService_1.PivotService)
    ], InMemoryRowModel.prototype, "pivotService", void 0);
    __decorate([
        context_1.Autowired('filterStage'), 
        __metadata('design:type', Object)
    ], InMemoryRowModel.prototype, "filterStage", void 0);
    __decorate([
        context_1.Autowired('sortStage'), 
        __metadata('design:type', Object)
    ], InMemoryRowModel.prototype, "sortStage", void 0);
    __decorate([
        context_1.Autowired('flattenStage'), 
        __metadata('design:type', Object)
    ], InMemoryRowModel.prototype, "flattenStage", void 0);
    __decorate([
        context_1.Optional('groupStage'), 
        __metadata('design:type', Object)
    ], InMemoryRowModel.prototype, "groupStage", void 0);
    __decorate([
        context_1.Optional('aggregationStage'), 
        __metadata('design:type', Object)
    ], InMemoryRowModel.prototype, "aggregationStage", void 0);
    __decorate([
        // the rows mapped to rows to display
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], InMemoryRowModel.prototype, "init", null);
    InMemoryRowModel = __decorate([
        context_1.Bean('rowModel'), 
        __metadata('design:paramtypes', [])
    ], InMemoryRowModel);
    return InMemoryRowModel;
})();
exports.InMemoryRowModel = InMemoryRowModel;

},{"../../columnController/columnController":77,"../../columnController/pivotService":82,"../../constants":86,"../../context/context":87,"../../entities/rowNode":97,"../../eventService":98,"../../events":99,"../../filter/filterManager":101,"../../gridOptionsWrapper":109,"../../selectionController":152,"../../utils":156}],149:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("../../context/context");
var gridOptionsWrapper_1 = require("../../gridOptionsWrapper");
var sortController_1 = require("../../sortController");
var valueService_1 = require("../../valueService");
var utils_1 = require("../../utils");
var SortStage = (function () {
    function SortStage() {
    }
    SortStage.prototype.execute = function (rowNode) {
        // var sorting: any;
        var sortOptions;
        // if the sorting is already done by the server, then we should not do it here
        if (!this.gridOptionsWrapper.isEnableServerSideSorting()) {
            sortOptions = this.sortController.getSortForRowController();
        }
        this.sortRowNode(rowNode, sortOptions);
    };
    SortStage.prototype.sortRowNode = function (rowNode, sortOptions) {
        var _this = this;
        // sort any groups recursively
        rowNode.childrenAfterFilter.forEach(function (child) {
            if (child.group) {
                _this.sortRowNode(child, sortOptions);
            }
        });
        rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);
        var sortActive = utils_1.Utils.exists(sortOptions) && sortOptions.length > 0;
        if (sortActive) {
            rowNode.childrenAfterSort.sort(this.compareRowNodes.bind(this, sortOptions));
        }
        this.updateChildIndexes(rowNode);
    };
    SortStage.prototype.compareRowNodes = function (sortOptions, nodeA, nodeB) {
        // Iterate columns, return the first that doesn't match
        for (var i = 0, len = sortOptions.length; i < len; i++) {
            var sortOption = sortOptions[i];
            // var compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);
            var isInverted = sortOption.inverter === -1;
            var valueA = this.valueService.getValue(sortOption.column, nodeA);
            var valueB = this.valueService.getValue(sortOption.column, nodeB);
            var comparatorResult;
            if (sortOption.column.getColDef().comparator) {
                //if comparator provided, use it
                comparatorResult = sortOption.column.getColDef().comparator(valueA, valueB, nodeA, nodeB, isInverted);
            }
            else {
                //otherwise do our own comparison
                comparatorResult = utils_1.Utils.defaultComparator(valueA, valueB);
            }
            if (comparatorResult !== 0) {
                return comparatorResult * sortOption.inverter;
            }
        }
        // All matched, these are identical as far as the sort is concerned:
        return 0;
    };
    SortStage.prototype.updateChildIndexes = function (rowNode) {
        if (utils_1.Utils.missing(rowNode.childrenAfterSort)) {
            return;
        }
        rowNode.childrenAfterSort.forEach(function (child, index) {
            child.firstChild = index === 0;
            child.lastChild = index === rowNode.childrenAfterSort.length - 1;
            child.childIndex = index;
        });
    };
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], SortStage.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('sortController'), 
        __metadata('design:type', sortController_1.SortController)
    ], SortStage.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('valueService'), 
        __metadata('design:type', valueService_1.ValueService)
    ], SortStage.prototype, "valueService", void 0);
    SortStage = __decorate([
        context_1.Bean('sortStage'), 
        __metadata('design:paramtypes', [])
    ], SortStage);
    return SortStage;
})();
exports.SortStage = SortStage;

},{"../../context/context":87,"../../gridOptionsWrapper":109,"../../sortController":153,"../../utils":156,"../../valueService":157}],150:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require('../utils');
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var context_1 = require("../context/context");
var gridPanel_1 = require("../gridPanel/gridPanel");
var selectionController_1 = require("../selectionController");
var context_2 = require("../context/context");
var sortController_1 = require("../sortController");
var context_3 = require("../context/context");
var eventService_1 = require("../eventService");
var events_1 = require("../events");
var filterManager_1 = require("../filter/filterManager");
var constants_1 = require("../constants");
var template = '<div class="ag-paging-panel ag-font-style">' +
    '<span id="pageRowSummaryPanel" class="ag-paging-row-summary-panel">' +
    '<span id="firstRowOnPage"></span>' +
    ' [TO] ' +
    '<span id="lastRowOnPage"></span>' +
    ' [OF] ' +
    '<span id="recordCount"></span>' +
    '</span>' +
    '<span class="ag-paging-page-summary-panel">' +
    '<button type="button" class="ag-paging-button" id="btFirst">[FIRST]</button>' +
    '<button type="button" class="ag-paging-button" id="btPrevious">[PREVIOUS]</button>' +
    '[PAGE] ' +
    '<span id="current"></span>' +
    ' [OF] ' +
    '<span id="total"></span>' +
    '<button type="button" class="ag-paging-button" id="btNext">[NEXT]</button>' +
    '<button type="button" class="ag-paging-button" id="btLast">[LAST]</button>' +
    '</span>' +
    '</div>';
var PaginationController = (function () {
    function PaginationController() {
    }
    PaginationController.prototype.init = function () {
        var _this = this;
        // if we are doing pagination, we are guaranteed that the model type
        // is normal. if it is not, then this paginationController service
        // will never be called.
        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
            this.inMemoryRowModel = this.rowModel;
        }
        this.setupComponents();
        this.callVersion = 0;
        var paginationEnabled = this.gridOptionsWrapper.isRowModelPagination();
        this.eventService.addEventListener(events_1.Events.EVENT_FILTER_CHANGED, function () {
            if (paginationEnabled && _this.gridOptionsWrapper.isEnableServerSideFilter()) {
                _this.reset();
            }
        });
        this.eventService.addEventListener(events_1.Events.EVENT_SORT_CHANGED, function () {
            if (paginationEnabled && _this.gridOptionsWrapper.isEnableServerSideSorting()) {
                _this.reset();
            }
        });
        if (paginationEnabled && this.gridOptionsWrapper.getDatasource()) {
            this.setDatasource(this.gridOptionsWrapper.getDatasource());
        }
    };
    PaginationController.prototype.setDatasource = function (datasource) {
        this.datasource = datasource;
        if (!datasource) {
            // only continue if we have a valid datasource to work with
            return;
        }
        this.reset();
    };
    PaginationController.prototype.reset = function () {
        // important to return here, as the user could be setting filter or sort before
        // data-source is set
        if (utils_1.Utils.missing(this.datasource)) {
            return;
        }
        this.selectionController.reset();
        // copy pageSize, to guard against it changing the the datasource between calls
        if (this.datasource.pageSize && typeof this.datasource.pageSize !== 'number') {
            console.warn('datasource.pageSize should be a number');
        }
        this.pageSize = this.datasource.pageSize;
        // see if we know the total number of pages, or if it's 'to be decided'
        if (typeof this.datasource.rowCount === 'number' && this.datasource.rowCount >= 0) {
            this.rowCount = this.datasource.rowCount;
            this.foundMaxRow = true;
            this.calculateTotalPages();
        }
        else {
            this.rowCount = 0;
            this.foundMaxRow = false;
            this.totalPages = null;
        }
        this.currentPage = 0;
        // hide the summary panel until something is loaded
        this.ePageRowSummaryPanel.style.visibility = 'hidden';
        this.setTotalLabels();
        this.loadPage();
    };
    // the native method number.toLocaleString(undefined, {minimumFractionDigits: 0}) puts in decimal places in IE
    PaginationController.prototype.myToLocaleString = function (input) {
        if (typeof input !== 'number') {
            return '';
        }
        else {
            // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
            return input.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
        }
    };
    PaginationController.prototype.setTotalLabels = function () {
        if (this.foundMaxRow) {
            this.lbTotal.innerHTML = this.myToLocaleString(this.totalPages);
            this.lbRecordCount.innerHTML = this.myToLocaleString(this.rowCount);
        }
        else {
            var moreText = this.gridOptionsWrapper.getLocaleTextFunc()('more', 'more');
            this.lbTotal.innerHTML = moreText;
            this.lbRecordCount.innerHTML = moreText;
        }
    };
    PaginationController.prototype.calculateTotalPages = function () {
        this.totalPages = Math.floor((this.rowCount - 1) / this.pageSize) + 1;
    };
    PaginationController.prototype.pageLoaded = function (rows, lastRowIndex) {
        var firstId = this.currentPage * this.pageSize;
        this.inMemoryRowModel.setRowData(rows, true, firstId);
        // see if we hit the last row
        if (!this.foundMaxRow && typeof lastRowIndex === 'number' && lastRowIndex >= 0) {
            this.foundMaxRow = true;
            this.rowCount = lastRowIndex;
            this.calculateTotalPages();
            this.setTotalLabels();
            // if overshot pages, go back
            if (this.currentPage > this.totalPages) {
                this.currentPage = this.totalPages - 1;
                this.loadPage();
            }
        }
        this.enableOrDisableButtons();
        this.updateRowLabels();
    };
    PaginationController.prototype.updateRowLabels = function () {
        var startRow;
        var endRow;
        if (this.isZeroPagesToDisplay()) {
            startRow = 0;
            endRow = 0;
        }
        else {
            startRow = (this.pageSize * this.currentPage) + 1;
            endRow = startRow + this.pageSize - 1;
            if (this.foundMaxRow && endRow > this.rowCount) {
                endRow = this.rowCount;
            }
        }
        this.lbFirstRowOnPage.innerHTML = this.myToLocaleString(startRow);
        this.lbLastRowOnPage.innerHTML = this.myToLocaleString(endRow);
        // show the summary panel, when first shown, this is blank
        this.ePageRowSummaryPanel.style.visibility = "";
    };
    PaginationController.prototype.loadPage = function () {
        this.enableOrDisableButtons();
        var startRow = this.currentPage * this.datasource.pageSize;
        var endRow = (this.currentPage + 1) * this.datasource.pageSize;
        this.lbCurrent.innerHTML = this.myToLocaleString(this.currentPage + 1);
        this.callVersion++;
        var callVersionCopy = this.callVersion;
        var that = this;
        this.gridPanel.showLoadingOverlay();
        var sortModel;
        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
            sortModel = this.sortController.getSortModel();
        }
        var filterModel;
        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
            filterModel = this.filterManager.getFilterModel();
        }
        var params = {
            startRow: startRow,
            endRow: endRow,
            successCallback: successCallback,
            failCallback: failCallback,
            sortModel: sortModel,
            filterModel: filterModel,
            context: this.gridOptionsWrapper.getContext()
        };
        // check if old version of datasource used
        var getRowsParams = utils_1.Utils.getFunctionParameters(this.datasource.getRows);
        if (getRowsParams.length > 1) {
            console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
            console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
        }
        this.datasource.getRows(params);
        function successCallback(rows, lastRowIndex) {
            if (that.isCallDaemon(callVersionCopy)) {
                return;
            }
            that.pageLoaded(rows, lastRowIndex);
        }
        function failCallback() {
            if (that.isCallDaemon(callVersionCopy)) {
                return;
            }
            // set in an empty set of rows, this will at
            // least get rid of the loading panel, and
            // stop blocking things
            that.inMemoryRowModel.setRowData([], true);
        }
    };
    PaginationController.prototype.isCallDaemon = function (versionCopy) {
        return versionCopy !== this.callVersion;
    };
    PaginationController.prototype.onBtNext = function () {
        this.currentPage++;
        this.loadPage();
    };
    PaginationController.prototype.onBtPrevious = function () {
        this.currentPage--;
        this.loadPage();
    };
    PaginationController.prototype.onBtFirst = function () {
        this.currentPage = 0;
        this.loadPage();
    };
    PaginationController.prototype.onBtLast = function () {
        this.currentPage = this.totalPages - 1;
        this.loadPage();
    };
    PaginationController.prototype.isZeroPagesToDisplay = function () {
        return this.foundMaxRow && this.totalPages === 0;
    };
    PaginationController.prototype.enableOrDisableButtons = function () {
        var disablePreviousAndFirst = this.currentPage === 0;
        this.btPrevious.disabled = disablePreviousAndFirst;
        this.btFirst.disabled = disablePreviousAndFirst;
        var zeroPagesToDisplay = this.isZeroPagesToDisplay();
        var onLastPage = this.foundMaxRow && this.currentPage === (this.totalPages - 1);
        var disableNext = onLastPage || zeroPagesToDisplay;
        this.btNext.disabled = disableNext;
        var disableLast = !this.foundMaxRow || zeroPagesToDisplay || this.currentPage === (this.totalPages - 1);
        this.btLast.disabled = disableLast;
    };
    PaginationController.prototype.createTemplate = function () {
        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
        return template
            .replace('[PAGE]', localeTextFunc('page', 'Page'))
            .replace('[TO]', localeTextFunc('to', 'to'))
            .replace('[OF]', localeTextFunc('of', 'of'))
            .replace('[OF]', localeTextFunc('of', 'of'))
            .replace('[FIRST]', localeTextFunc('first', 'First'))
            .replace('[PREVIOUS]', localeTextFunc('previous', 'Previous'))
            .replace('[NEXT]', localeTextFunc('next', 'Next'))
            .replace('[LAST]', localeTextFunc('last', 'Last'));
    };
    PaginationController.prototype.getGui = function () {
        return this.eGui;
    };
    PaginationController.prototype.setupComponents = function () {
        this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
        this.btNext = this.eGui.querySelector('#btNext');
        this.btPrevious = this.eGui.querySelector('#btPrevious');
        this.btFirst = this.eGui.querySelector('#btFirst');
        this.btLast = this.eGui.querySelector('#btLast');
        this.lbCurrent = this.eGui.querySelector('#current');
        this.lbTotal = this.eGui.querySelector('#total');
        this.lbRecordCount = this.eGui.querySelector('#recordCount');
        this.lbFirstRowOnPage = this.eGui.querySelector('#firstRowOnPage');
        this.lbLastRowOnPage = this.eGui.querySelector('#lastRowOnPage');
        this.ePageRowSummaryPanel = this.eGui.querySelector('#pageRowSummaryPanel');
        var that = this;
        this.btNext.addEventListener('click', function () {
            that.onBtNext();
        });
        this.btPrevious.addEventListener('click', function () {
            that.onBtPrevious();
        });
        this.btFirst.addEventListener('click', function () {
            that.onBtFirst();
        });
        this.btLast.addEventListener('click', function () {
            that.onBtLast();
        });
    };
    __decorate([
        context_2.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], PaginationController.prototype, "filterManager", void 0);
    __decorate([
        context_2.Autowired('gridPanel'), 
        __metadata('design:type', gridPanel_1.GridPanel)
    ], PaginationController.prototype, "gridPanel", void 0);
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], PaginationController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_2.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], PaginationController.prototype, "selectionController", void 0);
    __decorate([
        context_2.Autowired('sortController'), 
        __metadata('design:type', sortController_1.SortController)
    ], PaginationController.prototype, "sortController", void 0);
    __decorate([
        context_2.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], PaginationController.prototype, "eventService", void 0);
    __decorate([
        context_2.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], PaginationController.prototype, "rowModel", void 0);
    __decorate([
        context_3.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], PaginationController.prototype, "init", null);
    PaginationController = __decorate([
        context_1.Bean('paginationController'), 
        __metadata('design:paramtypes', [])
    ], PaginationController);
    return PaginationController;
})();
exports.PaginationController = PaginationController;

},{"../constants":86,"../context/context":87,"../eventService":98,"../events":99,"../filter/filterManager":101,"../gridOptionsWrapper":109,"../gridPanel/gridPanel":110,"../selectionController":152,"../sortController":153,"../utils":156}],151:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require("../utils");
var gridOptionsWrapper_1 = require("../gridOptionsWrapper");
var rowNode_1 = require("../entities/rowNode");
var context_1 = require("../context/context");
var eventService_1 = require("../eventService");
var selectionController_1 = require("../selectionController");
var events_1 = require("../events");
var sortController_1 = require("../sortController");
var filterManager_1 = require("../filter/filterManager");
var constants_1 = require("../constants");
/*
* This row controller is used for infinite scrolling only. For normal 'in memory' table,
* or standard pagination, the inMemoryRowController is used.
*/
var logging = false;
var VirtualPageRowModel = (function () {
    function VirtualPageRowModel() {
        this.datasourceVersion = 0;
    }
    VirtualPageRowModel.prototype.init = function () {
        var _this = this;
        this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();
        var virtualEnabled = this.gridOptionsWrapper.isRowModelVirtual();
        this.eventService.addEventListener(events_1.Events.EVENT_FILTER_CHANGED, function () {
            if (virtualEnabled && _this.gridOptionsWrapper.isEnableServerSideFilter()) {
                _this.reset();
            }
        });
        this.eventService.addEventListener(events_1.Events.EVENT_SORT_CHANGED, function () {
            if (virtualEnabled && _this.gridOptionsWrapper.isEnableServerSideSorting()) {
                _this.reset();
            }
        });
        if (virtualEnabled && this.gridOptionsWrapper.getDatasource()) {
            this.setDatasource(this.gridOptionsWrapper.getDatasource());
        }
    };
    VirtualPageRowModel.prototype.getType = function () {
        return constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL;
    };
    VirtualPageRowModel.prototype.setDatasource = function (datasource) {
        this.datasource = datasource;
        if (!datasource) {
            // only continue if we have a valid datasource to working with
            return;
        }
        this.reset();
    };
    VirtualPageRowModel.prototype.isEmpty = function () {
        return !this.datasource;
    };
    VirtualPageRowModel.prototype.isRowsToRender = function () {
        return utils_1.Utils.exists(this.datasource);
    };
    VirtualPageRowModel.prototype.reset = function () {
        // important to return here, as the user could be setting filter or sort before
        // data-source is set
        if (utils_1.Utils.missing(this.datasource)) {
            return;
        }
        this.selectionController.reset();
        // see if datasource knows how many rows there are
        if (typeof this.datasource.rowCount === 'number' && this.datasource.rowCount >= 0) {
            this.virtualRowCount = this.datasource.rowCount;
            this.foundMaxRow = true;
        }
        else {
            this.virtualRowCount = 0;
            this.foundMaxRow = false;
        }
        // in case any daemon requests coming from datasource, we know it ignore them
        this.datasourceVersion++;
        // map of page numbers to rows in that page
        this.pageCache = {};
        this.pageCacheSize = 0;
        // if a number is in this array, it means we are pending a load from it
        this.pageLoadsInProgress = [];
        this.pageLoadsQueued = [];
        this.pageAccessTimes = {}; // keeps a record of when each page was last viewed, used for LRU cache
        this.accessTime = 0; // rather than using the clock, we use this counter
        // the number of concurrent loads we are allowed to the server
        if (typeof this.datasource.maxConcurrentRequests === 'number' && this.datasource.maxConcurrentRequests > 0) {
            this.maxConcurrentDatasourceRequests = this.datasource.maxConcurrentRequests;
        }
        else {
            this.maxConcurrentDatasourceRequests = 2;
        }
        // the number of pages to keep in browser cache
        if (typeof this.datasource.maxPagesInCache === 'number' && this.datasource.maxPagesInCache > 0) {
            this.maxPagesInCache = this.datasource.maxPagesInCache;
        }
        else {
            // null is default, means don't  have any max size on the cache
            this.maxPagesInCache = null;
        }
        this.pageSize = this.datasource.pageSize; // take a copy of page size, we don't want it changing
        this.overflowSize = this.datasource.overflowSize; // take a copy of page size, we don't want it changing
        this.doLoadOrQueue(0);
        this.rowRenderer.refreshView();
    };
    VirtualPageRowModel.prototype.createNodesFromRows = function (pageNumber, rows) {
        var nodes = [];
        if (rows) {
            for (var i = 0, j = rows.length; i < j; i++) {
                var virtualRowIndex = (pageNumber * this.pageSize) + i;
                var node = this.createNode(rows[i], virtualRowIndex, true);
                nodes.push(node);
            }
        }
        return nodes;
    };
    VirtualPageRowModel.prototype.createNode = function (data, virtualRowIndex, realNode) {
        var rowHeight = this.rowHeight;
        var top = rowHeight * virtualRowIndex;
        var rowNode;
        if (realNode) {
            // if a real node, then always create a new one
            rowNode = new rowNode_1.RowNode();
            this.context.wireBean(rowNode);
            rowNode.id = virtualRowIndex;
            rowNode.data = data;
            // and see if the previous one was selected, and if yes, swap it out
            this.selectionController.syncInRowNode(rowNode);
        }
        else {
            // if creating a proxy node, see if there is a copy in selected memory that we can use
            var rowNode = this.selectionController.getNodeForIdIfSelected(virtualRowIndex);
            if (!rowNode) {
                rowNode = new rowNode_1.RowNode();
                this.context.wireBean(rowNode);
                rowNode.id = virtualRowIndex;
                rowNode.data = data;
            }
        }
        rowNode.rowTop = top;
        rowNode.rowHeight = rowHeight;
        return rowNode;
    };
    VirtualPageRowModel.prototype.removeFromLoading = function (pageNumber) {
        var index = this.pageLoadsInProgress.indexOf(pageNumber);
        this.pageLoadsInProgress.splice(index, 1);
    };
    VirtualPageRowModel.prototype.pageLoadFailed = function (pageNumber) {
        this.removeFromLoading(pageNumber);
        this.checkQueueForNextLoad();
    };
    VirtualPageRowModel.prototype.pageLoaded = function (pageNumber, rows, lastRow) {
        this.putPageIntoCacheAndPurge(pageNumber, rows);
        this.checkMaxRowAndInformRowRenderer(pageNumber, lastRow);
        this.removeFromLoading(pageNumber);
        this.checkQueueForNextLoad();
    };
    VirtualPageRowModel.prototype.putPageIntoCacheAndPurge = function (pageNumber, rows) {
        this.pageCache[pageNumber] = this.createNodesFromRows(pageNumber, rows);
        this.pageCacheSize++;
        if (logging) {
            console.log('adding page ' + pageNumber);
        }
        var needToPurge = this.maxPagesInCache && this.maxPagesInCache < this.pageCacheSize;
        if (needToPurge) {
            // find the LRU page
            var youngestPageIndex = this.findLeastRecentlyAccessedPage(Object.keys(this.pageCache));
            if (logging) {
                console.log('purging page ' + youngestPageIndex + ' from cache ' + Object.keys(this.pageCache));
            }
            delete this.pageCache[youngestPageIndex];
            this.pageCacheSize--;
        }
    };
    VirtualPageRowModel.prototype.checkMaxRowAndInformRowRenderer = function (pageNumber, lastRow) {
        if (!this.foundMaxRow) {
            // if we know the last row, use if
            if (typeof lastRow === 'number' && lastRow >= 0) {
                this.virtualRowCount = lastRow;
                this.foundMaxRow = true;
            }
            else {
                // otherwise, see if we need to add some virtual rows
                var thisPagePlusBuffer = ((pageNumber + 1) * this.pageSize) + this.overflowSize;
                if (this.virtualRowCount < thisPagePlusBuffer) {
                    this.virtualRowCount = thisPagePlusBuffer;
                }
            }
            // if rowCount changes, refreshView, otherwise just refreshAllVirtualRows
            this.rowRenderer.refreshView();
        }
        else {
            this.rowRenderer.refreshAllVirtualRows();
        }
    };
    VirtualPageRowModel.prototype.isPageAlreadyLoading = function (pageNumber) {
        var result = this.pageLoadsInProgress.indexOf(pageNumber) >= 0 || this.pageLoadsQueued.indexOf(pageNumber) >= 0;
        return result;
    };
    VirtualPageRowModel.prototype.doLoadOrQueue = function (pageNumber) {
        // if we already tried to load this page, then ignore the request,
        // otherwise server would be hit 50 times just to display one page, the
        // first row to find the page missing is enough.
        if (this.isPageAlreadyLoading(pageNumber)) {
            return;
        }
        // try the page load - if not already doing a load, then we can go ahead
        if (this.pageLoadsInProgress.length < this.maxConcurrentDatasourceRequests) {
            // go ahead, load the page
            this.loadPage(pageNumber);
        }
        else {
            // otherwise, queue the request
            this.addToQueueAndPurgeQueue(pageNumber);
        }
    };
    VirtualPageRowModel.prototype.addToQueueAndPurgeQueue = function (pageNumber) {
        if (logging) {
            console.log('queueing ' + pageNumber + ' - ' + this.pageLoadsQueued);
        }
        this.pageLoadsQueued.push(pageNumber);
        // see if there are more pages queued that are actually in our cache, if so there is
        // no point in loading them all as some will be purged as soon as loaded
        var needToPurge = this.maxPagesInCache && this.maxPagesInCache < this.pageLoadsQueued.length;
        if (needToPurge) {
            // find the LRU page
            var youngestPageIndex = this.findLeastRecentlyAccessedPage(this.pageLoadsQueued);
            if (logging) {
                console.log('de-queueing ' + pageNumber + ' - ' + this.pageLoadsQueued);
            }
            var indexToRemove = this.pageLoadsQueued.indexOf(youngestPageIndex);
            this.pageLoadsQueued.splice(indexToRemove, 1);
        }
    };
    VirtualPageRowModel.prototype.findLeastRecentlyAccessedPage = function (pageIndexes) {
        var youngestPageIndex = -1;
        var youngestPageAccessTime = Number.MAX_VALUE;
        var that = this;
        pageIndexes.forEach(function (pageIndex) {
            var accessTimeThisPage = that.pageAccessTimes[pageIndex];
            if (accessTimeThisPage < youngestPageAccessTime) {
                youngestPageAccessTime = accessTimeThisPage;
                youngestPageIndex = pageIndex;
            }
        });
        return youngestPageIndex;
    };
    VirtualPageRowModel.prototype.checkQueueForNextLoad = function () {
        if (this.pageLoadsQueued.length > 0) {
            // take from the front of the queue
            var pageToLoad = this.pageLoadsQueued[0];
            this.pageLoadsQueued.splice(0, 1);
            if (logging) {
                console.log('dequeueing ' + pageToLoad + ' - ' + this.pageLoadsQueued);
            }
            this.loadPage(pageToLoad);
        }
    };
    VirtualPageRowModel.prototype.loadPage = function (pageNumber) {
        this.pageLoadsInProgress.push(pageNumber);
        var startRow = pageNumber * this.pageSize;
        var endRow = (pageNumber + 1) * this.pageSize;
        var that = this;
        var datasourceVersionCopy = this.datasourceVersion;
        var sortModel;
        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
            sortModel = this.sortController.getSortModel();
        }
        var filterModel;
        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
            filterModel = this.filterManager.getFilterModel();
        }
        var params = {
            startRow: startRow,
            endRow: endRow,
            successCallback: successCallback,
            failCallback: failCallback,
            sortModel: sortModel,
            filterModel: filterModel,
            context: this.gridOptionsWrapper.getContext()
        };
        // check if old version of datasource used
        var getRowsParams = utils_1.Utils.getFunctionParameters(this.datasource.getRows);
        if (getRowsParams.length > 1) {
            console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
            console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
        }
        this.datasource.getRows(params);
        function successCallback(rows, lastRowIndex) {
            if (that.requestIsDaemon(datasourceVersionCopy)) {
                return;
            }
            that.pageLoaded(pageNumber, rows, lastRowIndex);
        }
        function failCallback() {
            if (that.requestIsDaemon(datasourceVersionCopy)) {
                return;
            }
            that.pageLoadFailed(pageNumber);
        }
    };
    VirtualPageRowModel.prototype.expandOrCollapseAll = function (expand) {
        console.warn('ag-Grid: can not expand or collapse all when doing virtual pagination');
    };
    // check that the datasource has not changed since the lats time we did a request
    VirtualPageRowModel.prototype.requestIsDaemon = function (datasourceVersionCopy) {
        return this.datasourceVersion !== datasourceVersionCopy;
    };
    VirtualPageRowModel.prototype.getRow = function (rowIndex) {
        if (rowIndex > this.virtualRowCount) {
            return null;
        }
        var pageNumber = Math.floor(rowIndex / this.pageSize);
        var page = this.pageCache[pageNumber];
        // for LRU cache, track when this page was last hit
        this.pageAccessTimes[pageNumber] = this.accessTime++;
        if (!page) {
            this.doLoadOrQueue(pageNumber);
            // return back an empty row, so table can at least render empty cells
            var dummyNode = this.createNode(null, rowIndex, false);
            return dummyNode;
        }
        else {
            var indexInThisPage = rowIndex % this.pageSize;
            return page[indexInThisPage];
        }
    };
    VirtualPageRowModel.prototype.forEachNode = function (callback) {
        var pageKeys = Object.keys(this.pageCache);
        for (var i = 0; i < pageKeys.length; i++) {
            var pageKey = pageKeys[i];
            var page = this.pageCache[pageKey];
            for (var j = 0; j < page.length; j++) {
                var node = page[j];
                callback(node);
            }
        }
    };
    VirtualPageRowModel.prototype.getRowCombinedHeight = function () {
        return this.virtualRowCount * this.rowHeight;
    };
    VirtualPageRowModel.prototype.getRowIndexAtPixel = function (pixel) {
        if (this.rowHeight !== 0) {
            return Math.floor(pixel / this.rowHeight);
        }
        else {
            return 0;
        }
    };
    VirtualPageRowModel.prototype.getRowCount = function () {
        return this.virtualRowCount;
    };
    VirtualPageRowModel.prototype.setRowData = function (rows, refresh, firstId) {
        console.warn('setRowData - does not work with virtual pagination');
    };
    VirtualPageRowModel.prototype.forEachNodeAfterFilter = function (callback) {
        console.warn('forEachNodeAfterFilter - does not work with virtual pagination');
    };
    VirtualPageRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {
        console.warn('forEachNodeAfterFilter - does not work with virtual pagination');
    };
    VirtualPageRowModel.prototype.refreshModel = function () {
        console.warn('forEachNodeAfterFilter - does not work with virtual pagination');
    };
    VirtualPageRowModel.prototype.getTopLevelNodes = function () {
        console.warn('getTopLevelNodes - does not work with virtual pagination');
        return null;
    };
    __decorate([
        context_1.Autowired('rowRenderer'), 
        __metadata('design:type', Object)
    ], VirtualPageRowModel.prototype, "rowRenderer", void 0);
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], VirtualPageRowModel.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('filterManager'), 
        __metadata('design:type', filterManager_1.FilterManager)
    ], VirtualPageRowModel.prototype, "filterManager", void 0);
    __decorate([
        context_1.Autowired('sortController'), 
        __metadata('design:type', sortController_1.SortController)
    ], VirtualPageRowModel.prototype, "sortController", void 0);
    __decorate([
        context_1.Autowired('selectionController'), 
        __metadata('design:type', selectionController_1.SelectionController)
    ], VirtualPageRowModel.prototype, "selectionController", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], VirtualPageRowModel.prototype, "eventService", void 0);
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], VirtualPageRowModel.prototype, "context", void 0);
    __decorate([
        context_1.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], VirtualPageRowModel.prototype, "init", null);
    VirtualPageRowModel = __decorate([
        context_1.Bean('rowModel'), 
        __metadata('design:paramtypes', [])
    ], VirtualPageRowModel);
    return VirtualPageRowModel;
})();
exports.VirtualPageRowModel = VirtualPageRowModel;

},{"../constants":86,"../context/context":87,"../entities/rowNode":97,"../eventService":98,"../events":99,"../filter/filterManager":101,"../gridOptionsWrapper":109,"../selectionController":152,"../sortController":153,"../utils":156}],152:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var utils_1 = require('./utils');
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var logger_1 = require("./logger");
var eventService_1 = require("./eventService");
var events_1 = require("./events");
var context_3 = require("./context/context");
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var context_4 = require("./context/context");
var constants_1 = require("./constants");
var SelectionController = (function () {
    function SelectionController() {
    }
    SelectionController.prototype.setBeans = function (loggerFactory) {
        this.logger = loggerFactory.create('SelectionController');
        this.reset();
        if (this.gridOptionsWrapper.isRowModelDefault()) {
            this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));
        }
        else {
            this.logger.log('dont know what to do here');
        }
    };
    SelectionController.prototype.init = function () {
        this.eventService.addEventListener(events_1.Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
    };
    SelectionController.prototype.setLastSelectedNode = function (rowNode) {
        this.lastSelectedNode = rowNode;
    };
    SelectionController.prototype.getLastSelectedNode = function () {
        return this.lastSelectedNode;
    };
    SelectionController.prototype.getSelectedNodes = function () {
        var selectedNodes = [];
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
            if (rowNode) {
                selectedNodes.push(rowNode);
            }
        });
        return selectedNodes;
    };
    SelectionController.prototype.getSelectedRows = function () {
        var selectedRows = [];
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
            if (rowNode) {
                selectedRows.push(rowNode.data);
            }
        });
        return selectedRows;
    };
    SelectionController.prototype.removeGroupsFromSelection = function () {
        var _this = this;
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
            if (rowNode && rowNode.group) {
                _this.selectedNodes[rowNode.id] = undefined;
            }
        });
    };
    // should only be called if groupSelectsChildren=true
    SelectionController.prototype.updateGroupsFromChildrenSelections = function () {
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
            console.warn('updateGroupsFromChildrenSelections not available when rowModel is not normal');
        }
        var inMemoryRowModel = this.rowModel;
        inMemoryRowModel.getTopLevelNodes().forEach(function (rowNode) {
            rowNode.deptFirstSearch(function (rowNode) {
                if (rowNode.group) {
                    rowNode.calculateSelectedFromChildren();
                }
            });
        });
    };
    SelectionController.prototype.getNodeForIdIfSelected = function (id) {
        return this.selectedNodes[id];
    };
    SelectionController.prototype.clearOtherNodes = function (rowNodeToKeepSelected) {
        var _this = this;
        utils_1.Utils.iterateObject(this.selectedNodes, function (key, otherRowNode) {
            if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
                _this.selectedNodes[otherRowNode.id].setSelectedParams({ newValue: false, clearSelection: false, tailingNodeInSequence: true });
            }
        });
    };
    SelectionController.prototype.onRowSelected = function (event) {
        var rowNode = event.node;
        if (rowNode.isSelected()) {
            this.selectedNodes[rowNode.id] = rowNode;
        }
        else {
            this.selectedNodes[rowNode.id] = undefined;
        }
    };
    SelectionController.prototype.syncInRowNode = function (rowNode) {
        if (this.selectedNodes[rowNode.id] !== undefined) {
            rowNode.setSelectedInitialValue(true);
            this.selectedNodes[rowNode.id] = rowNode;
        }
    };
    SelectionController.prototype.reset = function () {
        this.logger.log('reset');
        this.selectedNodes = {};
        this.lastSelectedNode = null;
    };
    // returns a list of all nodes at 'best cost' - a feature to be used
    // with groups / trees. if a group has all it's children selected,
    // then the group appears in the result, but not the children.
    // Designed for use with 'children' as the group selection type,
    // where groups don't actually appear in the selection normally.
    SelectionController.prototype.getBestCostNodeSelection = function () {
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
            console.warn('getBestCostNodeSelection is only avilable when using normal row model');
        }
        var inMemoryRowModel = this.rowModel;
        var topLevelNodes = inMemoryRowModel.getTopLevelNodes();
        if (topLevelNodes === null) {
            console.warn('selectAll not available doing rowModel=virtual');
            return;
        }
        var result = [];
        // recursive function, to find the selected nodes
        function traverse(nodes) {
            for (var i = 0, l = nodes.length; i < l; i++) {
                var node = nodes[i];
                if (node.isSelected()) {
                    result.push(node);
                }
                else {
                    // if not selected, then if it's a group, and the group
                    // has children, continue to search for selections
                    if (node.group && node.children) {
                        traverse(node.children);
                    }
                }
            }
        }
        traverse(topLevelNodes);
        return result;
    };
    SelectionController.prototype.setRowModel = function (rowModel) {
        this.rowModel = rowModel;
    };
    SelectionController.prototype.isEmpty = function () {
        var count = 0;
        utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
            if (rowNode) {
                count++;
            }
        });
        return count === 0;
    };
    SelectionController.prototype.deselectAllRowNodes = function () {
        utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
            if (rowNode) {
                rowNode.selectThisNode(false);
            }
        });
        // we should not have to do this, as deselecting the nodes fires events
        // that we pick up, however it's good to clean it down, as we are still
        // left with entries pointing to 'undefined'
        this.selectedNodes = {};
        this.eventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
    };
    SelectionController.prototype.selectAllRowNodes = function () {
        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
            throw 'selectAll only available with norma row model, ie not virtual pagination';
        }
        this.rowModel.forEachNode(function (rowNode) {
            rowNode.setSelectedParams({ newValue: true, clearSelection: false, tailingNodeInSequence: true });
        });
        this.eventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
    };
    // Deprecated method
    SelectionController.prototype.selectNode = function (rowNode, tryMulti) {
        rowNode.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
    };
    // Deprecated method
    SelectionController.prototype.deselectIndex = function (rowIndex) {
        var node = this.rowModel.getRow(rowIndex);
        this.deselectNode(node);
    };
    // Deprecated method
    SelectionController.prototype.deselectNode = function (rowNode) {
        rowNode.setSelectedParams({ newValue: false, clearSelection: false });
    };
    // Deprecated method
    SelectionController.prototype.selectIndex = function (index, tryMulti) {
        var node = this.rowModel.getRow(index);
        this.selectNode(node, tryMulti);
    };
    __decorate([
        context_3.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], SelectionController.prototype, "eventService", void 0);
    __decorate([
        context_3.Autowired('rowModel'), 
        __metadata('design:type', Object)
    ], SelectionController.prototype, "rowModel", void 0);
    __decorate([
        context_3.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], SelectionController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        __param(0, context_2.Qualifier('loggerFactory')), 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
        __metadata('design:returntype', void 0)
    ], SelectionController.prototype, "setBeans", null);
    __decorate([
        context_4.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], SelectionController.prototype, "init", null);
    SelectionController = __decorate([
        context_1.Bean('selectionController'), 
        __metadata('design:paramtypes', [])
    ], SelectionController);
    return SelectionController;
})();
exports.SelectionController = SelectionController;

},{"./constants":86,"./context/context":87,"./eventService":98,"./events":99,"./gridOptionsWrapper":109,"./logger":124,"./utils":156}],153:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var column_1 = require("./entities/column");
var context_1 = require("./context/context");
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var columnController_1 = require("./columnController/columnController");
var eventService_1 = require("./eventService");
var events_1 = require("./events");
var context_2 = require("./context/context");
var utils_1 = require('./utils');
var SortController = (function () {
    function SortController() {
    }
    SortController.prototype.progressSort = function (column, multiSort) {
        // update sort on current col
        column.setSort(this.getNextSortDirection(column));
        // sortedAt used for knowing order of cols when multi-col sort
        if (column.getSort()) {
            column.setSortedAt(new Date().valueOf());
        }
        else {
            column.setSortedAt(null);
        }
        var doingMultiSort = multiSort && !this.gridOptionsWrapper.isSuppressMultiSort();
        // clear sort on all columns except this one, and update the icons
        if (!doingMultiSort) {
            this.clearSortBarThisColumn(column);
        }
        this.dispatchSortChangedEvents();
    };
    SortController.prototype.dispatchSortChangedEvents = function () {
        this.eventService.dispatchEvent(events_1.Events.EVENT_BEFORE_SORT_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_SORT_CHANGED);
        this.eventService.dispatchEvent(events_1.Events.EVENT_AFTER_SORT_CHANGED);
    };
    SortController.prototype.clearSortBarThisColumn = function (columnToSkip) {
        this.columnController.getAllColumnsIncludingAuto().forEach(function (columnToClear) {
            // Do not clear if either holding shift, or if column in question was clicked
            if (!(columnToClear === columnToSkip)) {
                columnToClear.setSort(null);
            }
        });
    };
    SortController.prototype.getNextSortDirection = function (column) {
        var sortingOrder;
        if (column.getColDef().sortingOrder) {
            sortingOrder = column.getColDef().sortingOrder;
        }
        else if (this.gridOptionsWrapper.getSortingOrder()) {
            sortingOrder = this.gridOptionsWrapper.getSortingOrder();
        }
        else {
            sortingOrder = SortController.DEFAULT_SORTING_ORDER;
        }
        if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
            console.warn('ag-grid: sortingOrder must be an array with at least one element, currently it\'s ' + sortingOrder);
            return;
        }
        var currentIndex = sortingOrder.indexOf(column.getSort());
        var notInArray = currentIndex < 0;
        var lastItemInArray = currentIndex == sortingOrder.length - 1;
        var result;
        if (notInArray || lastItemInArray) {
            result = sortingOrder[0];
        }
        else {
            result = sortingOrder[currentIndex + 1];
        }
        // verify the sort type exists, as the user could provide the sortOrder, need to make sure it's valid
        if (SortController.DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
            console.warn('ag-grid: invalid sort type ' + result);
            return null;
        }
        return result;
    };
    // used by the public api, for saving the sort model
    SortController.prototype.getSortModel = function () {
        var columnsWithSorting = this.getColumnsWithSortingOrdered();
        return utils_1.Utils.map(columnsWithSorting, function (column) {
            return {
                colId: column.getColId(),
                sort: column.getSort()
            };
        });
    };
    SortController.prototype.setSortModel = function (sortModel) {
        if (!this.gridOptionsWrapper.isEnableSorting()) {
            console.warn('ag-grid: You are setting the sort model on a grid that does not have sorting enabled');
            return;
        }
        // first up, clear any previous sort
        var sortModelProvided = sortModel && sortModel.length > 0;
        var allColumnsIncludingAuto = this.columnController.getAllColumnsIncludingAuto();
        allColumnsIncludingAuto.forEach(function (column) {
            var sortForCol = null;
            var sortedAt = -1;
            if (sortModelProvided && !column.getColDef().suppressSorting) {
                for (var j = 0; j < sortModel.length; j++) {
                    var sortModelEntry = sortModel[j];
                    if (typeof sortModelEntry.colId === 'string'
                        && typeof column.getColId() === 'string'
                        && sortModelEntry.colId === column.getColId()) {
                        sortForCol = sortModelEntry.sort;
                        sortedAt = j;
                    }
                }
            }
            if (sortForCol) {
                column.setSort(sortForCol);
                column.setSortedAt(sortedAt);
            }
            else {
                column.setSort(null);
                column.setSortedAt(null);
            }
        });
        this.dispatchSortChangedEvents();
    };
    SortController.prototype.getColumnsWithSortingOrdered = function () {
        // pull out all the columns that have sorting set
        var allColumnsIncludingAuto = this.columnController.getAllColumnsIncludingAuto();
        var columnsWithSorting = utils_1.Utils.filter(allColumnsIncludingAuto, function (column) { return !!column.getSort(); });
        // put the columns in order of which one got sorted first
        columnsWithSorting.sort(function (a, b) { return a.sortedAt - b.sortedAt; });
        return columnsWithSorting;
    };
    // used by row controller, when doing the sorting
    SortController.prototype.getSortForRowController = function () {
        var columnsWithSorting = this.getColumnsWithSortingOrdered();
        return utils_1.Utils.map(columnsWithSorting, function (column) {
            var ascending = column.getSort() === column_1.Column.SORT_ASC;
            return {
                inverter: ascending ? 1 : -1,
                column: column
            };
        });
    };
    SortController.DEFAULT_SORTING_ORDER = [column_1.Column.SORT_ASC, column_1.Column.SORT_DESC, null];
    __decorate([
        context_1.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], SortController.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_1.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], SortController.prototype, "columnController", void 0);
    __decorate([
        context_1.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], SortController.prototype, "eventService", void 0);
    SortController = __decorate([
        context_2.Bean('sortController'), 
        __metadata('design:paramtypes', [])
    ], SortController);
    return SortController;
})();
exports.SortController = SortController;

},{"./columnController/columnController":77,"./context/context":87,"./entities/column":92,"./eventService":98,"./events":99,"./gridOptionsWrapper":109,"./utils":156}],154:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SVG_NS = "http://www.w3.org/2000/svg";
var SvgFactory = (function () {
    function SvgFactory() {
    }
    SvgFactory.getInstance = function () {
        if (!this.theInstance) {
            this.theInstance = new SvgFactory();
        }
        return this.theInstance;
    };
    SvgFactory.prototype.createFilterSvg = function () {
        var eSvg = createIconSvg();
        var eFunnel = document.createElementNS(SVG_NS, "polygon");
        eFunnel.setAttribute("points", "0,0 4,4 4,10 6,10 6,4 10,0");
        eFunnel.setAttribute("class", "ag-header-icon");
        eSvg.appendChild(eFunnel);
        return eSvg;
    };
    SvgFactory.prototype.createFilterSvg12 = function () {
        var eSvg = createIconSvg(12);
        var eFunnel = document.createElementNS(SVG_NS, "polygon");
        eFunnel.setAttribute("points", "0,0 5,5 5,12 7,12 7,5 12,0");
        eFunnel.setAttribute("class", "ag-header-icon");
        eSvg.appendChild(eFunnel);
        return eSvg;
    };
    SvgFactory.prototype.createMenuSvg = function () {
        var eSvg = document.createElementNS(SVG_NS, "svg");
        var size = "12";
        eSvg.setAttribute("width", size);
        eSvg.setAttribute("height", size);
        ["0", "5", "10"].forEach(function (y) {
            var eLine = document.createElementNS(SVG_NS, "rect");
            eLine.setAttribute("y", y);
            eLine.setAttribute("width", size);
            eLine.setAttribute("height", "2");
            eLine.setAttribute("class", "ag-header-icon");
            eSvg.appendChild(eLine);
        });
        return eSvg;
    };
    SvgFactory.prototype.createColumnsSvg12 = function () {
        var eSvg = createIconSvg(12);
        [0, 4, 8].forEach(function (y) {
            [0, 7].forEach(function (x) {
                var eBar = document.createElementNS(SVG_NS, "rect");
                eBar.setAttribute("y", y.toString());
                eBar.setAttribute("x", x.toString());
                eBar.setAttribute("width", "5");
                eBar.setAttribute("height", "3");
                eBar.setAttribute("class", "ag-header-icon");
                eSvg.appendChild(eBar);
            });
        });
        return eSvg;
    };
    SvgFactory.prototype.createArrowUpSvg = function () {
        return createPolygonSvg("0,10 5,0 10,10");
    };
    SvgFactory.prototype.createArrowLeftSvg = function () {
        return createPolygonSvg("10,0 0,5 10,10");
    };
    SvgFactory.prototype.createArrowDownSvg = function () {
        return createPolygonSvg("0,0 5,10 10,0");
    };
    SvgFactory.prototype.createArrowRightSvg = function () {
        return createPolygonSvg("0,0 10,5 0,10");
    };
    SvgFactory.prototype.createSmallArrowRightSvg = function () {
        return createPolygonSvg("0,0 6,3 0,6", 6);
    };
    SvgFactory.prototype.createSmallArrowDownSvg = function () {
        return createPolygonSvg("0,0 3,6 6,0", 6);
    };
    //public createOpenSvg() {
    //    return createPlusMinus(true);
    //}
    //
    //public createCloseSvg() {
    //    return createPlusMinus(false);
    //}
    // UnSort Icon SVG
    SvgFactory.prototype.createArrowUpDownSvg = function () {
        var svg = createIconSvg();
        var eAscIcon = document.createElementNS(SVG_NS, "polygon");
        eAscIcon.setAttribute("points", '0,4 5,0 10,4');
        svg.appendChild(eAscIcon);
        var eDescIcon = document.createElementNS(SVG_NS, "polygon");
        eDescIcon.setAttribute("points", '0,6 5,10 10,6');
        svg.appendChild(eDescIcon);
        return svg;
    };
    //public createFolderOpen(size: number): HTMLElement {
    //    var svg = `<svg width="${size}" height="${size}" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1717 931q0-35-53-35h-1088q-40 0-85.5 21.5t-71.5 52.5l-294 363q-18 24-18 40 0 35 53 35h1088q40 0 86-22t71-53l294-363q18-22 18-39zm-1141-163h768v-160q0-40-28-68t-68-28h-576q-40 0-68-28t-28-68v-64q0-40-28-68t-68-28h-320q-40 0-68 28t-28 68v853l256-315q44-53 116-87.5t140-34.5zm1269 163q0 62-46 120l-295 363q-43 53-116 87.5t-140 34.5h-1088q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h544q92 0 158 66t66 158v160h192q54 0 99 24.5t67 70.5q15 32 15 68z"/></svg>`;
    //    return _.loadTemplate(svg);
    //}
    //
    //public createFolderClosed(size: number): HTMLElement {
    //    var svg = `<svg width="${size}" height="${size}" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1600 1312v-704q0-40-28-68t-68-28h-704q-40 0-68-28t-28-68v-64q0-40-28-68t-68-28h-320q-40 0-68 28t-28 68v960q0 40 28 68t68 28h1216q40 0 68-28t28-68zm128-704v704q0 92-66 158t-158 66h-1216q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h672q92 0 158 66t66 158z"/></svg>`;
    //    return _.loadTemplate(svg);
    //}
    SvgFactory.prototype.createFolderOpen = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAZpJREFUeNqkU0tLQkEUPjN3ShAzF66CaNGiaNEviFpLgbSpXf2ACIqgFkELaVFhtAratQ8qokU/oFVbMQtJvWpWGvYwtet9TWfu1QorvOGBb84M5/WdOTOEcw7tCKHBlT8sMIhr4BfLGXC4BrALM8QUoveHG9oPQ/NhwVCQbOjp0C5F6zDiwE7Aed/p5tKWruufTlY8bkqliqVN8wvH6wvhydWd5UYdkYCqqgaKotQTCEewnJuDBSqVmshOrWhKgCJVqeHcKtiGKdqTgGIOQmwGum7AxVUKinXKzX1/1y5Xp6g8gpe8iBxuGZhcKjyXQZIkmBkfczS62YnRQCKX75/b3t8QDNhD8QX83V5Ipe7Bybug2Pt5NJ7A4nEqGOQKT+Bzu0HTDNB1syUYYxCJy0kwzIRogb0rKjAiQVXXHLVQrqqvsZtsFu8hbyXwe73WeMQtO5GonJGxuiyeC+Oa4fF5PEirw9nbx9FdxtN5eMwkzcgRnoeCa9DVM/CvH/R2l+axkz3clQguOFjw1f+FUzEQCqJG2v3OHwIMAOW1JPnAAAJxAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createFolderClosed = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAARlJREFUeNqsUz1PwzAUPDtOUASpYKkQVWcQA/+DhbLA32CoKAMSTAwgFsQfQWLoX4GRDFXGIiqiyk4e7wUWmg8phJPOtvzunc6WrYgIXaD06KKhij0eD2uqUxBeDC9OmcNKCYd7ujm7ryodXz5ong6UPpqcP9+O76y1vwS+7yOOY1jr0OttlQyiaB0n148TAyK9XFqkaboiSTEYDNnkDUkyKxkkiSQkzQbwsiyHcBXz+Tv6/W1m+QiSEDT1igTO5RBWYbH4rNwPw/AnQU5ek0EdCj33SgLjHEHYzoAkgfmHBDmZuktsQqHPvxN0MyCbbWjtIQjWWhlIj/QqtT+6QrSz+6ef9DF7VTwFzE2madnu5K2prt/5S4ABADcIlSf6Ag8YAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createColumnIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAOCAYAAAAMn20lAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTcwQ0JFMzlENjZEMTFFNUFEQ0U5RDRCNjFFRENGMUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTcwQ0JFM0FENjZEMTFFNUFEQ0U5RDRCNjFFRENGMUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFNzBDQkUzN0Q2NkQxMUU1QURDRTlENEI2MUVEQ0YxQyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFNzBDQkUzOEQ2NkQxMUU1QURDRTlENEI2MUVEQ0YxQyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqDOrJYAAABxSURBVHjalJBBDsAgCAQXxXvj2/o/X9Cvmd4lUpV4MXroJMTAuihQSklVMSCysxSBW4uWKzjG6zZLDxrlWis5EVEThoWmi3N+nxAYs2WnXQY34L3HisMWPQlHB+2FPtNW6D/8+ziBRcroOXc0B/wEGABY6TPS1FU0bwAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createColumnsIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENFQkI4NDhENzJDMTFFNUJDNEVFRjgwRDI3MkU1Q0EiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENFQkI4NDlENzJDMTFFNUJDNEVFRjgwRDI3MkU1Q0EiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0VCQjg0NkQ3MkMxMUU1QkM0RUVGODBEMjcyRTVDQSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0VCQjg0N0Q3MkMxMUU1QkM0RUVGODBEMjcyRTVDQSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj6ozGQAAAAuSURBVHjaYmRgYPjPgBswQml8anBK/idGDQsxNpCghnTAOBoGo2EwGgZgABBgAHbrH/l4grETAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createPinIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAedJREFUeNqkUktLG1EYPTN31CIN0oWbIAWhKJR0FXcG6gOqkKGKVvEXCKULC91YSBcK7jXgQoIbFxn3ErFgFlIfCxUsQsCoIJYEm9LWNsGmJjPTM+Oo44Aa6IUzd+bec77H+UYyTRP/s5SsLFfCCxEjOhD9CXw64ccXJj7nLleYaMSvaa/+Au9Y73P3RUUBDIuXyaAxGu35A7xnkM57A7icCZXIO8/nkVleRn1/f9cv0xzjfVclFdi9N8ZivfnDQxQKBTwoFvFicLCVQSesJIpHMEY8dSqQWa54Eov1fF9ZQVHXsZNMblhnNE/wPmJPIX1zjOG2+fkgslnozHR2eopLcSIe3yoD48y45FbIxoVJNjimyMehoW3T58PvdBq53V18zeWwFo+vUfyBlCVvj0Li4/M1DnaAUtXCQkNDR4f/294eaoTAwdHRCROMWlzJZfC+1cKcJF07b5o+btWvV1eDyVBouyUcDj5UFDg924tVYtERpz0mCkmSulOp1GQgEIj0yvKPYiKBlwMDQXfPU47walEEmb8z0a5p2qaiKMPEoz6ezQLdM8DWNDDzltym24YthHimquoshSoDicvzZkK9S+h48pjCN4ZhrBPHTptlD0qevezwdCtAHVHrMti4A7rr3eb+E2AAoGnGkgkzpg8AAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createPlusIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAatJREFUeNqkU71KA0EQ/vaiib+lWCiordidpSg+QHwDBSt7n8DGhwhYCPoEgqCCINomARuLVIqgYKFG5f6z68xOzrvzYuXA3P7MzLffN7unjDH4jw3xx91bQXuxU4woNDjUX7VgsFOIH3/BnHgC0J65AzwFjDpZgoG7vb7lMsPDq6MiuK+B+kjGwFpCUjwK1DIQ3/dl0ssVh5TTM0UJP8aBgBKGleSGIWyP0oKYRm3KPSgYJ0Q0EpEgCASA2WmWZQY3kazBmjP9UhBFEbTWAgA0f9W2yHeG+vrd+tqGy5r5xNTT9erSqpvfdxwHN7fXOQZ0QhzH1oWArLsfXXieJ/KTGEZLcbVaTVn9ALTOLk9L+mYX5lxd0Xh6eGyVgspK6APwI8n3x9hmNpORJOuBo5ah8GcTc7dAHmkhNpYQlpHr47Hq2NspA1yEwHkoO/MVYLMmWJNarjEUQBzQw7rPvardFC8tZuOEwwB4p9PHqXgCdm738sUDJPB8mnwKj7qCTtJ527+XyAs6tOf2Bb6SP0OeGxRTVMp2h9nweWMoKS20l3+QT/vwqfZbgAEAUCrnlLQ+w4QAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createMinusIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAKVJREFUeNpi/P//PwMlgImBQjBqAAMDy3JGRgZGBoaZQGxMikZg3J0F4nSWHxC+cUBamvHXr18Zfv36Bca/f/8G43///oExKLphmImJieHagQMQF7QDiSwg/vnzJ8P3799RDPj79y+KRhhmBLr6I1DPNJABtxkYZM4xMFx7uXAhSX5/CtQD0gv0OgMfyCAgZgViZiL1/wXi30D8h3E0KVNuAECAAQDr51qtGxzf1wAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createMoveIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAoZJREFUeNpsU81rE0EUf7uzu2lNVJL6Eb0IBWusepqcKm3wEFkvxqDgQbwUtYeeg5cccwj4F7QKChEPipRcdMGDiaAoJAexLYViwYsfbU1JYkx3Zz98b8220Wbg7ez7vXm/mffmN9Kh1G2QGQOmMDiRyYEkSaCoKjDGdAAooOUdxzFsIcDzPPhSvgeO7YDrOLBRmQdlJHULVE0DNRSCvqFjUuHqhWP8+etvhR5m0CeengVhmiAsywdl2Dt03K1wZSrO220XaCaf8AFrQel32s0mrDcaWfovrq3Vc9OTvHj/Tb0Xzh6JxQwNyxtIgPXpqqJk94fDM+1Oh6CaEF4QTiIOGJ/DdQtBObsEmGxbll/rkCyDPDwMzW4XhHD88EH0NcRxDUeX4/qdnsi0s8Aas+kEp8Zg82pMkmpDigKbjSbQTD7hFL94/jin9ZRHBNLo3Wrt+uUkbzQsiEZVMPGKfv76DaawodnahkhY86+PNnXxs77ZgVOjMahWVuufi1NJRZhWvvT0beHGtQn++Nm7en+DzqXO8vfVxX+wsYnT/JWxWEe95P0eILsvkkdPKn4PUEBJmunILab5992PLVU++skoNmOniT7JX2Fkt5GM1EjqbMohXzQmqo7KwCQ6zYKiabu30PpQAnZ0HKSRMcMRwnBddw4ZOO4GLRYKFFdDhrrteTMMdWB9/QTdH8sIp0EKmNT4GWDjGZAPJ3TcrbBv+ibfwtwDqBvzYck/truxYjjLZRDflwLt7JUmEoAymdPV7INa5IXn0Uw+4f8PIqATMLQIWpQ0E/RFTmQ4nLx0B1Zfzrsr5eAmbLQW2hYpHwkcqfegNBJhzwY9sGC4aCZaF81CAvePAAMAcwtApJX/Wo0AAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createLeftIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAe9JREFUeNqkUz1oE2EYfu7uuyRKLCFt6g+4VNQWWod+mQRRR1En0UFOHKoNCMKNju4SEQsOzsFNcRGl4CS42AzaKhKcsqhk0Etj7u+773y/6+USbOLSF5574b33eX+e906L4xh7MaYeC/c/IFcowMznEzDTBGPMoldnqEFtkPy708mIqvHHe0s7BcaYJYSwRwPu9vbYRH1XJI4tEYb2jYtHOHko9LvdxE9cYZQcBoF9+9oJ7jgRQt+HFAJSyv9rkO6UkGvXF3mr9QelkpkUINsYR6T8Jrkay8i+b9+5yfnmppMmSFw6e4yrIynBBsdS3jQ1PH/zeTiBIt+9dZpvbTlZh1+Oh/Z3F33XRUj7R1GUxA3DwMx0EYHnDUUMPe9Rfe1tc26uiL6M8aXno+UH6O7PIShPIapMQx6sQMxW4JbL+MkKCKhwNgGN2FD7Pnz82j63coF/aoc4ekDHtxfrzUniaZrW/FfEBomI9Scv7fnVq7zdBwIqajBWpeTd99d3vgBNCaQSzMOLyJ+6ApSPWxSzD61a/MfThupSjVuvxk2A3sazYYGBGbML0OcvW9rMyeRLFO8eVGXnKyacMiug5ikSplLs05dXzqNQWpbv6/URjpK+m6JH3GhQQI2QI+RTmBO0EwQ/RUBcqe31d/4rwAB0lPTXqN6HzgAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createRightIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAfBJREFUeNqkUz1s00AU/hwSh1SEhiFCYuhCVSExgHRiYKjEVCEyMMGAsjCxZunesWM7dIgEA8JISPyoUhFDFoZOSE2GgtrSIAYWSEPb1HUS23c+8+7iuE5/JKQ+6fOdz/e+970fG2EY4jyWVo9b819hGEZ8WCgW4z2dV2lZFUJYgnNwz9PwXRebc3cGBMfN6XSQy+eHryyCMuv43dRpBCpSz7b1qlB+cI3RWkEYlv+LQFkgBLxuV8s9OAhQLk0w7vsnSHQKVMhqQuYRSRBouK5AqyXwpHSdvfywUYkKb8UEFIU9fXybOY6A+jbszGAP7O/7RBKg2eR4dH+KvV5ej0k0gaqobXO0214c3acUDnt99Pp9cKqDUqLsx68LuHd3gtU+b1eOCOiSaaZQKJjgMsSOy7EnJcSYCZnLwKbojic1weTVMXz81KhTexeSKdSXqrUzh2X84Qxr9SQmx1P48q6mnTPZrJUs4jMp5QlHlSd1Y203fRGFK8DPV28HzqZpjXShW3+D00bamCrpNU9DuvvcGsjea1rO+nvw39+AxRCGckyO8ciQFG8gPT27ptX8/b4gt1asYGdzRGE6MVCXCJcj5NShbG9B/NnYhttpyMYL5XmTYEdw1KgMFSgJJiEbIXNGPQXBi+CTrzTO+zv/E2AA3Y8Nbp4Kn1sAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createColumnVisibleIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAdhJREFUeNrUk01LAlEUhu845QdRUxZBhIIWtFBso2AwRAVNLqKltHCb63b9A/9AixZCELhyYdAmEyYCBcOlNa1CSQoxog/DMY3x9p5B27Zw1YGH8XrO+55759wROOdsmLCwIWNoAwFh/ugfZQKsAQV4gbNf9woqIAeuQHOgGxgIMNix2Wx7iqIsxmKxWU3TxgqFgpWSsix3fT5fK5VKPedyuftOp5OE7oz60hHsYD8UCh3k83k5k8ksGYYx5XK5rK2WzgiIrPQf5aiGakljakVRjKDrZaPR6Oi6zglVVTlFMnnMZXmdK8o2x674IE+1pCHtCFx2w+GwE9u3drtd81yJRAKdDXZ4eGSuFxb87PHxjg3yVEsaNNolg5NSqTTVbDaX7Agq8Hg8TFWLbGVl0xTY7TY2Our5NfhCQPNAWtFisdSr1WqvWCwawWBwRpKkcZyXadoN83qXmSQ50V1jGxurpnGlUqnH4/FzvItTmoo5ApjQNMIOh2MrEon4o9Gov1arzZXL5XHKBwKBT7fbXU+n07fZbPa23W5f4BVd93o9TgYimATTMHHCbB5PN9ZSf0LmrsEHRDWInvB8w/oFvAv920iFDkBzF/64fHTjvoFOxsL//5h+BBgAwjbgRLl5ImwAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createColumnHiddenIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZGNDRBMkJENkU3MTFFNUIwOTBGRTc0MTA3OTI2OEYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZGNDRBMkNENkU3MTFFNUIwOTBGRTc0MTA3OTI2OEYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RkY0NEEyOUQ2RTcxMUU1QjA5MEZFNzQxMDc5MjY4RiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RkY0NEEyQUQ2RTcxMUU1QjA5MEZFNzQxMDc5MjY4RiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjQ0mkwAAACISURBVHjaYvz//z8DJYCJgUIwDAxgKSwspMwAIOYDYlcgtgNiJSBWBGJhIGaHyoHAJyD+CcRvgfg+EN8D4kNAvBtkwGEg1iNgkSCUlgBibSg7D4gvgwywRXKBChArALEIELMCsQBU8Qcg/g3Eb4D4ARDfBeKDMBeAnLcWikkGjKMpcRAYABBgACqXGpPEq63VAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createColumnIndeterminateIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUY1QTkyNDUxRTkzMTFFNkFEQzVDNjE1NDE4RDlEQUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUY1QTkyNDYxRTkzMTFFNkFEQzVDNjE1NDE4RDlEQUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5RjVBOTI0MzFFOTMxMUU2QURDNUM2MTU0MThEOURBQyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5RjVBOTI0NDFFOTMxMUU2QURDNUM2MTU0MThEOURBQyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Por9Q7gAAAGzSURBVHja1JOxSwJRHMffqXcqSoVBQ0FDNN7iIBxO5WA3NYoEjm0u/T2Bkw2ONZlgNEk4Bw6GiGiippmRnp76+n4PbWhpcOoHH57P+36/7/e8n4qUUmxSLrFhbRygoJwPq6tsgRMQB0cgtNINQA0UwCMYrX3rAAUB516v9zIejx+nUqm90WgUDIfDaq1WE9PpdK6q6mc2m+0WCoUX7K/hu+O5TPCBq0gkUiqXy0PbtqVlWXK5XDqwuE4mEzmfzyU11NJDr3C73SZOfeh0OtPxeCyR7oixlzhdVqtV2ev1nCB+Tw219NDrQRtJwzBCaF+bzWbsSGQyGVEsFoWmacLj8YjBYCBisZhIp9MC3Qhq6YEmyQ5OTdO8bTQak263K8m69d+FIOc5tfTQywAvTrmIRqM3pVLptd1uy3q9/nN3slgsZLPZlHxGDbX00Ou8ApfLxbdh+P3+MyTriURC7/f7+7hCsFKpCF3XvwKBQCuXyz3n8/ln/Bb3yH9iOAPcYAfsIiSEsAOsh9hvA99qDizwAVMDphbWd+zfwFBZTSOFfqBxJv4YPk6cDcYMVv7/n+lbgAEAtdcjOjP715MAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createGroupIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUVCNUI1OUNENkYwMTFFNThGNjJDNUE3ODIwMEZERDciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUVCNUI1OURENkYwMTFFNThGNjJDNUE3ODIwMEZERDciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1RUI1QjU5QUQ2RjAxMUU1OEY2MkM1QTc4MjAwRkRENyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1RUI1QjU5QkQ2RjAxMUU1OEY2MkM1QTc4MjAwRkRENyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PlkCTGoAAACDSURBVHjaYmRgYPjPgBswQun/+BT8X3x5DoZErG4KCj/3/DcMNZMNuRiYGPADRiRX4HYBJV5AB0QrhAGW//8hehgZES6FiaGLYzUAq7sxNf0nxQCsinHFAguegCPKBYxoYfAfWQxNnPgwINJVYMDEQCEYfLHASGoKRQlxPN7BqQggwAAN+SopPnDCwgAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createPivotIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAitJREFUeNqcU01rE1EUPfPVJjFqdYw2pJQkNS2hYhQUiwj+AaugKFYUBWutG3HjokgNrroRKYKbglBBFF0o1IW404qClGIDxpYKTQgULZJmmpiYkPnwvmtNspPmweOcmXnnvPPufSOdjsf7AfjR3PiOU6OjV50mh9CqtmVJDlkNjWU3tPXEiA6hlS3Lkm3HQbFYxO5hnTF0pQ3Bwa3MAxc98F9wMd95TsOOswpzoRFa1TJNyaKHtTUD07cNdv9wx6jtNDNW53N369xyOiC0qmmanMAwcjh+/yimrr/D28kjf8WLizjY3c38YzKJw729zKcTCU4gtLUE+Xwejy+94gWfl5agKQr8uo4Eccu2USr48SWVQq5QWE/gcAJZuIgF5XIF5yf7GfcGg9Cos4O3UoiFw2jFLrx+/wtRet+3nkJoOAEbkJtty5g484I+yUivrODekxb4tmuInZhCuFPHyHAXZubnUTXNWgKhlc1qlY+gaZsw9PwkY4fPhxsDXvxcrWL25TE8G+8DFAOxSAQHotG6AWlrRXS52vD08ifGr5kM1+BBPIBkOo3flQpaNA2zCwug+8MGdkMCPoLbvQ0DDw8xRgIBBNvbsUoF6yK+h+pQJpN91JH9PT2NCWS1Ui4rNhtswZubPxi/LS9TTWxemKTK/9t1jtramEBo1Vw226pRvEfj3oaL6v3vVRYaoZXcodA12ePpbOZXtEuljEToprmZprpBvehn4Y8AAwDB0mLL0M405wAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createAggregationIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNpi/P//PwMlgImBQjDwBrCgmMYENq8RiLVxqL8KxPX//v1DiIACEYYZGRlBmBOIe4B4PRDrQMUYoGyQGIoebAbADJkAxFuAWA9JXJdYA0CYC4inAPFOINZHlkPWgxKIcFMhQA0aFveB+DbOUERxDhQAbTEC4qNAPBfqEmRx3F6AAhOgojNAvBikGckumDiKHhY0B3ECcTVQQhRIg/B1NNeeB1IgQ7/BXYvmdE6oAnYcPv4NxF+BerAbMDTzAkCAAQChYIl8b86M1gAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createGroupIcon12 = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTNFQzE0NTdEOTk1MTFFNUI4MjJGMjBFRDk4MkMxNjAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTNFQzE0NThEOTk1MTFFNUI4MjJGMjBFRDk4MkMxNjAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxM0VDMTQ1NUQ5OTUxMUU1QjgyMkYyMEVEOTgyQzE2MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxM0VDMTQ1NkQ5OTUxMUU1QjgyMkYyMEVEOTgyQzE2MCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PiInRbAAAAEjSURBVHjaYuTi5XqkpKvI9/fXHwZWDlaGZ/eeM7x59raDAQj4pOQrBBUVGP78+MfAzMbE8PLKhU8Mhnb6/6//P/f/8N/d/x8AWUn1cf+BaleCsFPt5P/T/v//3/zj//8JQFrB1vM/I5IN3EAbfgBt+Au0QRBqw3sMG0DiQMwPxFuB2BzKZmLAAViA+BOU/QOI7wPxRyhfCIhT0NT/ZETi7AZiZiD+DOXL6EdlGdkWFzF8evaDgUuIg2F9eiTYBrhuIJ4NxHegfDsgnobuJGQbNgBxMRDfhfLFgDgB3UnInPVALMxAACDbcBGItwDxAyhfCRismejBiuyHiUBsDMQmUL6cSXIJf0hTDsNboEN42RkYJth58TPisV0eaMNFdBsAAgwANVJzd8zQrUcAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createCutIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAlRJREFUeNqkU09okmEcfj6ThNRhjUEJDhxDZ1t4sI3lDrKDhESHpC6x6yBoh52GfcdBJDvtElEUdKhOSq1JjF0SabSton9OmIeRxVKIrUgdU5xvv8e+hXXYpRcefv+e5/mh7/tpSin8z9Gi0Sg0TTsv+edarfa+Wq2iUqmgXC6DudVqhd1uh81ma+UWi8Uv3G5ZPJ9MJmGq1+twOBynBOek6T9oG+fkkU8djymVSiGTyWBiYuL6QSb7YvLIp679+D0ej57NZpX8JD0QCPj7+vrgcrnAyJp9zskj3zD928Tr9er5fF5FIhFdiH4aMLJmn/N98R+Dq5qGSUFQwKFs1AuFggqFQrrT6bzIyJp9zoMGn7qWQU6ST4JNQeK3kd/n8+nFYlGFw+HFdDqtWLOfMHjk5wwDjckRwGYGeJVnBMdXgaNrbveJKysr/etu91pHtVo8BnyXWUnwsgHM7wAVX7MJ0cEmjWvW4eGzjpGRXnNnZ8cFeRi9pRI+dnXtjMbj/cLp57rG1tbPH0tLwd3l5QHp3RBU8E7Txr4MDb1V8bh60tOzfhN4vTc9rRYkCm4tGDX7nJNHPnWt/+CFpt1rF9emptScxKfA2DNZwThn9NtNWjoxMH1Tqru+va02NzbK47FY4PHMzJtdYPYD8OChGDCyZp9z8sinrnWXt4E7q4ODRbrelw0x2Xjyn1fImn3OySOfutYt+IDRSeCycAZeAYm7wKLkshR87A1+cILDAss4EDkNXJI8Ows8yin1nENn+5MXNA3hnpHzHBKYjWhqe4lffwkwAMRcPMqRQZ4vAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createCopyIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgBJREFUeNqMk79rFEEcxd/M7V2QAzVFEOMFGwNiIGCjEdIEhYODmEawsFf8G4QQSCPYyqUWCdhY2qSQECSpInvFJYT8Ki6dZO8Sb2P29pfvu+4sm+UKv/AYZna/b95ndla9WFyEUmoewG0Mr+9hGB5EYYhypZIseO0fCHa3sP/LhxVFkazd+by0tOIFAQac+3w5imPYto1Pa2tv+VxR+8bRuv8EevIRxn5uQoszpWI2RjSIBgMMLi/hui76/T6+Li+v8Pkz9k0Wo409pFHAJooUCiWqYlk46nTQ2ttD+/gY75pNPKjVmmfd7gf2vKbu5U0sMWBpzWatNcAkv7n789lZ1GdmMqQ3cbxApIUikg58H5S0JgkSE/L/L1JmoNJmMZEDzCNdK5cxwtFxHHxcXcXTqalm27Zf7rRaRKBBhkAhxcgjiYlUo16HfKlqtYpv29u95Az81EClCFLyaQ0SCib/dtNJ6qsGfDmJnRqoXIKiyVUDz8sSSGy5VnI3ikh5k1KplBnog/V19BxnRCZmV15dGCSdO1wziphcS3rrT7d71zk5Ob8+Pf3eMN4aH3/8qtGYM0hp7iyJbO0bBOrMPTz8kl6OpGoTEzEncwapaCLrRNfu6Wli0Etl6mbfdb0MiYrlXsjZyAUTE0qwOxsbo9aQ3/dGEWlYRRcX5xxG/wowAC8cIjzfyA4lAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createPasteIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAadJREFUeNpinGLPAAaMjAxwcJ9Tk+0Bt7YPkCkKFXqt8PXqFsXv13/B1Pz/D6FZENoYZgKxMYgh9OI6i567q5hFUp4kiH9i3qTnT3auqWPgZ/gDVXsWiNPBFk+2hxtwxi0syfjy5csM0vFzGTg42Bj4+XnAEh8/fmH48eMXw9OFyQy6uroMu1bNAxlgAnbB338IJ6hlzWU4uXgJw6FDO4Ga+Rl4eXkZWFlZGb58/crw6eNHBjG7Iga1yAiG7SvmwfWw/P2LMADkraiYaIb79+4xYAOKSkpgNch6UFzwFxgy//79Y5BTUMBqwF+g3H8mJgZkPSgu+Ac04M+/fwz4AAswulBc8Ocfqg1/kGWxAEagAch6WP78RfUCIQOYmJkZ/qC44A+qAb8JeIEZZMkfXC4gwgsQNUgG/CbRC2BXIhvw8AsDgzQnkgEEvACxBMJ++h0YJmufMTA8ABry8xckGkFOxIdBakBqQXpAekGZiXPTSwbeUAEgB5hsObm58acDoJp3nxkYNn1gEANyP4MNAGKxh18ZbsXxsjMQA97/Z7gF0gPEfwACDAB/y9xB1I3/FQAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createMenuIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjM3MUVBMzlERkJEMTFFNUEwMjFFNDJDMDlCMUY3OTciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjM3MUVBM0FERkJEMTFFNUEwMjFFNDJDMDlCMUY3OTciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCMzcxRUEzN0RGQkQxMUU1QTAyMUU0MkMwOUIxRjc5NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCMzcxRUEzOERGQkQxMUU1QTAyMUU0MkMwOUIxRjc5NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pux7nZcAAAGtSURBVHjalFM9a8JQFL0veYkfYJUQEYuIIF07uToVpGuHOgid3dJN+i+K4C6CXQqFjplcCoKbXZ0EqRUFP/CTxCS9NzTdNOmBx32P3Nx3zj33sXq9/tRqtbRYLCaLomhBANi2La5WK7NSqTRYNpt1LMsCLACO47iLMXY2CoIAm80GZFkGoVQqfWy3WzBNE6gQVveNhmHAbreDYrHYZaPRKKTr+i0ykTDBPnUzgfYEvFkYDAZWoVDQWb/fB9QD6XQajscjBCkQDodhOBzCcrkEVq1WXfoEL9EPlEdSZrMZ8Pl8frVYLO7QgRB+sPx+/GUk4qUGNvOdYSO+JpPJJdHyc8ADnUluIpH45vv9XiFbiFIQC71IjuBe5ZlM5gYlPHLOL7C4AcEgofXbXC7X4PF4vKuqahf+AWJxOBwgEokA6/V67kFRFFcGLU/SqShJkusATSNbr9fQ6XSuU6mUQP3BBIaJZyM6BuPx2Mnn85+sVqu9ttvt+2QyGXgOqInT6RTK5fIbwwl0iFI0Gv2btCA9QPdcOVzTtOdms/mAnnKkaAexES0UcG/hc375EWAA94tOP0vEOEcAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createCheckboxCheckedIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBRkJCRDU1MTEyM0ExMUU2ODE4MUUyOTNBNTRGQkIxNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBRkJCRDU1MDEyM0ExMUU2ODE4MUUyOTNBNTRGQkIxNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+riMaEQAAAL5JREFUeNqUks0JhDAQhSd7tgtLMDUIyTXF2IdNWIE3c0ruYg9LtgcPzvpEF8SfHR8MGR75hpcwRERmrjQXCyutDKUQAkuFu2AUpsyiJ1JK0UtycRgGMsbsPBFYVRVZaw/+7Zu895znOY/j+PPWT7oGp2lirTU3TbPz/4IAAGLALeic47Ztlx7RELHrusPAAwgoy7LlrOuay7I8TXIadYOLouC+7+XgBiP2lTbw0crFGAF9ANq1kS75G8xXgAEAiqu9OeWZ/voAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createCheckboxUncheckedIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MkU1Rjk1NDExNDExMUU2ODhEQkMyRTJGOUNGODYyQyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MkU1Rjk1MzExNDExMUU2ODhEQkMyRTJGOUNGODYyQyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjI1MkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+t+CXswAAAFBJREFUeNrsksENwDAIA023a9YGNqlItkixlAFIn1VOMv5wvACAOxOZWUwsB6Gqswp36QivJNhBRHDhI0f8j9jNrCy4O2twNMobT/7QeQUYAFaKU1yE2OfhAAAAAElFTkSuQmCC';
        return eImg;
    };
    SvgFactory.prototype.createCheckboxIndeterminateIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGMjU4MzhGQjEyM0ExMUU2QjAxM0Q2QjZFQ0IzNzM4NiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGMjU4MzhGQTEyM0ExMUU2QjAxM0Q2QjZFQ0IzNzM4NiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+2Xml2QAAAGBJREFUeNpiYGBg8ATiZ0D8n0j8DKqH4dnhw4f/EwtAakF6GEGmAAEDKYCRkZGBiYFMQH+NLNjcjw2ghwMLIQWDx48Do/H5kSNHiNZw9OhREPUCRHiBNJOQyJ+A9AAEGACqkFldNkPUwwAAAABJRU5ErkJggg==';
        return eImg;
    };
    SvgFactory.prototype.createGroupExpandedIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzBBODQ4M0ExMjM4MTFFNkFDNEJDMjUzQUJBQ0I2QjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzBBODQ4M0IxMjM4MTFFNkFDNEJDMjUzQUJBQ0I2QjkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MEE4NDgzODEyMzgxMUU2QUM0QkMyNTNBQkFDQjZCOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MEE4NDgzOTEyMzgxMUU2QUM0QkMyNTNBQkFDQjZCOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhKAo60AAADVSURBVHjajFC9DkRgEJzzFhqiligURKcjR+UFJK7wGN7jOq+glXgCvSgUCnyVn47GHsVdcURsss3s7OzOPEzTdB3HeTPGeMMw0DQNOI4Dz/PI8xyWZSGO4y4MwxeSJGnruqarGseRNE1r4fv+YSgIwgErioJwpgrggHmeR7Bt+xZ5GAbCNE2/0zvpv78v6bpOUFX1lvK6roQz92dkWZYJiqLcSmOeZ9qDb6uqusx5WRaSJIlBFEUnTdNuC536vifXdaksSwqCgLIsoyiKdnNs23l+BBgAK/54I/P5bhMAAAAASUVORK5CYII=';
        return eImg;
    };
    SvgFactory.prototype.createGroupContractedIcon = function () {
        var eImg = document.createElement('img');
        eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0U2QUVBRDYxMjM4MTFFNjk3NjVBRUM0MUJDRjFCODgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0U2QUVBRDcxMjM4MTFFNjk3NjVBRUM0MUJDRjFCODgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RTZBRUFENDEyMzgxMUU2OTc2NUFFQzQxQkNGMUI4OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RTZBRUFENTEyMzgxMUU2OTc2NUFFQzQxQkNGMUI4OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhjzsKsAAADSSURBVHjajJAvioVgFMXPuAuLYhYMBsVmU54mNyA4wWW4j2luwSq4ArsYDAZ9X/JP0+KZ58CkgTffD264l3MPnPPh+34cRdGXEEL1PA/TNEFRFKiqirZtEQQByrJ85nn+iaqq5nEc+Y5t2+g4zow0TSlD13XEf66/JElChGEoJV7Xldj3/WfRNI0A/sx9v3Fdl7BtW8r5ui6CkpimSViWJSU+joN38fMwDG+F53nSMAwBXdejuq6fr9K5LAvjOGbf98yyjE3TsCiKO5x4/Ty+BRgA3R6JXc/jqsQAAAAASUVORK5CYII=';
        return eImg;
    };
    return SvgFactory;
})();
exports.SvgFactory = SvgFactory;
// i couldn't figure out how to not make these blurry
/*function createPlusMinus(plus: boolean) {
    var eSvg = document.createElementNS(SVG_NS, "svg");
    var size = "14";
    eSvg.setAttribute("width", size);
    eSvg.setAttribute("height", size);

    var eRect = document.createElementNS(SVG_NS, "rect");
    eRect.setAttribute('x', '1');
    eRect.setAttribute('y', '1');
    eRect.setAttribute('width', '12');
    eRect.setAttribute('height', '12');
    eRect.setAttribute('rx', '2');
    eRect.setAttribute('ry', '2');
    eRect.setAttribute('fill', 'none');
    eRect.setAttribute('stroke', 'black');
    eRect.setAttribute('stroke-width', '1');
    eRect.setAttribute('stroke-linecap', 'butt');
    eSvg.appendChild(eRect);

    var eLineAcross = document.createElementNS(SVG_NS, "line");
    eLineAcross.setAttribute('x1','2');
    eLineAcross.setAttribute('x2','12');
    eLineAcross.setAttribute('y1','7');
    eLineAcross.setAttribute('y2','7');
    eLineAcross.setAttribute('stroke','black');
    eLineAcross.setAttribute('stroke-width', '1');
    eLineAcross.setAttribute('stroke-linecap', 'butt');
    eSvg.appendChild(eLineAcross);

    if (plus) {
        var eLineDown = document.createElementNS(SVG_NS, "line");
        eLineDown.setAttribute('x1','7');
        eLineDown.setAttribute('x2','7');
        eLineDown.setAttribute('y1','2');
        eLineDown.setAttribute('y2','12');
        eLineDown.setAttribute('stroke','black');
        eLineDown.setAttribute('stroke-width', '1');
        eLineDown.setAttribute('stroke-linecap', 'butt');
        eSvg.appendChild(eLineDown);
    }

    return eSvg;
}*/
function createPolygonSvg(points, width) {
    var eSvg = createIconSvg(width);
    var eDescIcon = document.createElementNS(SVG_NS, "polygon");
    eDescIcon.setAttribute("points", points);
    eSvg.appendChild(eDescIcon);
    return eSvg;
}
// util function for the above
function createIconSvg(width) {
    var eSvg = document.createElementNS(SVG_NS, "svg");
    if (width > 0) {
        eSvg.setAttribute("width", width);
        eSvg.setAttribute("height", width);
    }
    else {
        eSvg.setAttribute("width", "10");
        eSvg.setAttribute("height", "10");
    }
    return eSvg;
}
function createCircle(fill) {
    var eSvg = createIconSvg();
    var eCircle = document.createElementNS(SVG_NS, "circle");
    eCircle.setAttribute("cx", "5");
    eCircle.setAttribute("cy", "5");
    eCircle.setAttribute("r", "5");
    eCircle.setAttribute("stroke", "black");
    eCircle.setAttribute("stroke-width", "2");
    if (fill) {
        eCircle.setAttribute("fill", "black");
    }
    else {
        eCircle.setAttribute("fill", "none");
    }
    eSvg.appendChild(eCircle);
    return eSvg;
}

},{}],155:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var TemplateService = (function () {
    function TemplateService() {
        this.templateCache = {};
        this.waitingCallbacks = {};
    }
    // returns the template if it is loaded, or null if it is not loaded
    // but will call the callback when it is loaded
    TemplateService.prototype.getTemplate = function (url, callback) {
        var templateFromCache = this.templateCache[url];
        if (templateFromCache) {
            return templateFromCache;
        }
        var callbackList = this.waitingCallbacks[url];
        var that = this;
        if (!callbackList) {
            // first time this was called, so need a new list for callbacks
            callbackList = [];
            this.waitingCallbacks[url] = callbackList;
            // and also need to do the http request
            var client = new XMLHttpRequest();
            client.onload = function () {
                that.handleHttpResult(this, url);
            };
            client.open("GET", url);
            client.send();
        }
        // add this callback
        if (callback) {
            callbackList.push(callback);
        }
        // caller needs to wait for template to load, so return null
        return null;
    };
    TemplateService.prototype.handleHttpResult = function (httpResult, url) {
        if (httpResult.status !== 200 || httpResult.response === null) {
            console.warn('Unable to get template error ' + httpResult.status + ' - ' + url);
            return;
        }
        // response success, so process it
        // in IE9 the response is in - responseText
        this.templateCache[url] = httpResult.response || httpResult.responseText;
        // inform all listeners that this is now in the cache
        var callbacks = this.waitingCallbacks[url];
        for (var i = 0; i < callbacks.length; i++) {
            var callback = callbacks[i];
            // we could pass the callback the response, however we know the client of this code
            // is the cell renderer, and it passes the 'cellRefresh' method in as the callback
            // which doesn't take any parameters.
            callback();
        }
        if (this.$scope) {
            var that = this;
            setTimeout(function () {
                that.$scope.$apply();
            }, 0);
        }
    };
    __decorate([
        context_2.Autowired('$scope'), 
        __metadata('design:type', Object)
    ], TemplateService.prototype, "$scope", void 0);
    TemplateService = __decorate([
        context_1.Bean('templateService'), 
        __metadata('design:paramtypes', [])
    ], TemplateService);
    return TemplateService;
})();
exports.TemplateService = TemplateService;

},{"./context/context":87}],156:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FUNCTION_STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var FUNCTION_ARGUMENT_NAMES = /([^\s,]+)/g;
var Utils = (function () {
    function Utils() {
    }
    Utils.iterateObject = function (object, callback) {
        if (this.missing(object)) {
            return;
        }
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = object[key];
            callback(key, value);
        }
    };
    Utils.cloneObject = function (object) {
        var copy = {};
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = object[key];
            copy[key] = value;
        }
        return copy;
    };
    Utils.map = function (array, callback) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
            var item = array[i];
            var mappedItem = callback(item);
            result.push(mappedItem);
        }
        return result;
    };
    Utils.mapObject = function (object, callback) {
        var result = [];
        Utils.iterateObject(object, function (key, value) {
            result.push(callback(value));
        });
        return result;
    };
    Utils.forEach = function (array, callback) {
        if (!array) {
            return;
        }
        for (var i = 0; i < array.length; i++) {
            var value = array[i];
            callback(value, i);
        }
    };
    Utils.filter = function (array, callback) {
        var result = [];
        array.forEach(function (item) {
            if (callback(item)) {
                result.push(item);
            }
        });
        return result;
    };
    Utils.assign = function (object, source) {
        if (this.exists(source)) {
            this.iterateObject(source, function (key, value) {
                object[key] = value;
            });
        }
    };
    Utils.getFunctionParameters = function (func) {
        var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES);
        if (result === null) {
            return [];
        }
        else {
            return result;
        }
    };
    Utils.find = function (collection, predicate, value) {
        if (collection === null || collection === undefined) {
            return null;
        }
        var firstMatchingItem;
        for (var i = 0; i < collection.length; i++) {
            var item = collection[i];
            if (typeof predicate === 'string') {
                if (item[predicate] === value) {
                    firstMatchingItem = item;
                    break;
                }
            }
            else {
                var callback = predicate;
                if (callback(item)) {
                    firstMatchingItem = item;
                    break;
                }
            }
        }
        return firstMatchingItem;
    };
    Utils.toStrings = function (array) {
        return this.map(array, function (item) {
            if (item === undefined || item === null || !item.toString) {
                return null;
            }
            else {
                return item.toString();
            }
        });
    };
    Utils.iterateArray = function (array, callback) {
        for (var index = 0; index < array.length; index++) {
            var value = array[index];
            callback(value, index);
        }
    };
    //Returns true if it is a DOM node
    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    Utils.isNode = function (o) {
        return (typeof Node === "function" ? o instanceof Node :
            o && typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string");
    };
    //Returns true if it is a DOM element
    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    Utils.isElement = function (o) {
        return (typeof HTMLElement === "function" ? o instanceof HTMLElement :
            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string");
    };
    Utils.isNodeOrElement = function (o) {
        return this.isNode(o) || this.isElement(o);
    };
    //adds all type of change listeners to an element, intended to be a text field
    Utils.addChangeListener = function (element, listener) {
        element.addEventListener("changed", listener);
        element.addEventListener("paste", listener);
        element.addEventListener("input", listener);
        // IE doesn't fire changed for special keys (eg delete, backspace), so need to
        // listen for this further ones
        element.addEventListener("keydown", listener);
        element.addEventListener("keyup", listener);
    };
    //if value is undefined, null or blank, returns null, otherwise returns the value
    Utils.makeNull = function (value) {
        if (value === null || value === undefined || value === "") {
            return null;
        }
        else {
            return value;
        }
    };
    Utils.missing = function (value) {
        return !this.exists(value);
    };
    Utils.missingOrEmpty = function (value) {
        return this.missing(value) || value.length === 0;
    };
    Utils.exists = function (value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        else {
            return true;
        }
    };
    Utils.existsAndNotEmpty = function (value) {
        return this.exists(value) && value.length > 0;
    };
    Utils.removeAllChildren = function (node) {
        if (node) {
            while (node.hasChildNodes()) {
                node.removeChild(node.lastChild);
            }
        }
    };
    Utils.removeElement = function (parent, cssSelector) {
        this.removeFromParent(parent.querySelector(cssSelector));
    };
    Utils.removeFromParent = function (node) {
        if (node && node.parentNode) {
            node.parentNode.removeChild(node);
        }
    };
    Utils.isVisible = function (element) {
        return (element.offsetParent !== null);
    };
    /**
     * loads the template and returns it as an element. makes up for no simple way in
     * the dom api to load html directly, eg we cannot do this: document.createElement(template)
     */
    Utils.loadTemplate = function (template) {
        var tempDiv = document.createElement("div");
        tempDiv.innerHTML = template;
        return tempDiv.firstChild;
    };
    Utils.addOrRemoveCssClass = function (element, className, addOrRemove) {
        if (addOrRemove) {
            this.addCssClass(element, className);
        }
        else {
            this.removeCssClass(element, className);
        }
    };
    Utils.callIfPresent = function (func) {
        if (func) {
            func();
        }
    };
    Utils.addCssClass = function (element, className) {
        var _this = this;
        if (!className || className.length === 0) {
            return;
        }
        if (className.indexOf(' ') >= 0) {
            className.split(' ').forEach(function (value) { return _this.addCssClass(element, value); });
            return;
        }
        if (element.classList) {
            element.classList.add(className);
        }
        else {
            if (element.className && element.className.length > 0) {
                var cssClasses = element.className.split(' ');
                if (cssClasses.indexOf(className) < 0) {
                    cssClasses.push(className);
                    element.className = cssClasses.join(' ');
                }
            }
            else {
                element.className = className;
            }
        }
    };
    Utils.containsClass = function (element, className) {
        if (element.classList) {
            // for modern browsers
            return element.classList.contains(className);
        }
        else if (element.className) {
            // for older browsers, check against the string of class names
            // if only one class, can check for exact match
            var onlyClass = element.className === className;
            // if many classes, check for class name, we have to pad with ' ' to stop other
            // class names that are a substring of this class
            var contains = element.className.indexOf(' ' + className + ' ') >= 0;
            // the padding above then breaks when it's the first or last class names
            var startsWithClass = element.className.indexOf(className + ' ') === 0;
            var endsWithClass = element.className.lastIndexOf(' ' + className) === (element.className.length - className.length - 1);
            return onlyClass || contains || startsWithClass || endsWithClass;
        }
        else {
            // if item is not a node
            return false;
        }
    };
    Utils.getElementAttribute = function (element, attributeName) {
        if (element.attributes) {
            if (element.attributes[attributeName]) {
                var attribute = element.attributes[attributeName];
                return attribute.value;
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    };
    Utils.offsetHeight = function (element) {
        return element && element.clientHeight ? element.clientHeight : 0;
    };
    Utils.offsetWidth = function (element) {
        return element && element.clientWidth ? element.clientWidth : 0;
    };
    Utils.removeCssClass = function (element, className) {
        if (element.className && element.className.length > 0) {
            var cssClasses = element.className.split(' ');
            var index = cssClasses.indexOf(className);
            if (index >= 0) {
                cssClasses.splice(index, 1);
                element.className = cssClasses.join(' ');
            }
        }
    };
    Utils.removeFromArray = function (array, object) {
        if (array.indexOf(object) >= 0) {
            array.splice(array.indexOf(object), 1);
        }
    };
    Utils.insertIntoArray = function (array, object, toIndex) {
        array.splice(toIndex, 0, object);
    };
    Utils.moveInArray = function (array, objectsToMove, toIndex) {
        var _this = this;
        // first take out it items from the array
        objectsToMove.forEach(function (obj) {
            _this.removeFromArray(array, obj);
        });
        // now add the objects, in same order as provided to us, that means we start at the end
        // as the objects will be pushed to the right as they are inserted
        objectsToMove.slice().reverse().forEach(function (obj) {
            _this.insertIntoArray(array, obj, toIndex);
        });
    };
    Utils.defaultComparator = function (valueA, valueB) {
        var valueAMissing = valueA === null || valueA === undefined;
        var valueBMissing = valueB === null || valueB === undefined;
        if (valueAMissing && valueBMissing) {
            return 0;
        }
        if (valueAMissing) {
            return -1;
        }
        if (valueBMissing) {
            return 1;
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
    };
    Utils.formatWidth = function (width) {
        if (typeof width === "number") {
            return width + "px";
        }
        else {
            return width;
        }
    };
    Utils.formatNumberTwoDecimalPlacesAndCommas = function (value) {
        // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
        if (typeof value === 'number') {
            return (Math.round(value * 100) / 100).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
        }
        else {
            return '';
        }
    };
    /**
     * If icon provided, use this (either a string, or a function callback).
     * if not, then use the second parameter, which is the svgFactory function
     */
    Utils.createIcon = function (iconName, gridOptionsWrapper, column, svgFactoryFunc) {
        var eResult = document.createElement('span');
        eResult.appendChild(this.createIconNoSpan(iconName, gridOptionsWrapper, column, svgFactoryFunc));
        return eResult;
    };
    Utils.createIconNoSpan = function (iconName, gridOptionsWrapper, colDefWrapper, svgFactoryFunc) {
        var userProvidedIcon;
        // check col for icon first
        if (colDefWrapper && colDefWrapper.getColDef().icons) {
            userProvidedIcon = colDefWrapper.getColDef().icons[iconName];
        }
        // it not in col, try grid options
        if (!userProvidedIcon && gridOptionsWrapper.getIcons()) {
            userProvidedIcon = gridOptionsWrapper.getIcons()[iconName];
        }
        // now if user provided, use it
        if (userProvidedIcon) {
            var rendererResult;
            if (typeof userProvidedIcon === 'function') {
                rendererResult = userProvidedIcon();
            }
            else if (typeof userProvidedIcon === 'string') {
                rendererResult = userProvidedIcon;
            }
            else {
                throw 'icon from grid options needs to be a string or a function';
            }
            if (typeof rendererResult === 'string') {
                return this.loadTemplate(rendererResult);
            }
            else if (this.isNodeOrElement(rendererResult)) {
                return rendererResult;
            }
            else {
                throw 'iconRenderer should return back a string or a dom object';
            }
        }
        else {
            // otherwise we use the built in icon
            if (svgFactoryFunc) {
                return svgFactoryFunc();
            }
            else {
                return null;
            }
        }
    };
    Utils.addStylesToElement = function (eElement, styles) {
        if (!styles) {
            return;
        }
        Object.keys(styles).forEach(function (key) {
            eElement.style[key] = styles[key];
        });
    };
    Utils.getScrollbarWidth = function () {
        var outer = document.createElement("div");
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
        document.body.appendChild(outer);
        var widthNoScroll = outer.offsetWidth;
        // force scrollbars
        outer.style.overflow = "scroll";
        // add innerdiv
        var inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        var widthWithScroll = inner.offsetWidth;
        // remove divs
        outer.parentNode.removeChild(outer);
        return widthNoScroll - widthWithScroll;
    };
    Utils.isKeyPressed = function (event, keyToCheck) {
        var pressedKey = event.which || event.keyCode;
        return pressedKey === keyToCheck;
    };
    Utils.setVisible = function (element, visible, visibleStyle) {
        if (visible) {
            if (this.exists(visibleStyle)) {
                element.style.display = visibleStyle;
            }
            else {
                element.style.display = 'inline';
            }
        }
        else {
            element.style.display = 'none';
        }
    };
    Utils.isBrowserIE = function () {
        if (this.isIE === undefined) {
            this.isIE = false || !!document.documentMode; // At least IE6
        }
        return this.isIE;
    };
    Utils.isBrowserSafari = function () {
        if (this.isSafari === undefined) {
            this.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
        }
        return this.isSafari;
    };
    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
    Utils.getBodyWidth = function () {
        if (document.body) {
            return document.body.clientWidth;
        }
        if (window.innerHeight) {
            return window.innerWidth;
        }
        if (document.documentElement && document.documentElement.clientWidth) {
            return document.documentElement.clientWidth;
        }
        return -1;
    };
    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
    Utils.getBodyHeight = function () {
        if (document.body) {
            return document.body.clientHeight;
        }
        if (window.innerHeight) {
            return window.innerHeight;
        }
        if (document.documentElement && document.documentElement.clientHeight) {
            return document.documentElement.clientHeight;
        }
        return -1;
    };
    Utils.setCheckboxState = function (eCheckbox, state) {
        if (typeof state === 'boolean') {
            eCheckbox.checked = state;
            eCheckbox.indeterminate = false;
        }
        else {
            // isNodeSelected returns back undefined if it's a group and the children
            // are a mix of selected and unselected
            eCheckbox.indeterminate = true;
        }
    };
    Utils.traverseNodesWithKey = function (nodes, callback) {
        var keyParts = [];
        recursiveSearchNodes(nodes);
        function recursiveSearchNodes(nodes) {
            nodes.forEach(function (node) {
                if (node.group) {
                    keyParts.push(node.key);
                    var key = keyParts.join('|');
                    callback(node, key);
                    recursiveSearchNodes(node.childrenAfterGroup);
                    keyParts.pop();
                }
            });
        }
    };
    // Taken from here: https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
    /**
     * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
     * complicated, thus this doc is long and (hopefully) detailed enough to answer
     * your questions.
     *
     * If you need to react to the mouse wheel in a predictable way, this code is
     * like your bestest friend. * hugs *
     *
     * As of today, there are 4 DOM event types you can listen to:
     *
     *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
     *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
     *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
     *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
     *
     * So what to do?  The is the best:
     *
     *   normalizeWheel.getEventType();
     *
     * In your event callback, use this code to get sane interpretation of the
     * deltas.  This code will return an object with properties:
     *
     *   spinX   -- normalized spin speed (use for zoom) - x plane
     *   spinY   -- " - y plane
     *   pixelX  -- normalized distance (to pixels) - x plane
     *   pixelY  -- " - y plane
     *
     * Wheel values are provided by the browser assuming you are using the wheel to
     * scroll a web page by a number of lines or pixels (or pages).  Values can vary
     * significantly on different platforms and browsers, forgetting that you can
     * scroll at different speeds.  Some devices (like trackpads) emit more events
     * at smaller increments with fine granularity, and some emit massive jumps with
     * linear speed or acceleration.
     *
     * This code does its best to normalize the deltas for you:
     *
     *   - spin is trying to normalize how far the wheel was spun (or trackpad
     *     dragged).  This is super useful for zoom support where you want to
     *     throw away the chunky scroll steps on the PC and make those equal to
     *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
     *     resolve a single slow step on a wheel to 1.
     *
     *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
     *     get the crazy differences between browsers, but at least it'll be in
     *     pixels!
     *
     *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
     *     should translate to positive value zooming IN, negative zooming OUT.
     *     This matches the newer 'wheel' event.
     *
     * Why are there spinX, spinY (or pixels)?
     *
     *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
     *     with a mouse.  It results in side-scrolling in the browser by default.
     *
     *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
     *
     *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
     *     probably is by browsers in conjunction with fancy 3D controllers .. but
     *     you know.
     *
     * Implementation info:
     *
     * Examples of 'wheel' event if you scroll slowly (down) by one step with an
     * average mouse:
     *
     *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
     *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
     *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
     *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
     *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
     *
     * On the trackpad:
     *
     *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
     *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
     *
     * On other/older browsers.. it's more complicated as there can be multiple and
     * also missing delta values.
     *
     * The 'wheel' event is more standard:
     *
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
     *
     * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
     * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
     * backward compatibility with older events.  Those other values help us
     * better normalize spin speed.  Example of what the browsers provide:
     *
     *                          | event.wheelDelta | event.detail
     *        ------------------+------------------+--------------
     *          Safari v5/OS X  |       -120       |       0
     *          Safari v5/Win7  |       -120       |       0
     *         Chrome v17/OS X  |       -120       |       0
     *         Chrome v17/Win7  |       -120       |       0
     *                IE9/Win7  |       -120       |   undefined
     *         Firefox v4/OS X  |     undefined    |       1
     *         Firefox v4/Win7  |     undefined    |       3
     *
     */
    Utils.normalizeWheel = function (event) {
        var PIXEL_STEP = 10;
        var LINE_HEIGHT = 40;
        var PAGE_HEIGHT = 800;
        // spinX, spinY
        var sX = 0;
        var sY = 0;
        // pixelX, pixelY
        var pX = 0;
        var pY = 0;
        // Legacy
        if ('detail' in event) {
            sY = event.detail;
        }
        if ('wheelDelta' in event) {
            sY = -event.wheelDelta / 120;
        }
        if ('wheelDeltaY' in event) {
            sY = -event.wheelDeltaY / 120;
        }
        if ('wheelDeltaX' in event) {
            sX = -event.wheelDeltaX / 120;
        }
        // side scrolling on FF with DOMMouseScroll
        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ('deltaY' in event) {
            pY = event.deltaY;
        }
        if ('deltaX' in event) {
            pX = event.deltaX;
        }
        if ((pX || pY) && event.deltaMode) {
            if (event.deltaMode == 1) {
                pX *= LINE_HEIGHT;
                pY *= LINE_HEIGHT;
            }
            else {
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
            }
        }
        // Fall-back if spin cannot be determined
        if (pX && !sX) {
            sX = (pX < 1) ? -1 : 1;
        }
        if (pY && !sY) {
            sY = (pY < 1) ? -1 : 1;
        }
        return { spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY };
    };
    return Utils;
})();
exports.Utils = Utils;

},{}],157:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var gridOptionsWrapper_1 = require("./gridOptionsWrapper");
var expressionService_1 = require("./expressionService");
var columnController_1 = require("./columnController/columnController");
var context_1 = require("./context/context");
var context_2 = require("./context/context");
var context_3 = require("./context/context");
var utils_1 = require('./utils');
var events_1 = require("./events");
var eventService_1 = require("./eventService");
var ValueService = (function () {
    function ValueService() {
        this.initialised = false;
    }
    ValueService.prototype.init = function () {
        this.suppressDotNotation = this.gridOptionsWrapper.isSuppressFieldDotNotation();
        this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions();
        this.userProvidedTheGroups = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
        this.initialised = true;
    };
    ValueService.prototype.getValue = function (column, node) {
        return this.getValueUsingSpecificData(column, node.data, node);
    };
    ValueService.prototype.getValueUsingSpecificData = function (column, data, node) {
        // hack - the grid is getting refreshed before this bean gets initialised, race condition.
        // really should have a way so they get initialised in the right order???
        if (!this.initialised) {
            this.init();
        }
        var colDef = column.getColDef();
        var field = colDef.field;
        var result;
        // if there is a value getter, this gets precedence over a field
        // - need to revisit this, we check 'data' as this is the way for the grid to
        //   not render when on the footer row
        if (data && node.group && !this.userProvidedTheGroups) {
            result = node.data ? node.data[column.getId()] : undefined;
        }
        else if (colDef.valueGetter) {
            result = this.executeValueGetter(colDef.valueGetter, data, column, node);
        }
        else if (field && data) {
            result = this.getValueUsingField(data, field, column.isFieldContainsDots());
        }
        else {
            result = undefined;
        }
        // the result could be an expression itself, if we are allowing cell values to be expressions
        if (this.cellExpressions && (typeof result === 'string') && result.indexOf('=') === 0) {
            var cellValueGetter = result.substring(1);
            result = this.executeValueGetter(cellValueGetter, data, column, node);
        }
        return result;
    };
    ValueService.prototype.getValueUsingField = function (data, field, fieldContainsDots) {
        if (!field || !data) {
            return;
        }
        // if no '.', then it's not a deep value
        if (!fieldContainsDots) {
            return data[field];
        }
        else {
            // otherwise it is a deep value, so need to dig for it
            var fields = field.split('.');
            var currentObject = data;
            for (var i = 0; i < fields.length; i++) {
                currentObject = currentObject[fields[i]];
                if (utils_1.Utils.missing(currentObject)) {
                    return null;
                }
            }
            return currentObject;
        }
    };
    ValueService.prototype.setValue = function (rowNode, colKey, newValue) {
        var column = this.columnController.getOriginalColumn(colKey);
        if (!rowNode || !column) {
            return;
        }
        // this will only happen if user is trying to paste into a group row, which doesn't make sense
        // the user should not be trying to paste into group rows
        var data = rowNode.data;
        if (utils_1.Utils.missing(data)) {
            return;
        }
        var field = column.getColDef().field;
        var newValueHandler = column.getColDef().newValueHandler;
        // need either a field or a newValueHandler for this to work
        if (utils_1.Utils.missing(field) && utils_1.Utils.missing(newValueHandler)) {
            return;
        }
        var paramsForCallbacks = {
            node: rowNode,
            data: rowNode.data,
            oldValue: this.getValue(column, rowNode),
            newValue: newValue,
            colDef: column.getColDef(),
            api: this.gridOptionsWrapper.getApi(),
            context: this.gridOptionsWrapper.getContext()
        };
        if (newValueHandler) {
            newValueHandler(paramsForCallbacks);
        }
        else {
            this.setValueUsingField(data, field, newValue, column.isFieldContainsDots());
        }
        // reset quick filter on this row
        rowNode.resetQuickFilterAggregateText();
        paramsForCallbacks.newValue = this.getValue(column, rowNode);
        if (typeof column.getColDef().onCellValueChanged === 'function') {
            column.getColDef().onCellValueChanged(paramsForCallbacks);
        }
        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_VALUE_CHANGED, paramsForCallbacks);
    };
    ValueService.prototype.setValueUsingField = function (data, field, newValue, isFieldContainsDots) {
        // if no '.', then it's not a deep value
        if (!isFieldContainsDots) {
            data[field] = newValue;
        }
        else {
            // otherwise it is a deep value, so need to dig for it
            var fieldPieces = field.split('.');
            var currentObject = data;
            while (fieldPieces.length > 0 && currentObject) {
                var fieldPiece = fieldPieces.shift();
                if (fieldPieces.length === 0) {
                    currentObject[fieldPiece] = newValue;
                }
                else {
                    currentObject = currentObject[fieldPiece];
                }
            }
        }
    };
    ValueService.prototype.executeValueGetter = function (valueGetter, data, column, node) {
        var context = this.gridOptionsWrapper.getContext();
        var api = this.gridOptionsWrapper.getApi();
        var params = {
            data: data,
            node: node,
            colDef: column.getColDef(),
            api: api,
            context: context,
            getValue: this.getValueCallback.bind(this, data, node)
        };
        if (typeof valueGetter === 'function') {
            // valueGetter is a function, so just call it
            return valueGetter(params);
        }
        else if (typeof valueGetter === 'string') {
            // valueGetter is an expression, so execute the expression
            return this.expressionService.evaluate(valueGetter, params);
        }
    };
    ValueService.prototype.getValueCallback = function (data, node, field) {
        var otherColumn = this.columnController.getOriginalColumn(field);
        if (otherColumn) {
            return this.getValueUsingSpecificData(otherColumn, data, node);
        }
        else {
            return null;
        }
    };
    __decorate([
        context_2.Autowired('gridOptionsWrapper'), 
        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
    ], ValueService.prototype, "gridOptionsWrapper", void 0);
    __decorate([
        context_2.Autowired('expressionService'), 
        __metadata('design:type', expressionService_1.ExpressionService)
    ], ValueService.prototype, "expressionService", void 0);
    __decorate([
        context_2.Autowired('columnController'), 
        __metadata('design:type', columnController_1.ColumnController)
    ], ValueService.prototype, "columnController", void 0);
    __decorate([
        context_2.Autowired('eventService'), 
        __metadata('design:type', eventService_1.EventService)
    ], ValueService.prototype, "eventService", void 0);
    __decorate([
        context_3.PostConstruct, 
        __metadata('design:type', Function), 
        __metadata('design:paramtypes', []), 
        __metadata('design:returntype', void 0)
    ], ValueService.prototype, "init", null);
    ValueService = __decorate([
        context_1.Bean('valueService'), 
        __metadata('design:paramtypes', [])
    ], ValueService);
    return ValueService;
})();
exports.ValueService = ValueService;

},{"./columnController/columnController":77,"./context/context":87,"./eventService":98,"./events":99,"./expressionService":100,"./gridOptionsWrapper":109,"./utils":156}],158:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var utils_1 = require('../utils');
var eventService_1 = require("../eventService");
var Component = (function () {
    function Component(template) {
        this.destroyFunctions = [];
        this.childComponents = [];
        if (template) {
            this.eGui = utils_1.Utils.loadTemplate(template);
        }
    }
    Component.prototype.setTemplate = function (template) {
        this.eGui = utils_1.Utils.loadTemplate(template);
    };
    Component.prototype.addEventListener = function (eventType, listener) {
        if (!this.localEventService) {
            this.localEventService = new eventService_1.EventService();
        }
        this.localEventService.addEventListener(eventType, listener);
    };
    Component.prototype.removeEventListener = function (eventType, listener) {
        if (this.localEventService) {
            this.localEventService.removeEventListener(eventType, listener);
        }
    };
    Component.prototype.dispatchEvent = function (eventType, event) {
        if (this.localEventService) {
            this.localEventService.dispatchEvent(eventType, event);
        }
    };
    Component.prototype.getGui = function () {
        return this.eGui;
    };
    Component.prototype.queryForHtmlElement = function (cssSelector) {
        return this.eGui.querySelector(cssSelector);
    };
    Component.prototype.queryForHtmlInputElement = function (cssSelector) {
        return this.eGui.querySelector(cssSelector);
    };
    Component.prototype.appendChild = function (newChild) {
        if (utils_1.Utils.isNodeOrElement(newChild)) {
            this.eGui.appendChild(newChild);
        }
        else {
            var childComponent = newChild;
            this.eGui.appendChild(childComponent.getGui());
            this.childComponents.push(childComponent);
        }
    };
    Component.prototype.setVisible = function (visible) {
        utils_1.Utils.addOrRemoveCssClass(this.eGui, 'ag-hidden', !visible);
    };
    Component.prototype.destroy = function () {
        this.childComponents.forEach(function (childComponent) { return childComponent.destroy(); });
        this.destroyFunctions.forEach(function (func) { return func(); });
    };
    Component.prototype.addGuiEventListener = function (event, listener) {
        var _this = this;
        this.getGui().addEventListener(event, listener);
        this.destroyFunctions.push(function () { return _this.getGui().removeEventListener(event, listener); });
    };
    Component.prototype.addDestroyableEventListener = function (eElement, event, listener) {
        if (eElement instanceof HTMLElement) {
            eElement.addEventListener(event, listener);
        }
        else {
            eElement.addEventListener(event, listener);
        }
        this.destroyFunctions.push(function () {
            if (eElement instanceof HTMLElement) {
                eElement.removeEventListener(event, listener);
            }
            else {
                eElement.removeEventListener(event, listener);
            }
        });
    };
    Component.prototype.addDestroyFunc = function (func) {
        this.destroyFunctions.push(func);
    };
    return Component;
})();
exports.Component = Component;

},{"../eventService":98,"../utils":156}],159:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var component_1 = require("./component");
var context_1 = require("../context/context");
var popupService_1 = require("./popupService");
var utils_1 = require('../utils');
var svgFactory_1 = require("../svgFactory");
var svgFactory = svgFactory_1.SvgFactory.getInstance();
var MenuItemComponent = (function (_super) {
    __extends(MenuItemComponent, _super);
    function MenuItemComponent(params) {
        _super.call(this, MenuItemComponent.TEMPLATE);
        this.params = params;
        if (params.checked) {
            this.queryForHtmlElement('#eIcon').innerHTML = '&#10004;';
        }
        else if (params.icon) {
            if (utils_1.Utils.isNodeOrElement(params.icon)) {
                this.queryForHtmlElement('#eIcon').appendChild(params.icon);
            }
            else if (typeof params.icon === 'string') {
                this.queryForHtmlElement('#eIcon').innerHTML = params.icon;
            }
            else {
                console.log('ag-Grid: menu item icon must be DOM node or string');
            }
        }
        else {
            // if i didn't put space here, the alignment was messed up, probably
            // fixable with CSS but i was spending to much time trying to figure
            // it out.
            this.queryForHtmlElement('#eIcon').innerHTML = '&nbsp;';
        }
        if (params.shortcut) {
            this.queryForHtmlElement('#eShortcut').innerHTML = params.shortcut;
        }
        if (params.childMenu) {
            this.queryForHtmlElement('#ePopupPointer').appendChild(svgFactory.createSmallArrowRightSvg());
        }
        else {
            this.queryForHtmlElement('#ePopupPointer').innerHTML = '&nbsp;';
        }
        this.queryForHtmlElement('#eName').innerHTML = params.name;
        if (params.disabled) {
            utils_1.Utils.addCssClass(this.getGui(), 'ag-menu-option-disabled');
        }
        else {
            this.addGuiEventListener('click', this.onOptionSelected.bind(this));
        }
    }
    MenuItemComponent.prototype.onOptionSelected = function () {
        this.dispatchEvent(MenuItemComponent.EVENT_ITEM_SELECTED, this.params);
        if (this.params.action) {
            this.params.action();
        }
    };
    MenuItemComponent.TEMPLATE = '<div class="ag-menu-option">' +
        '  <span id="eIcon" class="ag-menu-option-icon"></span>' +
        '  <span id="eName" class="ag-menu-option-text"></span>' +
        '  <span id="eShortcut" class="ag-menu-option-shortcut"></span>' +
        '  <span id="ePopupPointer" class="ag-menu-option-popup-pointer"></span>' +
        '</div>';
    MenuItemComponent.EVENT_ITEM_SELECTED = 'itemSelected';
    __decorate([
        context_1.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], MenuItemComponent.prototype, "popupService", void 0);
    return MenuItemComponent;
})(component_1.Component);
exports.MenuItemComponent = MenuItemComponent;

},{"../context/context":87,"../svgFactory":154,"../utils":156,"./component":158,"./popupService":161}],160:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var component_1 = require("./component");
var context_1 = require("../context/context");
var utils_1 = require("../utils");
var popupService_1 = require("./popupService");
var menuItemComponent_1 = require("./menuItemComponent");
var MenuList = (function (_super) {
    __extends(MenuList, _super);
    function MenuList() {
        _super.call(this, MenuList.TEMPLATE);
        this.timerCount = 0;
    }
    MenuList.prototype.clearActiveItem = function () {
        this.removeActiveItem();
        this.removeOldChildPopup();
    };
    MenuList.prototype.addMenuItems = function (menuItems, defaultMenuItems) {
        var _this = this;
        if (utils_1.Utils.missing(menuItems)) {
            return;
        }
        menuItems.forEach(function (listItem) {
            if (listItem === 'separator') {
                _this.addSeparator();
            }
            else {
                var menuItem;
                if (typeof listItem === 'string') {
                    menuItem = defaultMenuItems[listItem];
                }
                else {
                    menuItem = listItem;
                }
                _this.addItem(menuItem);
            }
        });
    };
    MenuList.prototype.addItem = function (params) {
        var _this = this;
        var cMenuItem = new menuItemComponent_1.MenuItemComponent(params);
        this.context.wireBean(cMenuItem);
        this.getGui().appendChild(cMenuItem.getGui());
        cMenuItem.addEventListener(menuItemComponent_1.MenuItemComponent.EVENT_ITEM_SELECTED, function (event) {
            if (params.childMenu) {
                _this.showChildMenu(params, cMenuItem);
            }
            else {
                _this.dispatchEvent(menuItemComponent_1.MenuItemComponent.EVENT_ITEM_SELECTED, event);
            }
        });
        cMenuItem.addGuiEventListener('mouseenter', this.mouseEnterItem.bind(this, params, cMenuItem));
        cMenuItem.addGuiEventListener('mouseleave', function () { return _this.timerCount++; });
        if (params.childMenu) {
            this.addDestroyFunc(function () { return params.childMenu.destroy(); });
        }
    };
    MenuList.prototype.mouseEnterItem = function (menuItemParams, menuItem) {
        if (menuItemParams.disabled) {
            return;
        }
        if (this.activeMenuItemParams !== menuItemParams) {
            this.removeOldChildPopup();
        }
        this.removeActiveItem();
        this.activeMenuItemParams = menuItemParams;
        this.activeMenuItem = menuItem;
        utils_1.Utils.addCssClass(this.activeMenuItem.getGui(), 'ag-menu-option-active');
        if (menuItemParams.childMenu) {
            this.addHoverForChildPopup(menuItemParams, menuItem);
        }
    };
    MenuList.prototype.removeActiveItem = function () {
        if (this.activeMenuItem) {
            utils_1.Utils.removeCssClass(this.activeMenuItem.getGui(), 'ag-menu-option-active');
            this.activeMenuItem = null;
            this.activeMenuItemParams = null;
        }
    };
    MenuList.prototype.addHoverForChildPopup = function (menuItemParams, menuItem) {
        var _this = this;
        var timerCountCopy = this.timerCount;
        setTimeout(function () {
            var shouldShow = timerCountCopy === _this.timerCount;
            var showingThisMenu = _this.showingChildMenu === menuItemParams.childMenu;
            if (shouldShow && !showingThisMenu) {
                _this.showChildMenu(menuItemParams, menuItem);
            }
        }, 500);
    };
    MenuList.prototype.showChildMenu = function (menuItemParams, menuItem) {
        this.removeOldChildPopup();
        var ePopup = utils_1.Utils.loadTemplate('<div class="ag-menu"></div>');
        ePopup.appendChild(menuItemParams.childMenu.getGui());
        this.childPopupRemoveFunc = this.popupService.addAsModalPopup(ePopup, true);
        this.popupService.positionPopupForMenu({
            eventSource: menuItem.getGui(),
            ePopup: ePopup
        });
        this.showingChildMenu = menuItemParams.childMenu;
    };
    MenuList.prototype.addSeparator = function () {
        this.getGui().appendChild(utils_1.Utils.loadTemplate(MenuList.SEPARATOR_TEMPLATE));
    };
    MenuList.prototype.removeOldChildPopup = function () {
        if (this.childPopupRemoveFunc) {
            this.showingChildMenu.clearActiveItem();
            this.childPopupRemoveFunc();
            this.childPopupRemoveFunc = null;
            this.showingChildMenu = null;
        }
    };
    MenuList.prototype.destroy = function () {
        this.removeOldChildPopup();
        _super.prototype.destroy.call(this);
    };
    MenuList.TEMPLATE = '<div class="ag-menu-list"></div>';
    MenuList.SEPARATOR_TEMPLATE = '<div class="ag-menu-separator">' +
        '  <span class="ag-menu-separator-cell"></span>' +
        '  <span class="ag-menu-separator-cell"></span>' +
        '  <span class="ag-menu-separator-cell"></span>' +
        '  <span class="ag-menu-separator-cell"></span>' +
        '</div>';
    __decorate([
        context_1.Autowired('context'), 
        __metadata('design:type', context_1.Context)
    ], MenuList.prototype, "context", void 0);
    __decorate([
        context_1.Autowired('popupService'), 
        __metadata('design:type', popupService_1.PopupService)
    ], MenuList.prototype, "popupService", void 0);
    return MenuList;
})(component_1.Component);
exports.MenuList = MenuList;

},{"../context/context":87,"../utils":156,"./component":158,"./menuItemComponent":159,"./popupService":161}],161:[function(require,module,exports){
/**
 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
 * @version v4.2.6
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var utils_1 = require('../utils');
var constants_1 = require("../constants");
var context_1 = require("../context/context");
var gridCore_1 = require("../gridCore");
var PopupService = (function () {
    function PopupService() {
    }
    // this.popupService.setPopupParent(this.eRootPanel.getGui());
    PopupService.prototype.getPopupParent = function () {
        return this.gridCore.getRootGui();
    };
    PopupService.prototype.positionPopupForMenu = function (params) {
        var sourceRect = params.eventSource.getBoundingClientRect();
        var parentRect = this.getPopupParent().getBoundingClientRect();
        var x = sourceRect.right - parentRect.left - 2;
        var y = sourceRect.top - parentRect.top;
        var minWidth;
        if (params.ePopup.clientWidth > 0) {
            minWidth = params.ePopup.clientWidth;
        }
        else {
            minWidth = 200;
        }
        var widthOfParent = parentRect.right - parentRect.left;
        var maxX = widthOfParent - minWidth;
        if (x > maxX) {
            // try putting menu to the left
            x = sourceRect.left - minWidth;
        }
        if (x < 0) {
            x = 0;
        }
        params.ePopup.style.left = x + "px";
        params.ePopup.style.top = y + "px";
    };
    PopupService.prototype.positionPopupUnderMouseEvent = function (params) {
        var parentRect = this.getPopupParent().getBoundingClientRect();
        this.positionPopup({
            ePopup: params.ePopup,
            x: params.mouseEvent.clientX - parentRect.left,
            y: params.mouseEvent.clientY - parentRect.top,
            keepWithinBounds: true
        });
    };
    PopupService.prototype.positionPopupUnderComponent = function (params) {
        var sourceRect = params.eventSource.getBoundingClientRect();
        var parentRect = this.getPopupParent().getBoundingClientRect();
        this.positionPopup({
            ePopup: params.ePopup,
            minWidth: params.minWidth,
            nudgeX: params.nudgeX,
            nudgeY: params.nudgeY,
            x: sourceRect.left - parentRect.left,
            y: sourceRect.top - parentRect.top + sourceRect.height,
            keepWithinBounds: params.keepWithinBounds
        });
    };
    PopupService.prototype.positionPopupOverComponent = function (params) {
        var sourceRect = params.eventSource.getBoundingClientRect();
        var parentRect = this.getPopupParent().getBoundingClientRect();
        this.positionPopup({
            ePopup: params.ePopup,
            minWidth: params.minWidth,
            nudgeX: params.nudgeX,
            nudgeY: params.nudgeY,
            x: sourceRect.left - parentRect.left,
            y: sourceRect.top - parentRect.top,
            keepWithinBounds: params.keepWithinBounds
        });
    };
    PopupService.prototype.positionPopup = function (params) {
        var parentRect = this.getPopupParent().getBoundingClientRect();
        var x = params.x;
        var y = params.y;
        if (params.nudgeX) {
            x += params.nudgeX;
        }
        if (params.nudgeY) {
            y += params.nudgeY;
        }
        // if popup is overflowing to the right, move it left
        if (params.keepWithinBounds) {
            var minWidth;
            if (params.minWidth > 0) {
                minWidth = params.minWidth;
            }
            else if (params.ePopup.clientWidth > 0) {
                minWidth = params.ePopup.clientWidth;
            }
            else {
                minWidth = 200;
            }
            var widthOfParent = parentRect.right - parentRect.left;
            var maxX = widthOfParent - minWidth;
            if (x > maxX) {
                x = maxX;
            }
            if (x < 0) {
                x = 0;
            }
        }
        params.ePopup.style.left = x + "px";
        params.ePopup.style.top = y + "px";
    };
    //adds an element to a div, but also listens to background checking for clicks,
    //so that when the background is clicked, the child is removed again, giving
    //a model look to popups.
    PopupService.prototype.addAsModalPopup = function (eChild, closeOnEsc, closedCallback) {
        var eBody = document.body;
        if (!eBody) {
            console.warn('ag-grid: could not find the body of the document, document.body is empty');
            return;
        }
        var popupAlreadyShown = utils_1.Utils.isVisible(eChild);
        if (popupAlreadyShown) {
            return;
        }
        this.getPopupParent().appendChild(eChild);
        var that = this;
        var popupHidden = false;
        // if we add these listeners now, then the current mouse
        // click will be included, which we don't want
        setTimeout(function () {
            if (closeOnEsc) {
                eBody.addEventListener('keydown', hidePopupOnEsc);
            }
            eBody.addEventListener('click', hidePopup);
            eBody.addEventListener('contextmenu', hidePopup);
            //eBody.addEventListener('mousedown', hidePopup);
            eChild.addEventListener('click', consumeClick);
            //eChild.addEventListener('mousedown', consumeClick);
        }, 0);
        var eventFromChild = null;
        function hidePopupOnEsc(event) {
            var key = event.which || event.keyCode;
            if (key === constants_1.Constants.KEY_ESCAPE) {
                hidePopup(null);
            }
        }
        function hidePopup(event) {
            if (event && event === eventFromChild) {
                return;
            }
            // this method should only be called once. the client can have different
            // paths, each one wanting to close, so this method may be called multiple
            // times.
            if (popupHidden) {
                return;
            }
            popupHidden = true;
            that.getPopupParent().removeChild(eChild);
            eBody.removeEventListener('keydown', hidePopupOnEsc);
            //eBody.removeEventListener('mousedown', hidePopupOnEsc);
            eBody.removeEventListener('click', hidePopup);
            eBody.removeEventListener('contextmenu', hidePopup);
            eChild.removeEventListener('click', consumeClick);
            //eChild.removeEventListener('mousedown', consumeClick);
            if (closedCallback) {
                closedCallback();
            }
        }
        function consumeClick(event) {
            eventFromChild = event;
        }
        return hidePopup;
    };
    __decorate([
        context_1.Autowired('gridCore'), 
        __metadata('design:type', gridCore_1.GridCore)
    ], PopupService.prototype, "gridCore", void 0);
    PopupService = __decorate([
        context_1.Bean('popupService'), 
        __metadata('design:paramtypes', [])
    ], PopupService);
    return PopupService;
})();
exports.PopupService = PopupService;

},{"../constants":86,"../context/context":87,"../gridCore":108,"../utils":156}],162:[function(require,module,exports){

////////// MAKE SURE YOU EDIT main-webpack.js IF EDITING THIS FILE!!!

var populateClientExports = require('./dist/lib/clientExports').populateClientExports;
populateClientExports(exports);

},{"./dist/lib/clientExports":74}]},{},[56])